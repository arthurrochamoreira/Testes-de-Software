{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Documenta\u00e7\u00e3o pessoal sobre Testes de Software, desenvolvida como apoio aos estudos da disciplina cursada na gradua\u00e7\u00e3o em Engenharia de Software.</p> <ul> <li>xUnit Test Patterns (Meszaros, 2007)</li> <li>Test-Driven Development: By Example (Kent Beck, 2002)</li> <li>The Art of Software Testing (Glenford J. Myers, 2011)</li> <li>xUnit Test Patterns (Meszaros, 2007)</li> <li>Test-Driven Development: By Example (Kent Beck, 2002)</li> <li>The Art of Software Testing (Glenford J. Myers, 2011)</li> </ul>"},{"location":"aae3/aae3/","title":"1. Relat\u00f3rio de Cobertura MC/DC \u2014 Atividade AAE-3","text":""},{"location":"aae3/aae3/#11-objetivo","title":"1.1 Objetivo","text":"<p>Elaborar o menor conjunto de casos de teste que garanta 100% de cobertura segundo o crit\u00e9rio MC/DC para o m\u00e9todo <code>isNumber(String number)</code> abaixo:</p> <pre><code>public boolean isNumber(String number) {\n    if (number == null || number.isEmpty()) {\n        return false;\n    }\n\n    if (number.length() == 1 &amp;&amp; (number.charAt(0) == '-' || number.charAt(0) == '+')) {\n        return false;\n    }\n\n    for (int i = 0; i &lt; number.length(); i++) {\n        char c = number.charAt(i);\n\n        if (i == 0 &amp;&amp; (c == '-' || c == '+')) {\n            continue;\n        } else if (!Character.isDigit(c)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n</code></pre>"},{"location":"aae3/aae3/#12-recapitulando-mcdc","title":"1.2 Recapitulando MC/DC","text":"<p>MC/DC (Cobertura de Decis\u00e3o/Condi\u00e7\u00e3o Modificada) \u00e9 uma t\u00e9cnica de teste que exige:</p> <ol> <li>Que cada condi\u00e7\u00e3o booleana dentro de uma decis\u00e3o seja avaliada como verdadeira e falsa.</li> <li>Que, para cada condi\u00e7\u00e3o, seja demonstrado que ela, isoladamente, pode alterar o resultado da decis\u00e3o.</li> </ol>"},{"location":"aae3/aae3/#exemplo-if-a-b","title":"Exemplo: <code>if (A &amp;&amp; B)</code>","text":"Caso A B Resultado O que muda? D-Ex-T1 F V F Base para testar A D-Ex-T2 V V V (B = V; A muda F \u2192 V; resultado muda F \u2192 V) \u2713 D-Ex-T3 V F F Base para testar B D-Ex-T4 V V V (A = V; B muda F \u2192 V; resultado muda F \u2192 V) \u2713"},{"location":"aae3/aae3/#decisoes-validas-em-mcdc","title":"Decis\u00f5es v\u00e1lidas em MC/DC","text":"<p>Uma decis\u00e3o v\u00e1lida \u00e9 qualquer express\u00e3o booleana que:</p> <ul> <li>Controle o fluxo (<code>if</code>, <code>while</code>, <code>for</code>, <code>else if</code> etc.).</li> <li>Seja composta por duas ou mais condi\u00e7\u00f5es ligadas por <code>&amp;&amp;</code> ou <code>||</code>.</li> <li>Permita que cada condi\u00e7\u00e3o, isoladamente, altere o resultado.</li> </ul> <p>Nota:</p> <ul> <li>Condi\u00e7\u00f5es de la\u00e7o sem m\u00faltiplas vari\u00e1veis (ex.: <code>i &lt; n</code> em <code>for</code>) n\u00e3o precisam de MC/DC.</li> </ul>"},{"location":"aae3/aae3/#2-primeira-decisao-linha-2","title":"2. Primeira decis\u00e3o (linha 2)","text":"<pre><code>if (number == null || number.isEmpty()) {\n    return false;\n}\n</code></pre> <ul> <li>C1: <code>number == null</code></li> <li>C2: <code>number.isEmpty()</code></li> </ul>"},{"location":"aae3/aae3/#estrutura-logica","title":"Estrutura l\u00f3gica","text":"<pre><code>C1 || C2\n</code></pre> <p>Se a string for nula ou estiver vazia, retorna false</p>"},{"location":"aae3/aae3/#tabela-verdade-de-c1-c2","title":"Tabela-verdade de <code>C1 || C2</code>","text":"Caso C1 C2 Resultado D1-T1 F F F D1-T2 F V V D1-T3 V F V D1-T4 V V V"},{"location":"aae3/aae3/#pares-mcdc","title":"Pares MC/DC","text":"<ul> <li>C1: (C2 = F; C1 muda F \u2192 V; resultado muda F \u2192 V) \u2014 D1-T1 vs D1-T3</li> <li>C2: (C1 = F; C2 muda F \u2192 V; resultado muda F \u2192 V) \u2014 D1-T1 vs D1-T2</li> </ul>"},{"location":"aae3/aae3/#3-segunda-decisao-linha-5","title":"3. Segunda decis\u00e3o (linha 5)","text":"<pre><code>if (number.length() == 1 &amp;&amp; (number.charAt(0) == '-' || number.charAt(0) == '+')) {\n    return false;\n}\n</code></pre> <ul> <li>C3: <code>number.length() == 1</code></li> <li>C4: <code>number.charAt(0) == '-'</code></li> <li>C5: <code>number.charAt(0) == '+'</code></li> </ul>"},{"location":"aae3/aae3/#estrutura-logica_1","title":"Estrutura l\u00f3gica","text":"<pre><code>C3 &amp;&amp; (C4 || C5)\n</code></pre> <p>Se h\u00e1 um caractere e ele \u00e9 \u2018-\u2019 ou \u2018+\u2019, retorna false</p>"},{"location":"aae3/aae3/#tabela-verdade-de-c3-c4-c5","title":"Tabela-verdade de <code>C3 &amp;&amp; (C4 || C5)</code>","text":"Caso C3 C4 C5 Resultado D2-T1 V V F V D2-T2 V F V V D2-T3 V F F F D2-T4 F \u2013 \u2013 F"},{"location":"aae3/aae3/#pares-mcdc_1","title":"Pares MC/DC","text":"<ul> <li>C3: (C4 = V; C5 = F; C3 muda V \u2192 F; resultado muda V \u2192 F) \u2014 D2-T1 vs D2-T4</li> <li>C4: (C3 = V; C5 = F; C4 muda V \u2192 F; resultado muda V \u2192 F) \u2014 D2-T1 vs D2-T3</li> <li>C5: (C3 = V; C4 = F; C5 muda V \u2192 F; resultado muda V \u2192 F) \u2014 D2-T2 vs D2-T3</li> </ul>"},{"location":"aae3/aae3/#4-terceira-decisao-linha-10","title":"4. Terceira decis\u00e3o (linha 10)","text":"<pre><code>if (i == 0 &amp;&amp; (c == '-' || c == '+')) {\n    continue;\n}\n</code></pre> <ul> <li>C6: <code>i == 0</code></li> <li>C7: <code>c == '-'</code></li> <li>C8: <code>c == '+'</code></li> </ul>"},{"location":"aae3/aae3/#estrutura-logica_2","title":"Estrutura l\u00f3gica","text":"<pre><code>C6 &amp;&amp; (C7 || C8)\n</code></pre> <p>Se \u00e9 o primeiro caractere e ele \u00e9 \u2018-\u2019 ou \u2018+\u2019, ignora e segue</p>"},{"location":"aae3/aae3/#tabela-verdade-de-c6-c7-c8","title":"Tabela-verdade de <code>C6 &amp;&amp; (C7 || C8)</code>","text":"Caso C6 C7 C8 Resultado D3-T1 F \u2013 \u2013 F D3-T2 V V F V D3-T3 V F V V D3-T4 V F F F"},{"location":"aae3/aae3/#pares-mcdc_2","title":"Pares MC/DC","text":"<ul> <li>C6: (C7 = V; C8 = F; C6 muda F \u2192 V; resultado muda F \u2192 V) \u2014 D3-T1 vs D3-T2</li> <li>C7: (C6 = V; C8 = F; C7 muda V \u2192 F; resultado muda V \u2192 F) \u2014 D3-T2 vs D3-T4</li> <li>C8: (C6 = V; C7 = F; C8 muda V \u2192 F; resultado muda V \u2192 F) \u2014 D3-T3 vs D3-T4</li> </ul>"},{"location":"aae3/aae3/#5-resumo-dos-pares-mcdc","title":"5. Resumo dos pares MC/DC","text":"<ul> <li>Decis\u00e3o 1 (C1, C2): D1-T1 vs D1-T3; D1-T1 vs D1-T2</li> <li>Decis\u00e3o 2 (C3, C4, C5): D2-T1 vs D2-T4; D2-T1 vs D2-T3; D2-T2 vs D2-T3</li> <li>Decis\u00e3o 3 (C6, C7, C8): D3-T1 vs D3-T2; D3-T2 vs D3-T4; D3-T3 vs D3-T4</li> </ul>"},{"location":"aae3/aae3/#6-conclusao","title":"6. Conclus\u00e3o","text":"<p>Com o conjunto de 12 casos de teste (D1-T1 a D1-T4, D2-T1 a D2-T4 e D3-T1 a D3-T4), cada condi\u00e7\u00e3o C1\u2013C8 foi avaliada como verdadeira e falsa e demonstrou, isoladamente, sua capacidade de alterar o resultado da decis\u00e3o. Assim, alcan\u00e7amos 100% de cobertura segundo o crit\u00e9rio MC/DC para o m\u00e9todo <code>isNumber</code>.</p>"},{"location":"aae3/aae3/#7-referencias-bibliograficas","title":"7. Refer\u00eancias Bibliogr\u00e1ficas","text":"<ol> <li>Myers, G. J., Sandler, C., &amp; Badgett, T. (2011). The Art of Software Testing (3rd ed.). Wiley. pp. 46\u201348.</li> <li>RTCA/DO-178C. (2011). Software Considerations in Airborne Systems and Equipment Certification. RTCA.</li> <li>ISO/IEC/IEEE 29119. (2013). Software and Systems Engineering \u2014 Software Testing. ISO/IEC/IEEE.</li> </ol>"},{"location":"aae3/mc_dc/","title":"Modified Condition/Decision Coverage (MC/DC)","text":"<p>O Modified Condition/Decision Coverage (MC/DC) \u00e9 um dos crit\u00e9rios de cobertura estrutural mais exigentes para software de alta criticidade (por exemplo: avia\u00e7\u00e3o, automotivo, ferrovi\u00e1rio, etc.). O MC/DC est\u00e1 definido na norma DO-178B/C da FAA e \u00e9 referenciado em normas como ISO 26262 (automotiva) e IEC 61508 (industrial). Uma apresenta\u00e7\u00e3o detalhada pode ser encontrada em Hayhurst et al. (2001).</p> <p>Veja uma explica\u00e7\u00e3o pr\u00e1tica e visual no v\u00eddeo a seguir:</p>"},{"location":"aae3/mc_dc/#1-definicao-formal","title":"1. Defini\u00e7\u00e3o Formal","text":"<p>De acordo com o DO-178C </p> <p>O MC/DC requer que, para cada decis\u00e3o (uma express\u00e3o booleana composta) no c\u00f3digo, sejam atendidos simultaneamente:</p> <ol> <li>Cada ponto de entrada e sa\u00edda seja invocado ao menos uma vez.</li> <li>A decis\u00e3o tome cada um de seus poss\u00edveis resultados (verdadeiro/falso).</li> <li>Cada condi\u00e7\u00e3o atinja cada valor (verdadeiro/falso) ao menos uma vez.</li> <li>Cada condi\u00e7\u00e3o seja mostrada como tendo influ\u00eancia independente sobre o resultado da decis\u00e3o, mudando-a quando somente ela for invertida, mantendo-se fixas todas as demais.</li> </ol> <p>O item 4 \u00e9 o que diferencia o MC/DC: deve-se provar que apenas invertendo uma condi\u00e7\u00e3o \u2014 sem alterar as demais \u2014 o resultado da decis\u00e3o tamb\u00e9m inverte.</p>"},{"location":"aae3/mc_dc/#2-exemplo-pratico","title":"2. Exemplo Pr\u00e1tico","text":"<p>Considere a decis\u00e3o:</p> <pre><code>D = A &amp;&amp; B &amp;&amp; C\n</code></pre> Caso A B C D = A\u2227B\u2227C 1 True True True True 2 True True False False 3 True False True False 4 True False False False 5 False True True False 6 False True False False 7 False False True False 8 False False False False <p>Para atingir 100\u202f% de MC/DC, al\u00e9m de cobrir as condi\u00e7\u00f5es e decis\u00f5es, precisamos demonstrar a independ\u00eancia de cada condi\u00e7\u00e3o.</p>"},{"location":"aae3/mc_dc/#21-independencia-de-a","title":"2.1. Independ\u00eancia de A","text":"<p>Mant\u00e9m B = True e C = True, varia apenas A:</p> Caso A B C D = A\u2227B\u2227C 1 True True True True 5 False True True False"},{"location":"aae3/mc_dc/#22-independencia-de-b","title":"2.2. Independ\u00eancia de B","text":"<p>Mant\u00e9m A = True e C = True, varia apenas B:</p> Caso A B C D = A\u2227B\u2227C 1 True True True True 3 True False True False"},{"location":"aae3/mc_dc/#23-independencia-de-c","title":"2.3. Independ\u00eancia de C","text":"<p>Mant\u00e9m A = True e B = True, varia apenas C:</p> Caso A B C D = A\u2227B\u2227C 1 True True True True 2 True True False False"},{"location":"aae3/mc_dc/#3-vantagens-e-aplicacoes","title":"3. Vantagens e Aplica\u00e7\u00f5es","text":"<ul> <li>Redu\u00e7\u00e3o de riscos: garante que cada condi\u00e7\u00e3o individualmente impacta o resultado, revelando erros mascarados.</li> <li>Requisito normativo: n\u00edvel A em avia\u00e7\u00e3o exige 100\u202f% MC/DC (DO-178C, Tabela A-7); tamb\u00e9m recomendado para SIL\u202f4 (IEC\u00a061508) e ASIL\u202fD (ISO\u00a026262).</li> <li>Efici\u00eancia: exige menos testes que a cobertura de todas as combina\u00e7\u00f5es (Multiple Condition Coverage), mantendo rigor.</li> </ul>"},{"location":"aae3/mc_dc/#4-referencias-bibliograficas","title":"4. Refer\u00eancias Bibliogr\u00e1ficas","text":"<ol> <li>Kelly\u00a0J. Hayhurst, Dan\u00a0S. Veerhusen, John\u00a0D. Chilenski e Leanna\u00a0R. Rierson. A Practical Tutorial on Modified Condition/Decision Coverage, NASA TM-2001-210876, 2001.</li> <li>FAA. Guidelines for the Use of the Modified Condition/Decision Coverage (MC/DC) Criterion, CAST-10, 2020.</li> <li>RTCA/DO-178C. Software Considerations in Airborne Systems and Equipment Certification, 2011.</li> <li>ISO\u00a026262:2011. Road vehicles \u2013 Functional safety, Parte\u00a06.</li> <li>IEC\u00a061508-3:2010. Functional safety of electrical/electronic/programmable electronic safety-related systems, Anexo\u00a0B.</li> <li>Myers, G. J., Sandler, C., &amp; Badgett, T. (2011). The Art of Software Testing (3rd ed.). Wiley. pp. 46\u201348.</li> </ol>"},{"location":"aae3/unit_test/","title":"Teste de Unidade","text":""},{"location":"aae3/unit_test/#3-piramide-de-testes","title":"3. Pir\u00e2mide de Testes","text":"<p>A Pir\u00e2mide de Testes ilustra como equilibrar velocidade, custo e cobertura ao estruturar sua su\u00edte de testes (Meszaros, 2007):</p> <p></p> N\u00edvel Quantidade de Testes Custo por Teste Velocidade de Execu\u00e7\u00e3o Exemplos de Ferramentas Aceita\u00e7\u00e3o Baixa Alto Muito Lenta Cucumber, Robot Framework Sistema M\u00e9dia M\u00e9dio Lenta Selenium, TestComplete Integra\u00e7\u00e3o M\u00e9dia\u2013Alta Baixo\u2013M\u00e9dio Moderada Pytest + Docker Compose, Postman Unidade Alta Baixo Muito R\u00e1pida pytest, unittest, Jest <ul> <li>Unidade (base) </li> <li>O que: Testes de fun\u00e7\u00e3o/m\u00e9todo isolado.  </li> <li>Por que: R\u00e1pidos e baratos; detectam defeitos de l\u00f3gica interna antes de integrar depend\u00eancias.  </li> <li>Integra\u00e7\u00e3o (camada intermedi\u00e1ria) </li> <li>O que: Testes de m\u00faltiplos m\u00f3dulos funcionando juntos (por exemplo, servi\u00e7o + banco de dados).  </li> <li>Por que: Verifica contratos/interfaces, detecta erros de comunica\u00e7\u00e3o e configura\u00e7\u00e3o.  </li> <li>Sistema (\u00faltima camada antes da aceita\u00e7\u00e3o) </li> <li>O que: Testes fim-a-fim que exercitam todo o sistema em ambiente real ou simulado.  </li> <li>Por que: Confirma fluxo completo (UI \u2192 backend \u2192 DB), mas custa mais manter.  </li> <li>Aceita\u00e7\u00e3o (topo) </li> <li>O que: Valida\u00e7\u00e3o contra requisitos de neg\u00f3cio por meio de cen\u00e1rios escritos em linguagem natural.  </li> <li>Por que: Garante que o software atenda \u00e0s expectativas do usu\u00e1rio, mas demora para rodar.</li> </ul> <p>Eixos - Velocidade: decresce de unidades \u2192 aceita\u00e7\u00e3o. - Custo: cresce de unidades \u2192 aceita\u00e7\u00e3o. - Quantidade: cresce de aceita\u00e7\u00e3o \u2192 unidades.</p>"},{"location":"aae3/unit_test/#4-outros-formatos-de-estrategia","title":"4. Outros Formatos de Estrat\u00e9gia","text":""},{"location":"aae3/unit_test/#a-the-testing-trophy","title":"A. The Testing Trophy","text":"<p>Desenvolvida por Kent C. Dodds para aplica\u00e7\u00f5es web modernas:</p> <p></p> <ul> <li>Static: detec\u00e7\u00e3o de erros sem execu\u00e7\u00e3o (ESLint, mypy).  </li> <li>Unit: l\u00f3gica interna (Jest, pytest).  </li> <li>Integration: contratos entre m\u00f3dulos (Testing Library, pytest-docker).  </li> <li>End to End: simula\u00e7\u00e3o completa de usu\u00e1rio (Cypress, Playwright).   <p>Meta: Keep static and unit tests em larga quantidade, reduzindo gradualmente at\u00e9 E2E (Dodds, 2020).</p> </li> </ul>"},{"location":"aae3/unit_test/#b-microservices-test-strategy","title":"B. Microservices Test Strategy","text":"<p>Abordagem do Spotify Labs para arquiteturas de microsservi\u00e7os:</p> <ol> <li>Implementation Detail: validar l\u00f3gica isolada de cada servi\u00e7o (testes de unidade profundas).  </li> <li>Integration: testar comunica\u00e7\u00e3o entre pares de servi\u00e7os (contratos de API).  </li> <li>Integrated: executar conjunto completo de microsservi\u00e7os simulando produ\u00e7\u00e3o (fluxos end-to-end).   <p>Recomenda\u00e7\u00e3o: minimizar testes de detalhe interno, focar em Integration e Integrated (Spotify Labs, 2019).</p> </li> </ol>"},{"location":"aae3/unit_test/#5-niveis-de-teste-beneficios","title":"5. N\u00edveis de Teste \u2013 Benef\u00edcios","text":"<ol> <li>Evita redund\u00e2ncia </li> <li>Cada n\u00edvel foca em diferentes categorias de defeitos (Myers et al., 2012).  </li> <li>Custo x Risco </li> <li>Detectar cedo (unidade) corrige barato; detectar tarde (aceita\u00e7\u00e3o) corrige caro.  </li> <li>Escalabilidade </li> <li>Pequenos projetos podem parar em integra\u00e7\u00e3o; projetos cr\u00edticos devem chegar \u00e0 aceita\u00e7\u00e3o.  </li> </ol>"},{"location":"aae3/unit_test/#6-niveis-de-teste-consideracoes","title":"6. N\u00edveis de Teste \u2013 Considera\u00e7\u00f5es","text":"<ul> <li>N\u00e3o s\u00e3o sequenciais: escolha n\u00edveis conforme risco, or\u00e7amento e complexidade do projeto.  </li> <li>Fatores a influenciar a estrat\u00e9gia: </li> <li>Grau de acoplamento e coes\u00e3o do sistema.  </li> <li>Frequ\u00eancia de mudan\u00e7as nos componentes.  </li> <li>Recursos de infraestrutura (tempo de build, ambientes de teste).  </li> </ul>"},{"location":"aae3/unit_test/#7-diagrama-de-correspondencia-de-niveis","title":"7. Diagrama de Correspond\u00eancia de N\u00edveis","text":""},{"location":"aae3/unit_test/#8-lista-de-niveis-de-teste","title":"8. Lista de N\u00edveis de Teste","text":"<ol> <li>Unidade \u2013 testar o menor bloco de c\u00f3digo isoladamente.  </li> <li>Integra\u00e7\u00e3o \u2013 validar a intera\u00e7\u00e3o entre m\u00f3dulos.  </li> <li>Fun\u00e7\u00e3o \u2013 foco em funcionalidades discretas, similar a testes de sistema menores.  </li> <li>Sistema \u2013 testes de ponta a ponta num ambiente completo.  </li> <li>Aceita\u00e7\u00e3o \u2013 valida\u00e7\u00e3o contra crit\u00e9rios de aceite do cliente.</li> </ol>"},{"location":"aae3/unit_test/#9-testes-de-unidade","title":"9. Testes de Unidade","text":"<p>Defini\u00e7\u00e3o (Myers, 2012): Processo de testar fun\u00e7\u00f5es, m\u00e9todos, procedimentos, sub-rotinas ou subprogramas individualmente, garantindo que cada unidade isolada se comporte conforme a especifica\u00e7\u00e3o.</p> <ul> <li>Objetivo: verificar o menor elemento test\u00e1vel de um software.  </li> <li>Procedural: fun\u00e7\u00e3o ou procedimento.  </li> <li>Orientado a objeto: m\u00e9todo de classe.  </li> <li>Respons\u00e1vel: geralmente o desenvolvedor.  </li> <li>Enfoque: algoritmos e l\u00f3gica de programa\u00e7\u00e3o.  </li> <li>T\u00e9cnicas: tipicamente caixa-branca, complementada por caixa-preta.</li> </ul> <p>Motiva\u00e7\u00f5es: - Gerenciar incrementalmente os elementos do teste. - Facilitar a depura\u00e7\u00e3o (localiza\u00e7\u00e3o de defeitos). - Permitir paralelismo na execu\u00e7\u00e3o dos testes.</p>"},{"location":"aae3/unit_test/#91-ferramentas-em-python","title":"9.1. Ferramentas em Python","text":"Ferramenta Caracter\u00edsticas Refer\u00eancia <code>unittest</code> Framework padr\u00e3o, estilo xUnit. Python Software Foundation (2024). <code>pytest</code> Sintaxe concisa, fixtures, parametriza\u00e7\u00e3o e plugins. pytest Documentation (2024). <code>coverage.py</code> Medi\u00e7\u00e3o de cobertura de c\u00f3digo. Ned Batchelder (2024)."},{"location":"aae3/unit_test/#92-exemplo-simples-funcao-is_even","title":"9.2. Exemplo Simples: Fun\u00e7\u00e3o <code>is_even</code>","text":"<pre><code># utils.py\ndef is_even(n: int) -&gt; bool:\n    \"\"\"\n    Retorna True se n for par, False caso contr\u00e1rio.\n    \"\"\"\n    return n % 2 == 0\n</code></pre>"},{"location":"aae3/unit_test/#921-testes-com-pytest","title":"9.2.1. Testes com <code>pytest</code>","text":"<pre><code># tests/test_utils.py\nimport pytest\nfrom utils import is_even\n\n@pytest.mark.parametrize(\"input,expected\", [\n    (0, True),\n    (1, False),\n    (2, True),\n    (99, False),\n])\ndef test_is_even(input, expected):\n    assert is_even(input) == expected\n</code></pre> <ul> <li>Casos de teste:</li> <li><code>0</code> \u2192 <code>True</code></li> <li><code>1</code> \u2192 <code>False</code></li> <li><code>2</code> \u2192 <code>True</code></li> <li><code>99</code> \u2192 <code>False</code></li> </ul>"},{"location":"aae3/unit_test/#922-teste-caixa-branca-cobertura-de-decisao","title":"9.2.2. Teste Caixa-Branca (Cobertura de Decis\u00e3o)","text":"<pre><code>def test_is_even_branches():\n    # testa tanto o ramo True quanto o ramo False\n    assert is_even(4) is True\n    assert is_even(5) is False\n</code></pre> <ul> <li>Com isso garantimos que ambas as sa\u00eddas (<code>True</code> e <code>False</code>) ocorram ao menos uma vez.</li> </ul>"},{"location":"aae3/unit_test/#93-criterios-de-cobertura","title":"9.3. Crit\u00e9rios de Cobertura","text":"Crit\u00e9rio Descri\u00e7\u00e3o Cobertura de decis\u00f5es Garante que <code>n % 2 == 0</code> avalie <code>True</code> e <code>False</code> Cobertura de instru\u00e7\u00f5es Garante execu\u00e7\u00e3o da \u00fanica linha da fun\u00e7\u00e3o <pre><code># Gerando relat\u00f3rio de cobertura\ncoverage run -m pytest &amp;&amp; coverage report -m\n</code></pre> <pre><code>Name           Stmts   Miss  Cover\n----------------------------------\nutils.py           3      0   100%\n</code></pre>"},{"location":"aae3/unit_test/#12-referencias-bibliograficas","title":"12. Refer\u00eancias Bibliogr\u00e1ficas","text":"<ul> <li>Myers, G. J., Sandler, C., &amp; Badgett, T. (2012). The Art of Software Testing. John Wiley &amp; Sons.  </li> <li>pytest Development Team. (2024). pytest documentation. Retrieved from https://docs.pytest.org/  </li> <li>Ned Batchelder. (2024). coverage.py documentation. Retrieved from https://coverage.readthedocs.io/  </li> <li>Meszaros, G. (2007). xUnit Test Patterns: Refactoring Test Code. Addison-Wesley.  </li> <li>Dodds, K. C. (2020). The Testing Trophy.  </li> <li>Spotify Labs. (2019). Microservices Test Strategy</li> </ul>"},{"location":"aae3/white_box_test/","title":"Cap\u00edtulo 4 \u2013  Teste de Caixa Branca","text":"<p>Outra estrat\u00e9gia de teste, o teste de caixa branca (ou orientado por l\u00f3gica), permite que voc\u00ea examine a estrutura interna do programa. Essa estrat\u00e9gia deriva dados de teste de um exame da l\u00f3gica do programa (e muitas vezes, infelizmente, negligenciando a especifica\u00e7\u00e3o).</p> <p>O objetivo neste ponto \u00e9 estabelecer, para esta estrat\u00e9gia, o teste de entrada an\u00e1logo ao exaustivo na abordagem de caixa preta. Fazer com que todas as instru\u00e7\u00f5es do programa sejam executadas pelo menos uma vez pode parecer ser a resposta, mas n\u00e3o \u00e9 dif\u00edcil mostrar que isso \u00e9 altamente inadequado. Sem insistir no ponto aqui, uma vez que esse assunto \u00e9 discutido com mais profundidade no Cap\u00edtulo 4, o an\u00e1logo geralmente \u00e9 considerado um teste de caminho exaustivo. Ou seja, se voc\u00ea executar, via casos de teste, todos os caminhos poss\u00edveis de controle fluem pelo programa, ent\u00e3o, possivelmente, o programa foi completamente testado.</p> <p>Existem duas falhas nesta afirma\u00e7\u00e3o, no entanto. Uma \u00e9 que o n\u00famero de caminhos l\u00f3gicos \u00fanicos atrav\u00e9s de um programa pode ser astronomicamente grande. Para ver isso, considere o programa trivial representado na Figura 2.1. O diagrama \u00e9 um gr\u00e1fico de fluxo de controle. Cada n\u00f3 ou c\u00edrculo representa um segmento de instru\u00e7\u00f5es que s\u00e3o executadas sequencialmente, possivelmente terminando com uma branching statement. Cada aresta ou arco representa uma transfer\u00eancia de controle (ramifica\u00e7\u00e3o) entre segmentos. O diagrama, ent\u00e3o, descreve um programa de 10 a 20 instru\u00e7\u00f5es que consiste em um loop DO que itera at\u00e9 20 vezes. Dentro do corpo do loop DO, h\u00e1 um conjunto de instru\u00e7\u00f5es IF aninhadas. Determinar o n\u00famero de caminhos l\u00f3gicos \u00fanicos \u00e9 o mesmo que determinar o n\u00famero total de maneiras \u00fanicas de se mover do ponto A para o ponto B (assumindo que todas as decis\u00f5es no programa s\u00e3o independentes umas das outras). Este n\u00famero \u00e9 aproximadamente 10\u00b9\u2074.</p> <p>FIGURA 2.1: Gr\u00e1fico de fluxo de controle de um pequeno programa.</p> <p>100 trilh\u00f5es. \u00c9 calculado a partir de 5\u00b2\u2070 + 5\u00b9\u2079 + ... + 5\u00b9, onde 5 \u00e9 o n\u00famero de caminhos atrav\u00e9s do corpo do loop. A maioria das pessoas tem dificuldade em visualizar esse n\u00famero, ent\u00e3o considere desta forma: se voc\u00ea pudesse escrever, executar e verificar um caso de teste a cada cinco minutos, levaria aproximadamente 1 bilh\u00e3o de anos para tentar todos os caminhos. Se voc\u00ea fosse 300 vezes mais r\u00e1pido, completando um teste uma vez por segundo, voc\u00ea poderia completar o trabalho em 3,2 milh\u00f5es de anos, dar ou tirar alguns anos bissextos e s\u00e9culos.</p> <p>\u00c9 claro que, em programas reais, todas as decis\u00f5es n\u00e3o s\u00e3o independentes de todas as outras decis\u00f5es, o que significa que o n\u00famero de caminhos de execu\u00e7\u00e3o poss\u00edveis seria um pouco menor. Por outro lado, os programas reais s\u00e3o muito maiores do que o programa simples representado na Figura 2.1. Portanto, testes exaustivos de caminho, como testes exaustivos de entrada, parecem ser impratic\u00e1veis, se n\u00e3o imposs\u00edveis.</p> <p>A segunda falha na afirma\u00e7\u00e3o \"teste de caminho exaustivo significa um teste completo\" \u00e9 que todos os caminhos em um programa podem ser testados, mas o programa ainda pode estar carregado de erros. Existem tr\u00eas explica\u00e7\u00f5es para isso.</p> <p>A primeira \u00e9 que um teste exaustivo de trajet\u00f3ria n\u00e3o garante, de forma alguma, que um programa corresponda \u00e0 sua especifica\u00e7\u00e3o. Por exemplo, se voc\u00ea fosse solicitado a escrever uma rotina de classifica\u00e7\u00e3o em ordem crescente, mas produzisse por engano uma rotina de classifica\u00e7\u00e3o em ordem decrescente, o teste de caminho exaustivo seria de pouco valor; o programa ainda tem um bug: \u00e9 o programa errado, pois n\u00e3o atende \u00e0 especifica\u00e7\u00e3o.</p> <p>Em segundo lugar, um programa pode estar incorreto devido a caminhos ausentes. O teste exaustivo de caminho, \u00e9 claro, n\u00e3o detectaria a aus\u00eancia de caminhos necess\u00e1rios.</p> <p>Terceiro, um teste de caminho exaustivo pode n\u00e3o revelar erros de confidencialidade de dados. Existem muitos exemplos de tais erros, mas um simples deve ser suficiente. Suponha que, em um programa, voc\u00ea tenha que comparar dois n\u00fameros para converg\u00eancia, isto \u00e9, para ver se a diferen\u00e7a entre os dois n\u00fameros \u00e9 menor do que algum valor predeterminado. Por exemplo, voc\u00ea pode escrever uma instru\u00e7\u00e3o Java IF como:</p> <pre><code>if (a - b &lt; c)\n    System.out.println(\"a - b &lt; c\");\n</code></pre> <p>Claro, a declara\u00e7\u00e3o cont\u00e9m um erro porque deveria comparar <code>c</code> com o valor absoluto de <code>a - b</code>. A detec\u00e7\u00e3o desse erro, no entanto, depende dos valores usados para <code>a</code> e <code>b</code>, e n\u00e3o seria necessariamente detectada apenas executando todos os caminhos do programa.</p> <p>Em conclus\u00e3o, embora o teste exaustivo de entrada seja superior ao teste de caminho exaustivo, nenhum deles se mostra \u00fatil porque ambos s\u00e3o invi\u00e1veis. Talvez, ent\u00e3o, existam maneiras de combinar elementos de teste de caixa preta e caixa branca para derivar uma estrat\u00e9gia de teste razo\u00e1vel, mas n\u00e3o herm\u00e9tica. Este assunto \u00e9 aprofundado no Cap\u00edtulo 4.</p>"},{"location":"aae3/white_box_test/#principios-de-teste-de-software","title":"Princ\u00edpios de teste de software","text":""},{"location":"aae3/white_box_test/#tabela-21-diretrizes-de-teste-de-programas","title":"Tabela 2.1 \u2013 Diretrizes de teste de programas","text":"N\u00ba Princ\u00edpio 1 Uma parte necess\u00e1ria de um caso de teste \u00e9 uma defini\u00e7\u00e3o da sa\u00edda ou resultado esperado. 2 Um programador deve evitar tentar testar seu pr\u00f3prio programa. 3 Uma organiza\u00e7\u00e3o de programa\u00e7\u00e3o n\u00e3o deve testar seus pr\u00f3prios programas. 4 Qualquer processo de teste deve incluir uma inspe\u00e7\u00e3o completa dos resultados de cada teste. 5 Os casos de teste devem ser gravados para condi\u00e7\u00f5es de entrada inv\u00e1lidas e inesperadas, bem como para aquelas que s\u00e3o v\u00e1lidas e esperadas. 6 Examinar um programa para ver se ele n\u00e3o faz o que deveria fazer \u00e9 apenas metade da batalha; a outra metade \u00e9 ver se o programa faz o que n\u00e3o deveria fazer. 7 Evite casos de teste descart\u00e1veis, a menos que o programa seja realmente um programa descart\u00e1vel. 8 N\u00e3o planeje um esfor\u00e7o de teste sob a suposi\u00e7\u00e3o t\u00e1cita de que nenhum erro ser\u00e1 encontrado. 9 A probabilidade da exist\u00eancia de mais erros em uma se\u00e7\u00e3o de um programa \u00e9 proporcional ao n\u00famero de erros j\u00e1 encontrados nessa se\u00e7\u00e3o. 10 O teste \u00e9 uma tarefa extremamente criativa e intelectualmente desafiadora. <p>Continuando com a premissa principal deste cap\u00edtulo, de que as considera\u00e7\u00f5es mais importantes no teste de software s\u00e3o quest\u00f5es de psicologia, podemos identificar um conjunto de princ\u00edpios ou diretrizes vitais de teste. A maioria desses princ\u00edpios pode parecer \u00f3bvia, mas muitas vezes s\u00e3o negligenciados. A Tabela 2.1 resume esses princ\u00edpios importantes, e cada um \u00e9 discutido com mais detalhes nos par\u00e1grafos a seguir.</p>"},{"location":"aae3/white_box_test/#principio-1","title":"Princ\u00edpio 1","text":"<p>Uma parte necess\u00e1ria de um caso de teste \u00e9 uma defini\u00e7\u00e3o da sa\u00edda ou resultado esperado. Este princ\u00edpio, embora \u00f3bvio, quando negligenciado, \u00e9 a causa de um dos erros mais frequentes no teste de programas. Novamente, \u00e9 algo baseado na psicologia humana. Se o resultado esperado de um caso de teste n\u00e3o foi predefinido, \u00e9 prov\u00e1vel que um resultado plaus\u00edvel, mas err\u00f4neo, seja interpretado como um resultado correto por causa do fen\u00f4meno de \"o olho ver o que quer ver\". Em outras palavras, apesar da defini\u00e7\u00e3o destrutiva adequada de teste, ainda h\u00e1 um desejo subconsciente de ver o resultado correto.</p> <p>Uma maneira de lutar contra essa situa\u00e7\u00e3o consiste em incentivar uma an\u00e1lise pormenorizada de toda a produ\u00e7\u00e3o, especificando com precis\u00e3o, antecipadamente, a produ\u00e7\u00e3o esperada do programa. Portanto, um caso de teste deve consistir em dois componentes:</p> <ol> <li>Uma descri\u00e7\u00e3o dos dados de entrada para o programa.</li> <li>Uma descri\u00e7\u00e3o precisa da sa\u00edda correta do programa para esse conjunto de dados de entrada.</li> </ol> <p>Um problema pode ser caracterizado como um fato ou grupo de fatos para os quais n\u00e3o temos uma explica\u00e7\u00e3o aceit\u00e1vel, que parecem incomuns ou que n\u00e3o se encaixam em nossas expectativas ou preconceitos. Deve ser \u00f3bvio que algumas cren\u00e7as pr\u00e9vias s\u00e3o necess\u00e1rias para que algo pare\u00e7a problem\u00e1tico. Se n\u00e3o houver expectativas, n\u00e3o pode haver surpresas.</p>"},{"location":"aae3/white_box_test/#principio-2","title":"Princ\u00edpio 2","text":"<p>Um programador deve evitar tentar testar seu pr\u00f3prio programa. Qualquer escritor sabe \u2014 ou deveria saber \u2014 que \u00e9 uma m\u00e1 ideia tentar editar ou revisar seu pr\u00f3prio trabalho. Eles sabem o que a pe\u00e7a deve dizer, portanto, podem n\u00e3o reconhecer quando diz o contr\u00e1rio. E eles realmente n\u00e3o querem encontrar erros em seu pr\u00f3prio trabalho. O mesmo se aplica aos autores de software.</p> <p>Outro problema surge com uma mudan\u00e7a de foco em um projeto de software. Depois que um programador projetou e codificou construtivamente um programa, \u00e9 extremamente dif\u00edcil mudar repentinamente a perspectiva para olhar para o programa com um olhar destrutivo.</p> <p>Como muitos propriet\u00e1rios sabem, remover o papel de parede (um processo destrutivo) n\u00e3o \u00e9 f\u00e1cil, mas \u00e9 quase insuportavelmente deprimente se foram suas m\u00e3os que penduraram o papel em primeiro lugar. Da mesma forma, a maioria dos programadores n\u00e3o pode testar efetivamente seus pr\u00f3prios programas porque n\u00e3o consegue mudar as engrenagens mentais para tentar expor erros. Al\u00e9m disso, um programador pode inconscientemente evitar encontrar erros por medo de retalia\u00e7\u00e3o de colegas, de um supervisor, de um cliente ou do propriet\u00e1rio do programa ou sistema que est\u00e1 sendo desenvolvido.</p> <p>Al\u00e9m dessas quest\u00f5es psicol\u00f3gicas, h\u00e1 um segundo problema significativo: o programa pode conter erros devido ao mal-entendido do programador sobre a declara\u00e7\u00e3o ou especifica\u00e7\u00e3o do problema. Se for esse o caso, \u00e9 prov\u00e1vel que o programador leve o mesmo mal-entendido para os testes de seu pr\u00f3prio programa.</p> <p>Isso n\u00e3o significa que seja imposs\u00edvel para um programador testar seu pr\u00f3prio programa. Em vez disso, implica que o teste \u00e9 mais eficaz e bem-sucedido se outra pessoa o fizer. No entanto, como vamos discutir em mais detalhes no Cap\u00edtulo 3, os desenvolvedores podem ser membros valiosos da equipe de teste quando a especifica\u00e7\u00e3o do programa e o pr\u00f3prio c\u00f3digo do programa est\u00e3o sendo avaliados.</p> <p>Observe que esse argumento n\u00e3o se aplica \u00e0 depura\u00e7\u00e3o (corrigir erros conhecidos); a depura\u00e7\u00e3o \u00e9 executada com mais efici\u00eancia pelo programador original.</p>"},{"location":"aae3/white_box_test/#principio-3","title":"Princ\u00edpio 3","text":"<p>Uma organiza\u00e7\u00e3o de programa\u00e7\u00e3o n\u00e3o deve testar seus pr\u00f3prios programas. O argumento aqui \u00e9 semelhante ao feito no princ\u00edpio anterior. Uma organiza\u00e7\u00e3o de projeto ou programa\u00e7\u00e3o \u00e9, em muitos sentidos, uma organiza\u00e7\u00e3o viva com problemas psicol\u00f3gicos semelhantes aos de programadores individuais. Al\u00e9m disso, na maioria dos ambientes, uma organiza\u00e7\u00e3o de programas ou um gerente de projeto \u00e9 amplamente medido pela capacidade de produzir um programa em uma determinada data e por um determinado custo.</p> <p>Uma raz\u00e3o para isso \u00e9 que \u00e9 f\u00e1cil medir os objetivos de tempo e custo, enquanto \u00e9 extremamente dif\u00edcil quantificar a confiabilidade de um programa. Portanto, \u00e9 dif\u00edcil para uma organiza\u00e7\u00e3o de programa\u00e7\u00e3o ser objetiva ao testar seus pr\u00f3prios programas, porque o processo de teste, se abordado com a defini\u00e7\u00e3o adequada, pode ser visto como diminuindo a probabilidade de atingir o cronograma e os objetivos de custo.</p> <p>Novamente, isso n\u00e3o significa que seja imposs\u00edvel para uma organiza\u00e7\u00e3o de programa\u00e7\u00e3o encontrar alguns de seus erros, porque as organiza\u00e7\u00f5es realizam isso com algum grau de sucesso. Em vez disso, implica que \u00e9 mais econ\u00f4mico que os testes sejam realizados por uma parte objetiva e independente.</p>"},{"location":"aae3/white_box_test/#principio-4","title":"Princ\u00edpio 4","text":"<p>Qualquer processo de teste deve incluir uma inspe\u00e7\u00e3o completa dos resultados de cada teste. Este \u00e9 provavelmente o princ\u00edpio mais \u00f3bvio, mas, novamente, \u00e9 algo que muitas vezes \u00e9 esquecido. Vimos v\u00e1rios experimentos que mostram que muitos sujeitos falharam em detectar certos erros, mesmo quando os sintomas desses erros eram claramente observ\u00e1veis nas listas de sa\u00edda. Dito de outra forma, os erros encontrados em testes posteriores foram frequentemente perdidos nos resultados de testes anteriores.</p>"},{"location":"aae3/white_box_test/#principio-5","title":"Princ\u00edpio 5","text":"<p>Os casos de teste devem ser escritos para condi\u00e7\u00f5es de entrada inv\u00e1lidas e inesperadas, bem como para aquelas que s\u00e3o v\u00e1lidas e esperadas. H\u00e1 uma tend\u00eancia natural, ao testar um programa, de se concentrar nas condi\u00e7\u00f5es de entrada v\u00e1lidas e esperadas, negligenciando as condi\u00e7\u00f5es inv\u00e1lidas e inesperadas.</p> <p>Por exemplo, essa tend\u00eancia aparece frequentemente no teste do programa do tri\u00e2ngulo no Cap\u00edtulo 1. Poucas pessoas, por exemplo, alimentam o programa com os n\u00fameros 1, 2, 5 para garantir que o programa n\u00e3o interprete erroneamente isso como um tri\u00e2ngulo equil\u00e1tero em vez de um tri\u00e2ngulo escaleno.</p> <p>Al\u00e9m disso, muitos erros que s\u00e3o descobertos repentinamente no software de produ\u00e7\u00e3o aparecem quando ele \u00e9 usado de alguma maneira nova ou inesperada. \u00c9 dif\u00edcil, se n\u00e3o imposs\u00edvel, definir todos os casos de uso para teste de software. Portanto, os casos de teste que representam condi\u00e7\u00f5es de entrada inesperadas e inv\u00e1lidas parecem ter um rendimento de detec\u00e7\u00e3o de erro maior do que os casos de teste para condi\u00e7\u00f5es de entrada v\u00e1lidas.</p>"},{"location":"aae3/white_box_test/#principio-6","title":"Princ\u00edpio 6","text":"<p>Examinar um programa para ver se ele n\u00e3o faz o que deveria fazer \u00e9 apenas metade da batalha; a outra metade \u00e9 ver se o programa faz o que n\u00e3o deveria fazer. Este \u00e9 um corol\u00e1rio do princ\u00edpio anterior. Os programas devem ser examinados quanto a efeitos colaterais indesejados.</p> <p>Por exemplo, um programa de c\u00e1lculo das folhas de pagamento que produz os contracheques corretos ainda \u00e9 um programa err\u00f4neo se tamb\u00e9m produzir cheques extras para empregados inexistentes ou se sobregravar o primeiro registro do arquivo pessoal.</p>"},{"location":"aae3/white_box_test/#principio-7","title":"Princ\u00edpio 7","text":"<p>Evite casos de teste descart\u00e1veis, a menos que o programa seja realmente um programa descart\u00e1vel. Este problema \u00e9 visto com mais frequ\u00eancia com sistemas interativos para testar programas. Uma pr\u00e1tica comum \u00e9 sentar-se em um terminal e inventar casos de teste em tempo real e, em seguida, enviar esses casos de teste pelo programa.</p> <p>A principal quest\u00e3o \u00e9 que os casos de teste representam um investimento valioso que, neste ambiente, desaparece ap\u00f3s a conclus\u00e3o do teste. Sempre que o programa tiver que ser testado novamente (por exemplo, ap\u00f3s corrigir um erro ou fazer uma melhoria), os casos de teste devem ser reinventados.</p> <p>Na maioria das vezes, uma vez que essa reinven\u00e7\u00e3o requer uma quantidade consider\u00e1vel de trabalho, as pessoas tendem a evit\u00e1-la. Portanto, o teste do programa raramente \u00e9 t\u00e3o rigoroso quanto o teste original, o que significa que, se a modifica\u00e7\u00e3o fizer com que uma parte anteriormente funcional do programa falhe, esse erro geralmente n\u00e3o \u00e9 detectado.</p> <p>Salvar casos de teste e execut\u00e1-los novamente ap\u00f3s altera\u00e7\u00f5es em outros componentes do programa \u00e9 conhecido como teste de regress\u00e3o.</p>"},{"location":"aae3/white_box_test/#principio-8","title":"Princ\u00edpio 8","text":"<p>N\u00e3o planeje um esfor\u00e7o de teste sob a suposi\u00e7\u00e3o t\u00e1cita de que nenhum erro ser\u00e1 encontrado. Este \u00e9 um erro que os gerentes de projeto costumam cometer e \u00e9 um sinal do uso da defini\u00e7\u00e3o incorreta de teste \u2014 ou seja, a suposi\u00e7\u00e3o de que o teste \u00e9 o processo de mostrar que o programa funciona corretamente.</p> <p>Mais uma vez, a defini\u00e7\u00e3o de teste \u00e9 o processo de execu\u00e7\u00e3o de um programa com a inten\u00e7\u00e3o de encontrar erros. E deve ser \u00f3bvio a partir de nossas discuss\u00f5es anteriores que \u00e9 imposs\u00edvel desenvolver um programa que seja completamente livre de erros.</p> <p>Mesmo ap\u00f3s extensos testes e corre\u00e7\u00e3o de erros, \u00e9 seguro assumir que os erros ainda existem; eles simplesmente ainda n\u00e3o foram encontrados.</p>"},{"location":"aae3/white_box_test/#principio-9","title":"Princ\u00edpio 9","text":"<p>A probabilidade da exist\u00eancia de mais erros em uma se\u00e7\u00e3o de um programa \u00e9 proporcional ao n\u00famero de erros j\u00e1 encontrados nessa se\u00e7\u00e3o. Este fen\u00f4meno \u00e9 ilustrado na Figura 2.2. \u00c0 primeira vista, esse conceito pode parecer sem sentido, mas \u00e9 um fen\u00f4meno presente em muitos programas.</p> <p>Por exemplo, se um programa consiste em dois m\u00f3dulos, classes ou sub-rotinas, A e B, e cinco erros foram encontrados no m\u00f3dulo A, e apenas um erro foi encontrado no m\u00f3dulo B, e se o m\u00f3dulo A n\u00e3o foi propositalmente submetido a um teste mais rigoroso, ent\u00e3o este princ\u00edpio nos diz que a probabilidade de mais erros no m\u00f3dulo A \u00e9 maior do que a probabilidade de mais erros no m\u00f3dulo B.</p> <p>Outra maneira de afirmar esse princ\u00edpio \u00e9 dizer que os erros tendem a ocorrer em grupos e que, no programa t\u00edpico, algumas se\u00e7\u00f5es parecem ser muito mais propensas a erros do que outras se\u00e7\u00f5es, embora ningu\u00e9m tenha fornecido uma boa explica\u00e7\u00e3o de por que isso ocorre.</p> <p>FIGURA 2.2: A surpreendente rela\u00e7\u00e3o entre erros remanescentes e erros encontrados.</p> <p>O fen\u00f4meno \u00e9 \u00fatil porque nos d\u00e1 uma vis\u00e3o ou feedback no processo de teste. Se uma se\u00e7\u00e3o espec\u00edfica de um programa parece ser muito mais propensa a erros do que outras se\u00e7\u00f5es, esse fen\u00f4meno nos diz que, em termos de rendimento em nosso investimento em testes, os esfor\u00e7os adicionais de teste s\u00e3o mais bem focados nesta se\u00e7\u00e3o propensa a erros.</p>"},{"location":"aae3/white_box_test/#principio-10","title":"Princ\u00edpio 10","text":"<p>O teste \u00e9 uma tarefa extremamente criativa e intelectualmente desafiadora. Provavelmente \u00e9 verdade que a criatividade necess\u00e1ria para testar um programa grande excede a criatividade necess\u00e1ria para projetar esse programa.</p> <p>J\u00e1 vimos que \u00e9 imposs\u00edvel testar um programa o suficiente para garantir a aus\u00eancia de todos os erros. As metodologias discutidas posteriormente neste livro ajudam voc\u00ea a desenvolver um conjunto razo\u00e1vel de casos de teste para um programa, mas essas metodologias ainda exigem uma quantidade significativa de criatividade.</p>"},{"location":"aae3/white_box_test/#resumo","title":"Resumo","text":"<p>\u00c0 medida que voc\u00ea avan\u00e7a neste livro, tenha em mente estes importantes princ\u00edpios de teste:</p> <ul> <li>Teste \u00e9 o processo de execu\u00e7\u00e3o de um programa com a inten\u00e7\u00e3o de encontrar erros.</li> <li>O teste \u00e9 mais bem-sucedido quando n\u00e3o \u00e9 realizado pelo(s) desenvolvedor(es).</li> <li>Um bom caso de teste \u00e9 aquele que tem uma alta probabilidade de detectar um erro n\u00e3o descoberto.</li> <li>Um caso de teste bem-sucedido \u00e9 aquele que detecta um erro n\u00e3o descoberto.</li> <li>O teste bem-sucedido inclui tamb\u00e9m a defini\u00e7\u00e3o cuidadosa da sa\u00edda esperada como entrada.</li> <li>O teste bem-sucedido inclui o estudo cuidadoso dos resultados do teste.</li> </ul>"},{"location":"aae3/white_box_test/#bibliografia","title":"Bibliografia","text":"<p>MYERS, G. J.; SANDLER, C.; BADGETT, T. The Art of Software Testing. 3rd ed. Cap\u00edtulo 4, Se\u00e7\u00e3o White-Box Testing.</p>"},{"location":"tpi_tpe/tpi3_tpe3/","title":"TPI/TPE(3) - Quest\u00f5es de Testes de Software","text":""},{"location":"tpi_tpe/tpi3_tpe3/#q01-qual-e-a-representacao-de-programa-mais-comumente-utilizada-nos-criterios-de-teste-estrutural","title":"Q01. Qual \u00e9 a representa\u00e7\u00e3o de programa mais comumente utilizada nos crit\u00e9rios de teste estrutural?","text":"<ul> <li>a. Grafo de Causa-Efeito.  </li> <li>b. Grafo de Fluxo de Dados.  </li> <li>c. Grafo de Caminhos Independentes.  </li> <li>d. Grafo de Fluxo de Controle.  </li> </ul> <p>RESPOSTA: d. Grafo de Fluxo de Controle.</p> <p>O diagrama \u00e9 um grafo de fluxo de controle. Cada n\u00f3 ou c\u00edrculo representa um segmento de instru\u00e7\u00f5es que executam sequencialmente, podendo terminar com uma instru\u00e7\u00e3o de desvio. Cada aresta ou arco representa uma transfer\u00eancia de controle (desvio) entre segmentos.</p> <p>Refer\u00eancia: The Art of Software Testing \u2013 3rd Edition, p\u00e1gina 11.</p>"},{"location":"tpi_tpe/tpi3_tpe3/#q02-qual-das-seguintes-afirmacoes-e-mais-verdadeira-sobre-o-teste-de-unidade","title":"Q02. Qual das seguintes afirma\u00e7\u00f5es \u00e9 MAIS VERDADEIRA sobre o teste de unidade?","text":"<ul> <li>a. \u00c9 uma abordagem de teste de caixa preta onde a estrutura interna do m\u00f3dulo n\u00e3o \u00e9 considerada.  </li> <li>b. \u00c9 uma abordagem de teste de caixa branca que foca nos componentes individuais de um programa.  </li> <li>c. S\u00f3 \u00e9 usado para grandes programas com mais de 500 instru\u00e7\u00f5es.  </li> <li>d. \u00c9 o mesmo que teste de integra\u00e7\u00e3o, que combina v\u00e1rios componentes.</li> </ul> <p>RESPOSTA: b. \u00c9 uma abordagem de teste de caixa branca que foca nos componentes individuais de um programa.</p> <p>O teste de unidade \u00e9 amplamente orientado \u00e0 caixa-branca. (p. 86)  </p> <p>Refer\u00eancia: The Art of Software Testing \u2013 3rd Edition, p\u00e1gina 86.</p>"},{"location":"tpi_tpe/tpi3_tpe3/#q03-quais-sao-os-dois-principais-motivos-para-realizar-o-teste-de-unidade","title":"Q03. Quais s\u00e3o os dois principais motivos para realizar o teste de unidade?","text":"<ul> <li>a. Documentar a funcionalidade do programa e identificar erros no in\u00edcio do processo de desenvolvimento.  </li> <li>b. Reduzir a complexidade de testar programas grandes e facilitar a depura\u00e7\u00e3o.  </li> <li>c. Atender aos requisitos do usu\u00e1rio e garantir que o programa esteja livre de erros.  </li> <li>d. Melhorar a cobertura do c\u00f3digo e testar o desempenho do programa.  </li> </ul> <p>RESPOSTA: b. Reduzir a complexidade de testar programas grandes e facilitar a depura\u00e7\u00e3o.</p> <p>As motiva\u00e7\u00f5es para fazer isso s\u00e3o tr\u00eas. Primeiro, o teste de m\u00f3dulo \u00e9 uma forma de gerenciar os elementos combinados do teste, j\u00e1 que a aten\u00e7\u00e3o \u00e9 focada inicialmente em unidades menores do programa. Segundo, o teste de m\u00f3dulo facilita a tarefa de depura\u00e7\u00e3o, j\u00e1 que a aten\u00e7\u00e3o est\u00e1 concentrada em uma pequena unidade de c\u00f3digo e, frequentemente, a interface com o restante do programa \u00e9 simulada por um m\u00f3dulo stub. (p. 85)</p> <p>Refer\u00eancia: The Art of Software Testing \u2013 3rd Edition, p\u00e1gina 85.</p>"},{"location":"tpi_tpe/tpi3_tpe3/#q04-por-que-a-cobertura-de-condicao-pode-nao-satisfazer-a-cobertura-de-decisao","title":"Q04. Por que a cobertura de condi\u00e7\u00e3o pode n\u00e3o satisfazer a cobertura de decis\u00e3o?","text":"<ul> <li>a. Porque a cobertura de condi\u00e7\u00e3o n\u00e3o testa todas as instru\u00e7\u00f5es.  </li> <li>b. Porque algumas condi\u00e7\u00f5es podem mascarar outras.  </li> <li>c. Porque a cobertura de condi\u00e7\u00e3o n\u00e3o inclui os pontos de entrada do programa.  </li> <li>d. Porque a cobertura de condi\u00e7\u00e3o n\u00e3o testa todas as combina\u00e7\u00f5es de condi\u00e7\u00f5es.  </li> </ul> <p>RESPOSTA: b. Porque algumas condi\u00e7\u00f5es podem mascarar outras.</p> <p>Um ponto fraco da cobertura de condi\u00e7\u00e3o/decis\u00e3o \u00e9 que, embora pare\u00e7a exercitar todos os resultados de todas as condi\u00e7\u00f5es, frequentemente n\u00e3o o faz, porque certas condi\u00e7\u00f5es mascaram outras condi\u00e7\u00f5es.  </p> <p>Por exemplo, se uma condi\u00e7\u00e3o \u2018and\u2019 for falsa, nenhuma das condi\u00e7\u00f5es subsequentes na express\u00e3o precisa ser avaliada. Da mesma forma, se uma condi\u00e7\u00e3o \u2018or\u2019 for verdadeira, as condi\u00e7\u00f5es subsequentes tamb\u00e9m n\u00e3o precisam ser avaliadas.  </p> <p>Refer\u00eancia: The Art of Software Testing \u2013 3rd Edition, p\u00e1ginas 46\u201347.</p>"},{"location":"tpi_tpe/tpi3_tpe3/#q05-qual-e-a-principal-limitacao-da-cobertura-de-decisao","title":"Q05. Qual \u00e9 a principal limita\u00e7\u00e3o da cobertura de decis\u00e3o?","text":"<ul> <li>a. N\u00e3o garante que todas as instru\u00e7\u00f5es sejam executadas.  </li> <li>b. N\u00e3o considera as m\u00faltiplas condi\u00e7\u00f5es dentro de uma decis\u00e3o.  </li> <li>c. N\u00e3o testa todas as poss\u00edveis combina\u00e7\u00f5es de condi\u00e7\u00f5es.  </li> <li>d. N\u00e3o identifica erros em decis\u00f5es aninhadas.  </li> </ul> <p>RESPOSTA: b. N\u00e3o considera as m\u00faltiplas condi\u00e7\u00f5es dentro de uma decis\u00e3o.</p> <p>A cobertura de decis\u00e3o \u00e9 um crit\u00e9rio mais forte do que a cobertura de instru\u00e7\u00f5es, mas ainda \u00e9 bastante fraco. Um crit\u00e9rio que \u00e0s vezes \u00e9 mais forte do que a cobertura de decis\u00e3o \u00e9 a cobertura de condi\u00e7\u00e3o. [...] Mas, assim como a cobertura de decis\u00e3o, isso nem sempre leva \u00e0 execu\u00e7\u00e3o de cada instru\u00e7\u00e3o. Embora o crit\u00e9rio de cobertura de condi\u00e7\u00e3o pare\u00e7a, \u00e0 primeira vista, satisfazer o crit\u00e9rio de cobertura de decis\u00e3o, isso nem sempre acontece. [...] Os testes de cobertura de condi\u00e7\u00e3o do exemplo anterior cobriram todos os resultados das condi\u00e7\u00f5es, mas apenas dois dos quatro resultados das decis\u00f5es...</p> <p>Refer\u00eancia: The Art of Software Testing \u2013 3rd Edition, p\u00e1ginas 45\u201346.</p>"},{"location":"tpi_tpe/tpi3_tpe3/#q06-qual-dos-criterios-de-cobertura-de-logica-e-considerado-o-mais-fraco","title":"Q06. Qual dos crit\u00e9rios de cobertura de l\u00f3gica \u00e9 considerado o mais fraco?","text":"<ul> <li>a. Cobertura de condi\u00e7\u00e3o.  </li> <li>b. Cobertura de decis\u00e3o.  </li> <li>c. Cobertura de m\u00faltiplas condi\u00e7\u00f5es.  </li> <li>d. Cobertura de instru\u00e7\u00e3o.  </li> </ul> <p>RESPOSTA: d. Cobertura de instru\u00e7\u00e3o.</p> <p>Embora voc\u00ea possa executar todas as instru\u00e7\u00f5es com um \u00fanico teste, esse crit\u00e9rio \u00e9 bastante fraco. Em outras palavras, o crit\u00e9rio de cobertura de instru\u00e7\u00e3o \u00e9 t\u00e3o fraco que geralmente \u00e9 in\u00fatil.  </p> <p>Refer\u00eancia: The Art of Software Testing \u2013 3rd Edition, p\u00e1gina 44</p>"},{"location":"tpi_tpe/tpi3_tpe3/#q07-o-que-o-metodo-mcdc-visa-alcancar","title":"Q07. O que o m\u00e9todo MC/DC visa alcan\u00e7ar?","text":"<ul> <li>a. Testar todas as instru\u00e7\u00f5es do programa pelo menos uma vez.  </li> <li>b. Testar todas as combina\u00e7\u00f5es de decis\u00f5es em um programa.  </li> <li>c. Garantir que cada condi\u00e7\u00e3o em uma decis\u00e3o tenha um resultado verdadeiro e falso pelo menos uma vez.  </li> <li>d. Garantir que cada condi\u00e7\u00e3o independente em uma decis\u00e3o tenha um efeito independente na sa\u00edda da decis\u00e3o.  </li> </ul> <p>RESPOSTA: d. Garantir que cada condi\u00e7\u00e3o independente em uma decis\u00e3o tenha um efeito independente na sa\u00edda da decis\u00e3o.</p> <p>A cobertura de condi\u00e7\u00e3o/decis\u00e3o modificada (MC/DC) exige que cada ponto de entrada e sa\u00edda do programa tenha sido invocado pelo menos uma vez, que cada condi\u00e7\u00e3o em uma decis\u00e3o assuma todos os resultados poss\u00edveis pelo menos uma vez e que cada condi\u00e7\u00e3o em uma decis\u00e3o tenha mostrado afetar de forma independente o resultado da decis\u00e3o.</p> <p>Refer\u00eancia: The Art of Software Testing \u2013 3rd Edition, p\u00e1gina 47.</p>"},{"location":"tpi_tpe/tpi3_tpe3/#q08-qual-e-uma-das-principais-vantagens-do-metodo-mcdc-em-relacao-a-outros-criterios-de-cobertura","title":"Q08. Qual \u00e9 uma das principais vantagens do m\u00e9todo MC/DC em rela\u00e7\u00e3o a outros crit\u00e9rios de cobertura?","text":"<ul> <li>a. Requer menos casos de teste para ser implementado.  </li> <li>b. \u00c9 mais f\u00e1cil de entender e aplicar em programas grandes.  </li> <li>c. Garante uma cobertura mais robusta ao testar condi\u00e7\u00f5es de decis\u00e3o.  </li> <li>d. N\u00e3o requer testes de m\u00faltiplas condi\u00e7\u00f5es dentro de uma decis\u00e3o.  </li> </ul> <p>RESPOSTA: c. Garante uma cobertura mais robusta ao testar condi\u00e7\u00f5es de decis\u00e3o.</p> <p>Um crit\u00e9rio que cobre esse problema, e vai al\u00e9m, \u00e9 a cobertura de m\u00faltiplas condi\u00e7\u00f5es. Esse crit\u00e9rio exige que voc\u00ea escreva casos de teste suficientes para que todas as combina\u00e7\u00f5es poss\u00edveis de resultados de condi\u00e7\u00f5es em cada decis\u00e3o, e todos os pontos de entrada, sejam invocados pelo menos uma vez. Embora o MC/DC n\u00e3o exija todas as combina\u00e7\u00f5es, ele melhora a cobertura de decis\u00e3o/condi\u00e7\u00e3o ao garantir que cada condi\u00e7\u00e3o afete independentemente o resultado da decis\u00e3o.</p> <p>Refer\u00eancia: The Art of Software Testing \u2013 3rd Edition, p\u00e1gina 47.</p>"},{"location":"tpi_tpe/tpi3_tpe3/#q09-qual-das-seguintes-afirmacoes-melhor-descreve-o-primeiro-passo-ao-usar-tecnicas-de-cobertura-logica-no-teste-de-software","title":"Q09. Qual das seguintes afirma\u00e7\u00f5es melhor descreve o primeiro passo ao usar t\u00e9cnicas de cobertura l\u00f3gica no teste de software?","text":"<ul> <li>a. Identificar todas as vari\u00e1veis no programa e garantir que cada uma seja testada em diferentes condi\u00e7\u00f5es.  </li> <li>b. Listar as decis\u00f5es condicionais no programa, focando em declara\u00e7\u00f5es IF, DO e similares.  </li> <li>c. Criar casos de teste para todas as funcionalidades do software sem considerar a estrutura interna do c\u00f3digo.  </li> <li>d. Garantir que todas as declara\u00e7\u00f5es IF no programa sejam testadas de forma isolada para verificar seu comportamento.  </li> </ul> <p>RESPOSTA: b. Listar as decis\u00f5es condicionais no programa, focando em declara\u00e7\u00f5es IF, DO e similares.</p> <p>Independentemente da t\u00e9cnica de cobertura l\u00f3gica utilizada, o primeiro passo \u00e9 listar as decis\u00f5es condicionais no programa. Os candidatos neste programa s\u00e3o todas as instru\u00e7\u00f5es IF e DO.</p> <p>Refer\u00eancia: The Art of Software Testing \u2013 3rd Edition, p\u00e1gina 89.</p>"},{"location":"tpi_tpe/tpi3_tpe3/#q10-qual-das-seguintes-afirmacoes-melhor-descreve-uma-caracteristica-do-criterio-de-cobertura-de-multiplas-condicoes","title":"Q10. Qual das seguintes afirma\u00e7\u00f5es melhor descreve uma caracter\u00edstica do crit\u00e9rio de cobertura de m\u00faltiplas condi\u00e7\u00f5es?","text":"<ul> <li>a. O crit\u00e9rio de cobertura de m\u00faltiplas condi\u00e7\u00f5es \u00e9 suficiente para detectar todos os erros poss\u00edveis em uma unidade.  </li> <li>b. Mesmo testes que satisfazem o crit\u00e9rio de cobertura de m\u00faltiplas condi\u00e7\u00f5es podem n\u00e3o detectar certos erros, como valores iniciais incorretos.  </li> <li>c. O crit\u00e9rio de cobertura de m\u00faltiplas condi\u00e7\u00f5es se concentra apenas em testes de caixa-preta.  </li> <li>d. O crit\u00e9rio de cobertura de m\u00faltiplas condi\u00e7\u00f5es garante que todos os caminhos de execu\u00e7\u00e3o do c\u00f3digo sejam testados.  </li> </ul> <p>RESPOSTA: b. Mesmo testes que satisfazem o crit\u00e9rio de cobertura de m\u00faltiplas condi\u00e7\u00f5es podem n\u00e3o detectar certos erros, como valores iniciais incorretos.</p> <p>Embora esses dois casos de teste atendam ao crit\u00e9rio de cobertura de decis\u00e3o, deve ser \u00f3bvio que pode haver muitos tipos de erros no m\u00f3dulo que n\u00e3o s\u00e3o detectados por esses dois casos. Por exemplo, os casos de teste n\u00e3o exploram circunst\u00e2ncias como quando o c\u00f3digo de erro \u00e9 0, um funcion\u00e1rio \u00e9 gerente ou a tabela de departamentos est\u00e1 vazia (DSIZE \u2264 0).</p> <p>Refer\u00eancia: The Art of Software Testing \u2013 3rd Edition, p\u00e1gina 90.</p>"},{"location":"tpi_tpe/tpi3_tpe3/#q11-qual-e-uma-vantagem-importante-do-teste-incremental-sobre-o-teste-nao-incremental","title":"Q11. Qual \u00e9 uma vantagem importante do teste incremental sobre o teste n\u00e3o incremental?","text":"<ul> <li>a. Requer menos m\u00f3dulos de driver e stub.  </li> <li>b. Necessita de menos tempo de m\u00e1quina.  </li> <li>c. Permite que todos os m\u00f3dulos sejam testados simultaneamente.  </li> <li>d. Reduz a possibilidade de detectar erros nas interfaces dos m\u00f3dulos.  </li> </ul> <p>RESPOSTA: a. Requer menos m\u00f3dulos de driver e stub.</p> <p>O teste n\u00e3o incremental exige mais trabalho. Para o programa da Figura 5.7, cinco drivers e cinco stubs devem ser preparados [...]. O teste incremental bottom-up exigiria cinco drivers, mas nenhum stub. Um teste incremental top-down exigiria cinco stubs, mas nenhum driver. Menos trabalho \u00e9 necess\u00e1rio porque os m\u00f3dulos previamente testados s\u00e3o usados em vez dos m\u00f3dulos driver (se come\u00e7ar do topo) ou dos m\u00f3dulos stub (se come\u00e7ar pela base) exigidos na abordagem n\u00e3o incremental.</p> <p>Refer\u00eancia: The Art of Software Testing \u2013 3rd Edition, p\u00e1gina 99.</p>"},{"location":"tpi_tpe/tpi3_tpe3/#q12-qual-das-seguintes-observacoes-e-uma-vantagem-do-teste-nao-incremental","title":"Q12. Qual das seguintes observa\u00e7\u00f5es \u00e9 uma vantagem do teste n\u00e3o incremental?","text":"<ul> <li>a. Detecta erros de interfaces de m\u00f3dulos mais cedo.  </li> <li>b. Reduz a necessidade de drivers e stubs.  </li> <li>c. Permite mais atividades paralelas no in\u00edcio da fase de testes de m\u00f3dulo.  </li> <li>d. Resulta em testes mais completos dos m\u00f3dulos.  </li> </ul> <p>RESPOSTA: c. Permite mais atividades paralelas no in\u00edcio da fase de testes de m\u00f3dulo.</p> <p>No in\u00edcio da fase de testes de m\u00f3dulo, h\u00e1 mais oportunidade para atividades paralelas quando se utiliza o teste n\u00e3o incremental (isto \u00e9, todos os m\u00f3dulos podem ser testados simultaneamente). Isso pode ser significativo em projetos grandes (com muitos m\u00f3dulos e pessoas), j\u00e1 que o n\u00famero de integrantes do projeto geralmente atinge seu pico no in\u00edcio dessa fase.</p> <p>Refer\u00eancia: The Art of Software Testing \u2013 3rd Edition, p\u00e1gina 100.</p>"},{"location":"tpi_tpe/tpi3_tpe3/#q13-qual-e-uma-das-principais-vantagens-do-teste-top-down","title":"Q13. Qual \u00e9 uma das principais vantagens do teste top-down?","text":"<ul> <li>a. N\u00e3o requer a cria\u00e7\u00e3o de stubs.  </li> <li>b. Facilita a representa\u00e7\u00e3o de casos de teste uma vez que as fun\u00e7\u00f5es de entrada e sa\u00edda s\u00e3o adicionadas.  </li> <li>c. Permite a identifica\u00e7\u00e3o de todos os erros poss\u00edveis no programa.  </li> <li>d. Garante que todos os m\u00f3dulos s\u00e3o testados simultaneamente.  </li> </ul> <p>RESPOSTA: b. Facilita a representa\u00e7\u00e3o de casos de teste uma vez que as fun\u00e7\u00f5es de entrada e sa\u00edda s\u00e3o adicionadas.</p> <p>Uma vez que as fun\u00e7\u00f5es de entrada/sa\u00edda s\u00e3o adicionadas, a representa\u00e7\u00e3o dos casos \u00e9 facilitada.</p> <p>Refer\u00eancia: The Art of Software Testing \u2013 3rd Edition, p\u00e1gina 109.</p>"},{"location":"tpi_tpe/tpi3_tpe3/#q14-qual-e-uma-desvantagem-do-teste-bottom-up","title":"Q14. Qual \u00e9 uma desvantagem do teste bottom-up?","text":"<ul> <li>a. A produ\u00e7\u00e3o de m\u00f3dulos driver \u00e9 mais dif\u00edcil que a produ\u00e7\u00e3o de stubs.  </li> <li>b. N\u00e3o permite a cria\u00e7\u00e3o de um esqueleto inicial do programa.  </li> <li>c. Requer que todos os m\u00f3dulos sejam testados simultaneamente.  </li> <li>d. Aumenta a possibilidade de erros humanos durante a fase de design.  </li> </ul> <p>RESPOSTA: b. N\u00e3o permite a cria\u00e7\u00e3o de um esqueleto inicial do programa.</p> <p>Uma desvantagem da estrat\u00e9gia bottom-up \u00e9 que n\u00e3o h\u00e1 conceito de um programa esquel\u00e9tico inicial. De fato, o programa funcional n\u00e3o existe at\u00e9 que o \u00faltimo m\u00f3dulo (m\u00f3dulo A) seja adicionado, e esse programa funcional \u00e9 o programa completo.</p> <p>Refer\u00eancia: The Art of Software Testing \u2013 3rd Edition, p\u00e1gina 107.</p>"},{"location":"tpi_tpe/tpi4_tpe4/","title":"TPI/TPE(4) - Quest\u00f5es de Testes de Software","text":""},{"location":"tpi_tpe/tpi4_tpe4/#q01-o-que-sao-objetos-dummy","title":"Q01. O que s\u00e3o objetos dummy?","text":"<ul> <li>a. Objetos que possuem implementa\u00e7\u00f5es reais, mas simplificadas.</li> <li>b. Objetos passados para a classe em teste, mas nunca utilizados.</li> <li>c. Objetos que fornecem respostas codificadas para chamadas realizadas durante o teste.</li> <li>d. Objetos que gravam todas as intera\u00e7\u00f5es e permitem fazer asser\u00e7\u00f5es posteriormente.</li> </ul> <p>RESPOSTA: b. Objetos passados para a classe em teste, mas nunca utilizados.</p> <p>Objetos dummy s\u00e3o passados para a classe em teste, mas nunca s\u00e3o utilizados. Isso \u00e9 comum em aplica\u00e7\u00f5es de neg\u00f3cio, onde \u00e9 necess\u00e1rio preencher uma longa lista de par\u00e2metros, mas o teste utiliza apenas alguns deles. Pense em um teste de unidade para uma classe Customer. Talvez essa classe dependa de v\u00e1rias outras, como Address, Email, e assim por diante. Talvez um caso de teste espec\u00edfico (caso A) queira exercitar um comportamento, e esse comportamento n\u00e3o se importa com qual Address o Customer possui. Nesse caso, o testador pode criar um objeto Address dummy e pass\u00e1-lo para a classe Customer.</p> <p>(Tradu\u00e7\u00e3o Livre de Aniche, 2022, Cap. 6)</p> <p>Dummy objects are passed to the class under test but never used. This is common in business applications where you need to fill a long list of parameters, but the test exercises only a few of them. Think of a unit test for a Customer class. Maybe this class depends on several other classes like Address, Email, and so on. Maybe a specific test case A wants to exercise a behavior, and this behavior does not care which Address this Customer has. In this case, a tester can set up a dummy Address object and pass it to the Customer class.</p> <p>(Aniche, 2022, Cap. 6)</p> <p>Objetos Dummy s\u00e3o uma forma degenerada de Test Double. Eles existem apenas para serem passados de m\u00e9todo para m\u00e9todo; eles nunca s\u00e3o utilizados. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 728)</p> <p>Um objeto dummy \u00e9 passado para preencher uma lista de par\u00e2metros, mas nunca \u00e9 usado. Eles s\u00e3o mais frequentemente usados para preencher par\u00e2metros obrigat\u00f3rios em m\u00e9todos ou construtores. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 728)</p> <p>Algumas linguagens exigem que forne\u00e7amos valores para todos os par\u00e2metros formais de um m\u00e9todo; objetos dummy nos permitem satisfazer esse requisito sem afetar o comportamento do teste. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 728)</p> <p>Refer\u00eancia: Meszaros, G. (2007). xUnit Test Patterns: Refactoring Test Code. Addison-Wesley. Aniche, Maur\u00edcio. Effective Software Testing: A Developer's Guide. Manning, 26 de abril de 2022. ISBN\u201110: 1633439933; ISBN\u201113: 978\u20111633439931.</p>"},{"location":"tpi_tpe/tpi4_tpe4/#por-que-as-outras-alternativas-estao-erradas","title":"Por que as outras alternativas est\u00e3o erradas","text":"<ul> <li>a. Objetos que possuem implementa\u00e7\u00f5es reais, mas simplificadas.</li> </ul> <p>Isso define um Fake Object: substitu\u00edmos um componente do SUT por uma implementa\u00e7\u00e3o funcional mais leve. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 551)</p> <ul> <li>c. Objetos que fornecem respostas codificadas para chamadas realizadas durante o teste.</li> </ul> <p>Isso define um Test Stub: substitu\u00edmos um objeto real por um objeto de teste que fornece entradas indiretas. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 529)</p> <ul> <li>d. Objetos que gravam todas as intera\u00e7\u00f5es e permitem fazer asser\u00e7\u00f5es posteriormente.</li> </ul> <p>Isso corresponde a um Test Spy: usamos um Test Double para capturar as chamadas indiretas feitas pelo SUT para posterior verifica\u00e7\u00e3o. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 538)</p> <p>Refer\u00eancia: Meszaros, G. (2007). xUnit Test Patterns: Refactoring Test Code. Addison-Wesley. Aniche, Maur\u00edcio. Effective Software Testing: A Developer's Guide. Manning, 26 de abril de 2022. ISBN\u201110: 1633439933; ISBN\u201113: 978\u20111633439931.</p>"},{"location":"tpi_tpe/tpi4_tpe4/#q02-qual-a-principal-caracteristica-de-objetos-fake","title":"Q02. Qual a principal caracter\u00edstica de objetos fake?","text":"<ul> <li>a. Eles t\u00eam implementa\u00e7\u00f5es reais, mas geralmente fazem a tarefa de forma mais simples.</li> <li>b. Eles fornecem respostas codificadas para chamadas realizadas durante o teste.</li> <li>c. Eles gravam todas as intera\u00e7\u00f5es e permitem fazer asser\u00e7\u00f5es posteriormente.</li> <li>d. Eles envolvem o objeto real e observam seu comportamento.</li> </ul> <p>RESPOSTA: a. Eles t\u00eam implementa\u00e7\u00f5es reais, mas geralmente fazem a tarefa de forma mais simples.</p> <p>Objetos fake possuem implementa\u00e7\u00f5es reais e funcionais da classe que est\u00e3o simulando. No entanto, eles geralmente realizam a mesma tarefa de forma muito mais simples. Imagine uma classe de banco de dados fake que usa uma ArrayList em vez de um banco de dados real. Esse objeto fake \u00e9 mais f\u00e1cil de controlar do que o banco verdadeiro. Um exemplo comum na pr\u00e1tica \u00e9 usar um banco de dados mais simples durante os testes. No mundo Java, os desenvolvedores costumam utilizar o HSQLDB (HyperSQL Database, http://hsqldb.org), um banco de dados em mem\u00f3ria que \u00e9 muito mais r\u00e1pido e f\u00e1cil de configurar no c\u00f3digo de teste do que um banco de dados real. Falaremos mais sobre bancos de dados em mem\u00f3ria quando discutirmos testes de integra\u00e7\u00e3o no cap\u00edtulo 9.</p> <p>(Tradu\u00e7\u00e3o Livre de Aniche, 2022, Cap. 6)</p> <p>Fake objects have real working implementations of the class they simulate. However, they usually do the same task in a much simpler way. Imagine a fake database class that uses an array list instead of a real database. This fake object is simpler to control than the real database. A common example in real life is to use a simpler database during testing. In the Java world, developers like to use HSQLDB (HyperSQL database, http://hsqldb.org), an in-memory database that is much faster and easier to set up in the test code than a real database. We will talk more about in-memory databases when we discuss integration testing in chapter 9.</p> <p>(Aniche, 2022, Cap. 6)</p> <p>Um Fake Object \u00e9 um dubl\u00ea de teste que substitui um componente do SUT com uma implementa\u00e7\u00e3o funcional, geralmente mais leve. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 551)</p> <p>Muitas vezes, usamos fakes para evitar depend\u00eancias de infraestrutura como banco de dados ou servi\u00e7os de rede. Por exemplo, um fake pode ser um banco de dados em mem\u00f3ria simples usado em vez de um real. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 551)</p> <p>Um fake geralmente implementa a mesma interface que o objeto real, mas com um comportamento mais simples, suficiente para os testes. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 551)</p>"},{"location":"tpi_tpe/tpi4_tpe4/#por-que-as-outras-alternativas-estao-erradas_1","title":"Por que as outras alternativas est\u00e3o erradas","text":"<ul> <li>b. Eles fornecem respostas codificadas para chamadas realizadas durante o teste.</li> </ul> <p>Isso define um Test Stub, n\u00e3o um fake. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 529)</p> <ul> <li>c. Eles gravam todas as intera\u00e7\u00f5es e permitem fazer asser\u00e7\u00f5es posteriormente.</li> </ul> <p>Essa \u00e9 a defini\u00e7\u00e3o de um Test Spy. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 538)</p> <ul> <li>d. Eles envolvem o objeto real e observam seu comportamento.</li> </ul> <p>Isso descreve um Mock Object, especialmente um mock din\u00e2mico que usa proxying para observar intera\u00e7\u00f5es. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 544)</p> <p>Refer\u00eancia: Meszaros, G. (2007). xUnit Test Patterns: Refactoring Test Code. Addison-Wesley. Aniche, Maur\u00edcio. Effective Software Testing: A Developer's Guide. Manning, 26 de abril de 2022. ISBN\u201110: 1633439933; ISBN\u201113: 978\u20111633439931.</p>"},{"location":"tpi_tpe/tpi4_tpe4/#q03-como-os-stubs-diferem-dos-objetos-fake","title":"Q03. Como os stubs diferem dos objetos fake?","text":"<ul> <li>a. Stubs t\u00eam implementa\u00e7\u00f5es reais, mas simplificadas.</li> <li>b. Stubs s\u00e3o usados apenas para observar o comportamento de uma depend\u00eancia real.</li> <li>c. Stubs fornecem respostas codificadas e n\u00e3o t\u00eam uma implementa\u00e7\u00e3o funcional.</li> <li>d. Stubs permitem fazer asser\u00e7\u00f5es sobre as intera\u00e7\u00f5es ap\u00f3s o teste.</li> </ul> <p>RESPOSTA: c. Stubs fornecem respostas codificadas e n\u00e3o t\u00eam uma implementa\u00e7\u00e3o funcional.</p> <p>Stubs fornecem respostas codificadas para as chamadas realizadas durante o teste. Diferente dos objetos fake, stubs n\u00e3o t\u00eam uma implementa\u00e7\u00e3o funcional. Se o c\u00f3digo chamar um m\u00e9todo stubado como getAllInvoices, o stub retornar\u00e1 uma lista de faturas codificada manualmente. Stubs s\u00e3o o tipo mais popular de simula\u00e7\u00e3o. Na maioria dos casos, tudo o que voc\u00ea precisa de uma depend\u00eancia \u00e9 que ela retorne um valor, permitindo que o m\u00e9todo em teste continue sua execu\u00e7\u00e3o. Se estivermos testando um m\u00e9todo que depende do getAllInvoices, podemos stub\u00e1-lo para retornar uma lista vazia, depois uma lista com um elemento, depois uma lista com v\u00e1rios elementos, e assim por diante. Isso nos permitiria verificar como o m\u00e9todo em teste se comporta ao receber listas de diferentes tamanhos, como se estivessem vindo do banco de dados. (Tradu\u00e7\u00e3o Livre de Aniche, 2022, Cap. 6)</p> <p>Stubs provide hard-coded answers to the calls performed during the test. Unlike fake objects, stubs do not have a working implementation. If the code calls a stubbed method getAllInvoices, the stub will return a hard-coded list of invoices. Stubs are the most popular type of simulation. In most cases, all you need from a dependency is for it to return a value so the method under test can continue its execution. If we were testing a method that depends on this getAllInvoices method, we could stub it to return an empty list, then return a list with one element, then return a list with many elements, and so on. This would enable us to assert how the method under test would work for lists of various lengths being returned from the database.</p> <p>(Aniche, 2022, Cap. 6)</p> <p>Um Stub \u00e9 um Dubl\u00ea de Teste que fornece entradas indiretas para o SUT, retornando valores codificados em resposta a chamadas feitas durante o teste. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 529)</p> <p>Os stubs n\u00e3o possuem comportamento funcional; eles apenas retornam valores predefinidos quando chamados. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 529)</p> <p>Em contraste, um Fake Object substitui um componente por uma implementa\u00e7\u00e3o funcional mais leve, como um banco de dados em mem\u00f3ria. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 551)</p> <p>Um Fake geralmente \u00e9 uma implementa\u00e7\u00e3o funcional completa (mas simples), o que o difere fundamentalmente de um stub que apenas devolve valores fixos. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 551)</p>"},{"location":"tpi_tpe/tpi4_tpe4/#por-que-as-outras-alternativas-estao-erradas_2","title":"Por que as outras alternativas est\u00e3o erradas","text":"<ul> <li>a. Stubs t\u00eam implementa\u00e7\u00f5es reais, mas simplificadas.</li> </ul> <p>Essa \u00e9 a defini\u00e7\u00e3o de um Fake, n\u00e3o de um Stub. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 551)</p> <ul> <li>b. Stubs s\u00e3o usados apenas para observar o comportamento de uma depend\u00eancia real.</li> </ul> <p>Isso descreve um Test Spy ou um Mock, e n\u00e3o um Stub. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 538)</p> <ul> <li>d. Stubs permitem fazer asser\u00e7\u00f5es sobre as intera\u00e7\u00f5es ap\u00f3s o teste.</li> </ul> <p>Quem permite isso s\u00e3o os Test Spies, n\u00e3o os Stubs. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 538)</p> <p>Refer\u00eancia: Meszaros, G. (2007). xUnit Test Patterns: Refactoring Test Code. Addison-Wesley. Aniche, Maur\u00edcio. Effective Software Testing: A Developer's Guide. Manning, 26 de abril de 2022. ISBN\u201110: 1633439933; ISBN\u201113: 978\u20111633439931.</p>"},{"location":"tpi_tpe/tpi4_tpe4/#q04-qual-a-vantagem-principal-dos-objetos-mocks-em-comparacao-com-os-stubs","title":"Q04. Qual a vantagem principal dos objetos mocks em compara\u00e7\u00e3o com os stubs?","text":"<ul> <li>a. Mocks t\u00eam implementa\u00e7\u00f5es reais.</li> <li>b. Mocks s\u00e3o mais f\u00e1ceis de controlar do que stubs.</li> <li>c. Mocks podem gravar intera\u00e7\u00f5es e permitir asser\u00e7\u00f5es sobre elas.</li> <li>d. Mocks fornecem respostas codificadas para chamadas realizadas durante o teste.</li> </ul> <p>RESPOSTA: c. Mocks podem gravar intera\u00e7\u00f5es e permitir asser\u00e7\u00f5es sobre elas.</p> <p>Objetos mock se comportam como stubs no sentido de que voc\u00ea pode configurar como eles devem responder quando um m\u00e9todo for chamado \u2014 por exemplo, retornar uma lista de faturas quando o m\u00e9todo getAllInvoices for invocado. No entanto, os mocks v\u00e3o al\u00e9m disso. Eles registram todas as intera\u00e7\u00f5es e permitem que voc\u00ea fa\u00e7a asser\u00e7\u00f5es posteriormente. Por exemplo, talvez queiramos garantir que o m\u00e9todo getAllInvoices seja chamado apenas uma vez. Se a classe em teste o chamar duas vezes, isso \u00e9 um erro, e o teste deve falhar. No fim do teste, podemos escrever uma asser\u00e7\u00e3o do tipo: \u201cverifique se getAllInvoices foi chamado apenas uma vez\u201d. Frameworks de mocking permitem verificar diversos tipos de intera\u00e7\u00f5es, como: \u201co m\u00e9todo nunca foi chamado com este par\u00e2metro espec\u00edfico\u201d ou \u201co m\u00e9todo foi chamado duas vezes com o par\u00e2metro A e uma vez com o par\u00e2metro B\u201d. Mocks tamb\u00e9m s\u00e3o populares na ind\u00fastria porque fornecem visibilidade sobre como as classes interagem. (Tradu\u00e7\u00e3o Livre de Aniche, 2022, Cap. 6)</p> <p>Mock objects act like stubs in the sense that you can configure how they reply if a method is called: for example, to return a list of invoices when getAllInvoices is called. However, mocks go beyond that. They save all the interactions and allow you to make assertions afterward. For example, maybe we only want the getAllInvoices method to be called once. If the method is called twice by the class under test, this is a bug, and the test should fail. At the end of our test, we can write an assertion along the lines of \u201cverify that getAllInvoices was called just once.\u201d Mocking frameworks let you assert all sorts of interactions, such as \u201cthe method was never called with this specific parameter\u201d or \u201cthe method was called twice with parameter A and once with parameter B.\u201d Mocks are also popular in industry since they can provide insight into how classes interact.</p> <p>(Aniche, 2022, Cap. 6)</p> <p>Um Mock Object \u00e9 um dubl\u00ea de teste que \u00e9 pr\u00e9-programado com expectativas, que representam uma especifica\u00e7\u00e3o das chamadas que ele deve receber. O mock verifica automaticamente se essas chamadas ocorrem e, se n\u00e3o, o teste falha. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 544)</p> <p>Os mocks s\u00e3o frequentemente criados por meio de bibliotecas que permitem especificar as intera\u00e7\u00f5es esperadas. Essas intera\u00e7\u00f5es s\u00e3o registradas durante a execu\u00e7\u00e3o, e as bibliotecas de mocks verificam automaticamente se o comportamento ocorreu como esperado. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 544)</p> <p>Em contraste, um Stub apenas fornece valores de retorno predefinidos e n\u00e3o verifica intera\u00e7\u00f5es com o SUT. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 529)</p> <p>Os stubs n\u00e3o sabem se foram chamados corretamente; s\u00e3o usados apenas para injetar entradas indiretas no SUT. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 529)</p>"},{"location":"tpi_tpe/tpi4_tpe4/#por-que-as-outras-alternativas-estao-erradas_3","title":"Por que as outras alternativas est\u00e3o erradas","text":"<ul> <li>a. Mocks t\u00eam implementa\u00e7\u00f5es reais.</li> </ul> <p>Isso define um Fake Object, que \u00e9 uma implementa\u00e7\u00e3o funcional simplificada, n\u00e3o um Mock. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 551)</p> <ul> <li>b. Mocks s\u00e3o mais f\u00e1ceis de controlar do que stubs.</li> </ul> <p>O livro n\u00e3o afirma que mocks s\u00e3o \"mais f\u00e1ceis de controlar\". Ele aponta que mocks s\u00e3o usados para verificar intera\u00e7\u00f5es, enquanto stubs s\u00e3o usados para fornecer entradas indiretas. (p. 544 vs. 529, Meszaros, 2007)</p> <ul> <li>d. Mocks fornecem respostas codificadas para chamadas realizadas durante o teste.</li> </ul> <p>Quem faz isso s\u00e3o os Stubs, n\u00e3o os Mocks. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 529)</p> <p>Refer\u00eancia: Meszaros, G. (2007). xUnit Test Patterns: Refactoring Test Code. Addison-Wesley. Aniche, Maur\u00edcio. Effective Software Testing: A Developer's Guide. Manning, 26 de abril de 2022. ISBN\u201110: 1633439933; ISBN\u201113: 978\u20111633439931.</p>"},{"location":"tpi_tpe/tpi4_tpe4/#q05-uma-classe-que-simula-uma-base-de-dados-usando-uma-lista-pode-ser-classificada-como","title":"Q05. Uma classe que simula uma base de dados usando uma lista pode ser classificada como:","text":"<ul> <li>a. Fake object</li> <li>b. Dummy object</li> <li>c. Mock</li> <li>d. Stub</li> </ul> <p>RESPOSTA: a. Fake object</p> <p>Objetos fake t\u00eam implementa\u00e7\u00f5es reais e funcionais da classe que est\u00e3o simulando. No entanto, geralmente realizam a mesma tarefa de uma forma muito mais simples. Imagine uma classe de banco de dados fake que usa uma ArrayList em vez de um banco de dados real. Esse objeto fake \u00e9 mais f\u00e1cil de controlar do que o banco de dados verdadeiro. Um exemplo comum na pr\u00e1tica \u00e9 usar um banco de dados mais simples durante os testes. No mundo Java, os desenvolvedores gostam de usar o HSQLDB (HyperSQL Database, http://hsqldb.org), um banco de dados em mem\u00f3ria que \u00e9 muito mais r\u00e1pido e f\u00e1cil de configurar no c\u00f3digo de teste do que um banco real. Falaremos mais sobre bancos de dados em mem\u00f3ria quando discutirmos testes de integra\u00e7\u00e3o no cap\u00edtulo 9. (Tradu\u00e7\u00e3o Livre de Aniche, 2022, Cap. 6)</p> <p>Fake objects have real working implementations of the class they simulate. However, they usually do the same task in a much simpler way. Imagine a fake database class that uses an array list instead of a real database. This fake object is simpler to control than the real database. A common example in real life is to use a simpler database during testing. In the Java world, developers like to use HSQLDB (HyperSQL database, http://hsqldb.org), an in-memory database that is much faster and easier to set up in the test code than a real database. We will talk more about in-memory databases when we discuss integration testing in chapter 9.</p> <p>(Aniche, 2022, Cap. 6)</p> <p>Um Fake Object \u00e9 um Dubl\u00ea de Teste que substitui um componente de que o SUT depende com uma implementa\u00e7\u00e3o funcional, geralmente mais leve. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 551)</p> <p>Um exemplo comum de fake \u00e9 uma implementa\u00e7\u00e3o em mem\u00f3ria de um banco de dados, usada em vez de um banco real durante os testes. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 551)</p> <p>Fakes s\u00e3o apropriados quando a implementa\u00e7\u00e3o alternativa \u00e9 mais r\u00e1pida ou f\u00e1cil de configurar do que a real, mas ainda fornece o comportamento necess\u00e1rio para os testes. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 551)</p>"},{"location":"tpi_tpe/tpi4_tpe4/#por-que-as-outras-alternativas-estao-erradas_4","title":"Por que as outras alternativas est\u00e3o erradas","text":"<ul> <li>b. Dummy object</li> </ul> <p>Dummies s\u00e3o passados para preencher par\u00e2metros, mas nunca s\u00e3o usados. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 728) Uma lista simulando uma base de dados \u00e9 usada funcionalmente, portanto n\u00e3o \u00e9 um dummy.</p> <ul> <li>c. Mock</li> </ul> <p>Mocks s\u00e3o configurados com expectativas de chamadas e verificam se elas ocorreram; n\u00e3o s\u00e3o usados para simular l\u00f3gica funcional como um banco de dados. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 544)</p> <ul> <li>d. Stub</li> </ul> <p>Stubs s\u00e3o usados para fornecer respostas codificadas a chamadas do SUT, mas n\u00e3o t\u00eam comportamento funcional completo como um banco de dados em mem\u00f3ria. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 529)</p> <p>Refer\u00eancia: Meszaros, G. (2007). xUnit Test Patterns: Refactoring Test Code. Addison-Wesley. Aniche, Maur\u00edcio. Effective Software Testing: A Developer's Guide. Manning, 26 de abril de 2022. ISBN\u201110: 1633439933; ISBN\u201113: 978\u20111633439931.</p>"},{"location":"tpi_tpe/tpi4_tpe4/#q06-o-que-pode-ser-necessario-para-injetar-dubles-de-teste","title":"Q06. O que pode ser necess\u00e1rio para injetar dubl\u00eas de teste?","text":"<ul> <li>a. Criar um tipo especial de dubl\u00ea que intercepte chamadas.</li> <li>b. Refatorar o construtor da classe de teste para instanciar a depend\u00eancia.</li> <li>c. Usar um framework de mocking para inje\u00e7\u00e3o autom\u00e1tica.</li> <li>d. Alterar o c\u00f3digo da classe sendo testada para aceitar a depend\u00eancia via construtor.</li> </ul> <p>RESPOSTA: d. Alterar o c\u00f3digo da classe sendo testada para aceitar a depend\u00eancia via construtor.</p> <p>Precisamos modificar nosso c\u00f3digo de produ\u00e7\u00e3o para facilitar os testes (acostume-se com a ideia de alterar o c\u00f3digo de produ\u00e7\u00e3o para torn\u00e1-lo mais test\u00e1vel). A forma mais direta de fazer isso \u00e9 passar IssuedInvoices como uma depend\u00eancia expl\u00edcita por meio do construtor da classe, como mostrado na listagem 6.3. A classe n\u00e3o instancia mais as classes DatabaseConnection e IssuedInvoices; em vez disso, ela recebe IssuedInvoices via construtor. Note que n\u00e3o h\u00e1 necessidade de injetar a classe DatabaseConnection, pois InvoiceFilter n\u00e3o precisa dela. Isso \u00e9 bom: quanto menos precisarmos fazer no c\u00f3digo de teste, melhor. A nova implementa\u00e7\u00e3o funciona tanto para os testes (porque podemos injetar um stub de IssuedInvoices) quanto para a produ\u00e7\u00e3o (porque podemos injetar a implementa\u00e7\u00e3o concreta de IssuedInvoices, que acessar\u00e1 o banco de dados, como esperamos em produ\u00e7\u00e3o).</p> <p>(Tradu\u00e7\u00e3o Livre de Aniche, 2022, Cap. 6)</p> <p>We must change our production code to make testing easier (get used to the idea of changing the production code to facilitate testing). The most direct way to do this is to have IssuedInvoices passed in as an explicit dependency through the class constructor, as shown in listing 6.3. The class no longer instantiates the DatabaseConnection and IssuedInvoices classes. Rather, it receives IssuedInvoices via constructor. Note that there is no need for the DatabaseConnection class to be injected, as InvoiceFilter does not need it. This is good: the less we need to do in our test code, the better. The new implementation works for both our tests (because we can inject an IssueInvoices stub) and production (because we can inject the concrete IssueInvoices, which will go to the database, as we expect in production).</p> <p>(Aniche, 2022, Cap. 6)</p> <p>Inje\u00e7\u00e3o por Construtor: informamos ao SUT qual DOC usar quando o constru\u00edmos. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 680)</p> <p>Para converter o SUT para usar Inje\u00e7\u00e3o por Construtor, podemos fazer um refatoramento do tipo \"Introduce Field\" para manter o DOC em um campo que \u00e9 inicializado no construtor existente. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 684)</p> <p>Quando um teste deseja substituir o DOC real por um dubl\u00ea de teste, ele o passa para o construtor ao construir o SUT. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 681)</p> <p>Quando o SUT n\u00e3o suporta inje\u00e7\u00e3o de depend\u00eancia \"de f\u00e1brica\", pode ser necess\u00e1rio refatorar o c\u00f3digo da classe sendo testada para permitir isso. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 682)</p>"},{"location":"tpi_tpe/tpi4_tpe4/#por-que-as-outras-alternativas-estao-erradas_5","title":"Por que as outras alternativas est\u00e3o erradas","text":"<ul> <li>a. Criar um tipo especial de dubl\u00ea que intercepte chamadas.</li> </ul> <p>O livro descreve mocks e spies como dubl\u00eas configur\u00e1veis, mas n\u00e3o afirma que a inje\u00e7\u00e3o exige criar um tipo especial que intercepte chamadas. Isso n\u00e3o \u00e9 necess\u00e1rio para inje\u00e7\u00e3o. (p. 522 e p. 544, Meszaros, 2007)</p> <ul> <li>b. Refatorar o construtor da classe de teste para instanciar a depend\u00eancia.</li> </ul> <p>O que precisa ser refatorado \u00e9 o construtor da classe sendo testada (SUT), n\u00e3o o da classe de teste. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 684)</p> <ul> <li>c. Usar um framework de mocking para inje\u00e7\u00e3o autom\u00e1tica.</li> </ul> <p>O livro menciona que frameworks de mock como JMock facilitam a cria\u00e7\u00e3o de mocks, mas n\u00e3o substituem a necessidade de refatorar o SUT para aceitar inje\u00e7\u00e3o. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 565)</p> <p>Refer\u00eancia: Meszaros, G. (2007). xUnit Test Patterns: Refactoring Test Code. Addison-Wesley. Aniche, Maur\u00edcio. Effective Software Testing: A Developer's Guide. Manning, 26 de abril de 2022. ISBN\u201110: 1633439933; ISBN\u201113: 978\u20111633439931.</p>"},{"location":"tpi_tpe/tpi4_tpe4/#q07-qual-a-principal-vantagem-de-configurar-dubles-para-lancar-excecoes","title":"Q07. Qual a principal vantagem de configurar dubl\u00eas para lan\u00e7ar exce\u00e7\u00f5es?","text":"<ul> <li>a. Permite testar como os sistemas se comportariam em cen\u00e1rios inesperados, simulando falhas.</li> <li>b. Garante que todos os m\u00e9todos sejam chamados ao menos uma vez.</li> <li>c. Facilita respostas codificadas.</li> <li>d. Substitui testes de integra\u00e7\u00e3o com sistemas externos.</li> </ul> <p>RESPOSTA: a. Permite testar como os sistemas se comportariam em cen\u00e1rios inesperados, simulando falhas.</p> <p>Temos mais controle. Podemos facilmente dizer a esses objetos falsos o que fazer. Se quisermos que um m\u00e9todo lance uma exce\u00e7\u00e3o, instru\u00edmos o m\u00e9todo mock a lan\u00e7\u00e1-la. N\u00e3o h\u00e1 necessidade de configura\u00e7\u00f5es complicadas para for\u00e7ar a depend\u00eancia a lan\u00e7ar a exce\u00e7\u00e3o. Pense em como \u00e9 dif\u00edcil for\u00e7ar uma classe a lan\u00e7ar uma exce\u00e7\u00e3o ou retornar uma data falsa. Esse esfor\u00e7o \u00e9 praticamente zero quando simulamos as depend\u00eancias com objetos mock.</p> <p>(Tradu\u00e7\u00e3o Livre de Aniche, 2022, Cap. 6)</p> <p>We have more control. We can easily tell these fake objects what to do. If we want a method to throw an exception, we tell the mock method to throw it. There is no need for complicated setups to force the dependency to throw the exception. Think of how hard it is to force a class to throw an exception or return a fake date. This effort is close to zero when we simulate the dependencies with mock objects.</p> <p>(Aniche, 2022, Cap. 6)</p> <p>Certamente n\u00e3o queremos que o c\u00f3digo de tratamento de exce\u00e7\u00f5es seja executado pela primeira vez em produ\u00e7\u00e3o. E se ele estiver implementado incorretamente? \u00c9 altamente desej\u00e1vel ter testes automatizados para esse c\u00f3digo. O desafio no teste \u00e9 fazer com que o DOC (componente dependente) lance uma exce\u00e7\u00e3o para que o caminho de erro possa ser testado. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 127)</p> <p>A exce\u00e7\u00e3o que esperamos que o DOC lance \u00e9 um bom exemplo de uma condi\u00e7\u00e3o de entrada indireta. Nosso meio de injetar essa entrada \u00e9 um ponto de controle. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 127)</p> <p>Um Saboteur \u00e9 um tipo especial de Test Stub que lan\u00e7a exce\u00e7\u00f5es ou erros para injetar entradas indiretas anormais no SUT. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 135)</p> <p>Um Expected Exception Test nos ajuda a verificar se os cen\u00e1rios de erro foram codificados corretamente. O modo mais comum de for\u00e7ar esses erros \u00e9 usar um Test Stub para controlar a entrada indireta e lan\u00e7ar as exce\u00e7\u00f5es apropriadas. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 350)</p>"},{"location":"tpi_tpe/tpi4_tpe4/#por-que-as-outras-alternativas-estao-erradas_6","title":"Por que as outras alternativas est\u00e3o erradas","text":"<ul> <li>b. Garante que todos os m\u00e9todos sejam chamados ao menos uma vez.</li> </ul> <p>Isso n\u00e3o \u00e9 relacionado ao lan\u00e7amento de exce\u00e7\u00f5es. Verificar se m\u00e9todos s\u00e3o chamados pertence ao comportamento de Mocks (verifica\u00e7\u00e3o de intera\u00e7\u00f5es), n\u00e3o ao uso de exce\u00e7\u00f5es. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 544)</p> <ul> <li>c. Facilita respostas codificadas.</li> </ul> <p>Quem faz isso s\u00e3o os Stubs do tipo Responder, usados para retornar valores predefinidos \u2014 n\u00e3o para lan\u00e7ar exce\u00e7\u00f5es. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 529)</p> <ul> <li>d. Substitui testes de integra\u00e7\u00e3o com sistemas externos.</li> </ul> <p>Dubl\u00eas podem ajudar a simular sistemas externos, mas o foco do uso de exce\u00e7\u00f5es n\u00e3o \u00e9 substituir testes de integra\u00e7\u00e3o, e sim permitir testar o comportamento em situa\u00e7\u00f5es de falha. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 127)</p> <p>Refer\u00eancia: Meszaros, G. (2007). xUnit Test Patterns: Refactoring Test Code. Addison-Wesley. Aniche, Maur\u00edcio. Effective Software Testing: A Developer's Guide. Manning, 26 de abril de 2022. ISBN\u201110: 1633439933; ISBN\u201113: 978\u20111633439931.</p>"},{"location":"tpi_tpe/tpi4_tpe4/#q08-qual-e-uma-das-principais-desvantagens-de-usar-dubles","title":"Q08. Qual \u00e9 uma das principais desvantagens de usar dubl\u00eas?","text":"<ul> <li>a. O acoplamento com o c\u00f3digo de produ\u00e7\u00e3o, que pode levar a falhas ao mudar intera\u00e7\u00f5es.</li> <li>b. Dificuldade de configura\u00e7\u00e3o e manuten\u00e7\u00e3o.</li> <li>c. Incapacidade de simular comportamentos complexos.</li> <li>d. Modifica\u00e7\u00e3o excessiva do c\u00f3digo de produ\u00e7\u00e3o.</li> </ul> <p>RESPOSTA: a. O acoplamento com o c\u00f3digo de produ\u00e7\u00e3o, que pode levar a falhas ao mudar intera\u00e7\u00f5es.</p> <p>Testes que utilizam mocks s\u00e3o mais acoplados ao c\u00f3digo de produ\u00e7\u00e3o do que testes que n\u00e3o os utilizam. Quando esse acoplamento n\u00e3o \u00e9 cuidadosamente planejado, ele pode se tornar problem\u00e1tico.</p> <p>(Tradu\u00e7\u00e3o Livre de Aniche, 2022, Cap. 6)</p> <p>Tests that use mocks are more coupled with the production code than tests that do not use mocks. When not carefully planned, such coupling can be problematic.</p> <p>(Aniche, 2022, Cap. 6)</p> <p>Podemos tamb\u00e9m implementar o Test Double criando uma subclasse da DOC real e sobrescrevendo os m\u00e9todos cujo comportamento queremos mudar. Infelizmente, essa abordagem pode ter consequ\u00eancias imprevis\u00edveis se o SUT chamar outros m\u00e9todos da DOC que n\u00e3o foram sobrescritos. Isso tamb\u00e9m acopla fortemente o c\u00f3digo de teste \u00e0 implementa\u00e7\u00e3o da DOC, o que pode resultar em software superespecificado. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 570)</p> <p>Testes fr\u00e1geis indicam que os testes est\u00e3o muito acoplados ao SUT. Isso causa alto custo de manuten\u00e7\u00e3o, pois os testes precisam ser revisados com frequ\u00eancia, mesmo quando mudan\u00e7as m\u00ednimas s\u00e3o feitas. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 266)</p> <p>O custo alto de manuten\u00e7\u00e3o dos testes decorre do fato de que os testes ficam excessivamente dif\u00edceis de entender e manter. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 265)</p>"},{"location":"tpi_tpe/tpi4_tpe4/#por-que-as-outras-alternativas-estao-erradas_7","title":"Por que as outras alternativas est\u00e3o erradas","text":"<ul> <li>b. Dificuldade de configura\u00e7\u00e3o e manuten\u00e7\u00e3o.</li> </ul> <p>O livro trata da manuten\u00e7\u00e3o como uma consequ\u00eancia de outros problemas (como acoplamento excessivo e duplica\u00e7\u00e3o de c\u00f3digo), mas n\u00e3o afirma que os dubl\u00eas s\u00e3o dif\u00edceis de configurar por si s\u00f3. Pelo contr\u00e1rio, Configurable Test Doubles s\u00e3o justamente uma solu\u00e7\u00e3o para facilitar isso. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 558)</p> <ul> <li>c. Incapacidade de simular comportamentos complexos.</li> </ul> <p>N\u00e3o \u00e9 mencionado como limita\u00e7\u00e3o. Pelo contr\u00e1rio, mocks e fakes s\u00e3o usados justamente para simular comportamentos complexos e dif\u00edceis de reproduzir com o objeto real. (p. 544, 551, Meszaros, 2007)</p> <ul> <li>d. Modifica\u00e7\u00e3o excessiva do c\u00f3digo de produ\u00e7\u00e3o.</li> </ul> <p>O livro recomenda pr\u00e1ticas como Dependency Injection para evitar altera\u00e7\u00f5es desnecess\u00e1rias no c\u00f3digo de produ\u00e7\u00e3o, ou seja, altera\u00e7\u00f5es s\u00e3o uma solu\u00e7\u00e3o e n\u00e3o um problema causado por dubl\u00eas. (p. 678\u2013682, Meszaros, 2007)</p> <p>Refer\u00eancia: Meszaros, G. (2007). xUnit Test Patterns: Refactoring Test Code. Addison-Wesley. Aniche, Maur\u00edcio. Effective Software Testing: A Developer's Guide. Manning, 26 de abril de 2022. ISBN\u201110: 1633439933; ISBN\u201113: 978\u20111633439931.</p>"},{"location":"tpi_tpe/tpi4_tpe4/#q09-qual-e-o-ciclo-repetido-no-processo-de-tdd","title":"Q09. Qual \u00e9 o ciclo repetido no processo de TDD?","text":"<ul> <li>a. Teste passa \u2192 implementa\u00e7\u00e3o \u2192 refatora\u00e7\u00e3o</li> <li>b. Teste falha \u2192 implementa\u00e7\u00e3o \u2192 refatora\u00e7\u00e3o</li> <li>c. Implementa\u00e7\u00e3o \u2192 teste passa \u2192 refatora\u00e7\u00e3o</li> <li>d. Refatora\u00e7\u00e3o \u2192 teste falha \u2192 implementa\u00e7\u00e3o</li> </ul> <p>RESPOSTA: b. Teste falha \u2192 implementa\u00e7\u00e3o \u2192 refatora\u00e7\u00e3o</p> <p>Refletindo sobre nossa primeira experi\u00eancia com TDD</p> <p>De forma abstrata, o ciclo que repetimos no processo de desenvolvimento da se\u00e7\u00e3o anterior foi o seguinte:</p> <ol> <li>Escrevemos um teste (de unidade) para a pr\u00f3xima funcionalidade que quer\u00edamos implementar. O teste falhou.</li> <li>Implementamos a funcionalidade. O teste passou.</li> <li>Refatoramos nosso c\u00f3digo de produ\u00e7\u00e3o e o c\u00f3digo de teste.</li> </ol> <p>(Tradu\u00e7\u00e3o Livre de Aniche, 2022, Cap. 8)</p> <p>Reflecting on our first TDD experience</p> <p>Abstractly, the cycle we repeated in the previous section\u2019s development process was as follows:</p> <ol> <li>We wrote a (unit) test for the next piece of functionality we wanted to implement. The test failed.</li> <li>We implemented the functionality. The test passed.</li> <li> <p>We refactored our production and test code.</p> <p>(Aniche, 2022, Cap. 8)</p> </li> </ol> <p>O ciclo geral do TDD \u00e9 o seguinte:</p> <ol> <li>Escreva um teste.</li> <li>Fa\u00e7a com que ele funcione. Colocar a barra verde rapidamente domina tudo.</li> <li>Fa\u00e7a certo. Agora que o sistema se comporta, remova duplica\u00e7\u00f5es. (Cap\u00edtulo 2, Beck, 2002)</li> </ol> <p>Lembre-se, o ciclo \u00e9 o seguinte: Adicione um pequeno teste. Execute todos os testes e veja falhar. Fa\u00e7a uma pequena mudan\u00e7a. Execute todos os testes e veja passar. Refatore para remover duplica\u00e7\u00f5es. (Cap\u00edtulo 1, Beck, 2002)</p> <p>TDD responde \u00e0 contradi\u00e7\u00e3o com um paradoxo \u2014 teste o programa antes de escrev\u00ea-lo. (Introdu\u00e7\u00e3o, Beck, 2002)</p>"},{"location":"tpi_tpe/tpi4_tpe4/#por-que-as-outras-alternativas-estao-erradas_8","title":"Por que as outras alternativas est\u00e3o erradas","text":"<ul> <li>a. Teste passa \u2192 implementa\u00e7\u00e3o \u2192 refatora\u00e7\u00e3o</li> </ul> <p>Isso inverte a ordem correta, j\u00e1 que o teste precisa falhar primeiro para guiar a implementa\u00e7\u00e3o.</p> <ul> <li>c. Implementa\u00e7\u00e3o \u2192 teste passa \u2192 refatora\u00e7\u00e3o</li> </ul> <p>Esta \u00e9 a abordagem tradicional, mas n\u00e3o \u00e9 TDD, pois ignora a cria\u00e7\u00e3o do teste antes da implementa\u00e7\u00e3o.</p> <ul> <li>d. Refatora\u00e7\u00e3o \u2192 teste falha \u2192 implementa\u00e7\u00e3o</li> </ul> <p>Tamb\u00e9m est\u00e1 fora da ordem. A refatora\u00e7\u00e3o vem depois que os testes est\u00e3o passando.</p> <p>Refer\u00eancia: Beck, K. (2002). Test-Driven Development: By Example. Addison-Wesley. Aniche, Maur\u00edcio. Effective Software Testing: A Developer's Guide. Manning, 26 de abril de 2022. ISBN\u201110: 1633439933; ISBN\u201113: 978\u20111633439931.</p>"},{"location":"tpi_tpe/tpi4_tpe4/#q10-por-que-o-tdd-facilita-a-identificacao-de-problemas","title":"Q10. Por que o TDD facilita a identifica\u00e7\u00e3o de problemas?","text":"<ul> <li>a. Porque desenvolvedores escrevem c\u00f3digo antes dos testes.</li> <li>b. Porque desenvolvedores focam no produto final.</li> <li>c. Porque todos os testes s\u00e3o escritos antes da implementa\u00e7\u00e3o.</li> <li>d. Porque o ciclo incremental permite detectar problemas ap\u00f3s pequenas altera\u00e7\u00f5es.</li> </ul> <p>RESPOSTA: d. Porque o ciclo incremental permite detectar problemas ap\u00f3s pequenas altera\u00e7\u00f5es.</p> <p>Feedback r\u00e1pido \u2014 Desenvolvedores que n\u00e3o trabalham em ciclos de TDD produzem grandes blocos de c\u00f3digo de produ\u00e7\u00e3o antes de receber qualquer tipo de feedback. Em um ciclo de TDD, os desenvolvedores s\u00e3o for\u00e7ados a dar um passo de cada vez. Escrevemos um teste, fazemos com que ele passe e refletimos sobre isso. Esses v\u00e1rios momentos de reflex\u00e3o tornam mais f\u00e1cil identificar novos problemas \u00e0 medida que surgem, pois escrevemos apenas uma pequena quantidade de c\u00f3digo desde a \u00faltima vez em que tudo estava sob controle.</p> <p>(Tradu\u00e7\u00e3o Livre de Aniche, 2022, Cap. 8)</p> <p>Quick feedback \u2014 Developers who do not work in TDD cycles produce large chunks of production code before getting any feedback. In a TDD cycle, developers are forced to take one step at a time. We write one test, make it pass, and reflect on it. These many moments of reflection make it easier to identify new problems as they arise, because we have only written a small amount of code since the last time everything was under control.</p> <p>(Aniche, 2022, Cap. 8)</p> <p>O processo de desenvolvimento orientado a testes (TDD) incentiva a \"escrever um teste e depois \"escrever algum c\u00f3digo para fazer esse teste passar. Esse processo n\u00e3o envolve escrever todos os testes antes de qualquer c\u00f3digo, mas sim escrever testes e c\u00f3digo de forma intercalada em passos muito pequenos. (Cap\u00edtulo 4, Meszaros, 2007)</p> <p>Isso \u00e9 desenvolvimento incremental no seu melhor. Muitos adeptos do TDD relatam que raramente usam o depurador, porque os testes em pequenas etapas localizam claramente o defeito e a \u00faltima altera\u00e7\u00e3o feita (que causou o problema) ainda est\u00e1 fresca na mem\u00f3ria. (Cap\u00edtulo 4, Meszaros, 2007)</p> <p>Lembre-se, o ciclo \u00e9 o seguinte:</p> <ol> <li>Adicione um pequeno teste.</li> <li>Execute todos os testes e veja falhar.</li> <li>Fa\u00e7a uma pequena mudan\u00e7a.</li> <li>Execute todos os testes e veja passar.</li> <li>Refatore para remover duplica\u00e7\u00f5es.</li> </ol> <p>O TDD permite que qualquer desenvolvedor escreva c\u00f3digo confi\u00e1vel e livre de erros, n\u00e3o importa o qu\u00e3o complexo ele seja. O desenvolvimento com testes automatizados e elimina\u00e7\u00e3o de duplica\u00e7\u00f5es encoraja mudan\u00e7as pequenas e constantes, facilitando identificar o que quebrou e quando. (Introdu\u00e7\u00e3o, Beck, 2002)</p>"},{"location":"tpi_tpe/tpi4_tpe4/#por-que-as-outras-alternativas-estao-erradas_9","title":"Por que as outras alternativas est\u00e3o erradas","text":"<ul> <li>a. Porque desenvolvedores escrevem c\u00f3digo antes dos testes.</li> </ul> <p>Falso. TDD prop\u00f5e exatamente o contr\u00e1rio: escrevemos o teste antes do c\u00f3digo. (Introdu\u00e7\u00e3o, Beck, 2002)</p> <ul> <li>b. Porque desenvolvedores focam no produto final.</li> </ul> <p>O foco est\u00e1 no comportamento incremental e test\u00e1vel, n\u00e3o no \"produto final\". (Cap\u00edtulo 4, Meszaros, 2007)</p> <ul> <li>c. Porque todos os testes s\u00e3o escritos antes da implementa\u00e7\u00e3o.</li> </ul> <p>N\u00e3o \u00e9 verdade. O TDD escreve um teste de cada vez, intercalado com c\u00f3digo. (Cap\u00edtulo 4, Meszaros, 2007)</p> <p>Refer\u00eancias: Beck, K. (2002). Test-Driven Development: By Example. Addison-Wesley. Meszaros, G. (2007). xUnit Test Patterns: Refactoring Test Code. Addison-Wesley. Aniche, Maur\u00edcio. Effective Software Testing: A Developer's Guide. Manning, 26 de abril de 2022. ISBN\u201110: 1633439933; ISBN\u201113: 978\u20111633439931.</p>"},{"location":"tpi_tpe/tpi4_tpe4/#q11-como-o-tdd-afeta-o-design","title":"Q11. Como o TDD afeta o design?","text":"<ul> <li>a. Testes n\u00e3o influenciam o design.</li> <li>b. O teste \u00e9 o primeiro cliente da classe, influenciando seu design.</li> <li>c. TDD encoraja designs mais complexos.</li> <li>d. TDD desencoraja refatora\u00e7\u00e3o.</li> </ul> <p>RESPOSTA: b. O teste \u00e9 o primeiro cliente da classe, influenciando seu design.</p> <p>C\u00f3digo test\u00e1vel \u2014 Criar os testes primeiro nos faz pensar, desde o in\u00edcio, em uma forma de testar (facilmente) o c\u00f3digo de produ\u00e7\u00e3o antes mesmo de implement\u00e1-lo. No fluxo tradicional, os desenvolvedores costumam pensar em testes apenas nas fases finais do desenvolvimento de uma funcionalidade. Nesse ponto, pode ser caro mudar como o c\u00f3digo funciona para facilitar os testes.</p> <p>(Tradu\u00e7\u00e3o Livre de Aniche, 2022, Cap. 8)</p> <p>Feedback sobre o design \u2014 O c\u00f3digo de teste costuma ser o primeiro cliente da classe ou componente que estamos desenvolvendo. Um m\u00e9todo de teste instancia a classe em teste, invoca um m\u00e9todo passando todos os par\u00e2metros necess\u00e1rios e verifica se o m\u00e9todo produz os resultados esperados. Se isso for dif\u00edcil de fazer, talvez exista uma forma melhor de projetar a classe. Ao praticar TDD, esses problemas surgem mais cedo no desenvolvimento da funcionalidade. E quanto mais cedo identificamos esses problemas, mais barato \u00e9 corrigi-los.</p> <p>(Tradu\u00e7\u00e3o Livre de Aniche, 2022, Cap. 8)</p> <p>Testable code \u2014 Creating the tests first makes us think from the beginning about a way to (easily) test the production code before implementing it. In the traditional flow, developers often think about testing only in the later stages of developing a feature. At that point, it may be expensive to change how the code works to facilitate testing.</p> <p>(Aniche, 2022, Cap. 8)</p> <p>Feedback about design \u2014 The test code is often the first client of the class or component we are developing. A test method instantiates the class under test, invokes a method passing all its required parameters, and asserts that the method produces the expected results. If this is hard to do, perhaps there is a better way to design the class. When doing TDD, these problems arise earlier in the development of the feature. And the earlier we observe such issues, the cheaper it is to fix them.</p> <p>(Aniche, 2022, Cap. 8)</p> <p>O TDD incentiva designs simples e conjuntos de testes que inspiram confian\u00e7a. (Introdu\u00e7\u00e3o, Beck, 2002)</p> <p>Voc\u00ea escrever\u00e1 um teste. Imagine como gostaria que a opera\u00e7\u00e3o parecesse em seu c\u00f3digo. Voc\u00ea est\u00e1 escrevendo uma hist\u00f3ria. Invente a interface que gostaria de ter. (Cap\u00edtulo 2, Beck, 2002)</p> <p>Como resultado, o teste se torna o primeiro cliente da classe, moldando seu design de forma natural, orientada por uso real. (Cap\u00edtulo 17, Beck, 2002)</p> <p>Cres\u00e7a o design organicamente, por meio de refatora\u00e7\u00f5es, adicionando decis\u00f5es de design uma de cada vez. (Introdu\u00e7\u00e3o, Beck, 2002)</p>"},{"location":"tpi_tpe/tpi4_tpe4/#por-que-as-outras-alternativas-estao-erradas_10","title":"Por que as outras alternativas est\u00e3o erradas","text":"<ul> <li>a. Testes n\u00e3o influenciam o design.</li> </ul> <p>Falso. O TDD molda o design desde o in\u00edcio, com o teste sendo o primeiro cliente da API. (Cap\u00edtulo 17, Beck, 2002)</p> <ul> <li>c. TDD encoraja designs mais complexos.</li> </ul> <p>Pelo contr\u00e1rio, TDD incentiva designs simples e incrementais. (Introdu\u00e7\u00e3o, Beck, 2002)</p> <ul> <li>d. TDD desencoraja refatora\u00e7\u00e3o.</li> </ul> <p>Falso. Refatora\u00e7\u00e3o \u00e9 uma das etapas essenciais do ciclo TDD. (Cap\u00edtulo 2, Beck, 2002)</p> <p>Refer\u00eancia: Beck, K. (2002). Test-Driven Development: By Example. Addison-Wesley. Aniche, Maur\u00edcio. Effective Software Testing: A Developer's Guide. Manning, 26 de abril de 2022. ISBN\u201110: 1633439933; ISBN\u201113: 978\u20111633439931.</p>"},{"location":"tpi_tpe/tpi4_tpe4/#q12-quando-o-tdd-e-mais-vantajoso","title":"Q12. Quando o TDD \u00e9 mais vantajoso?","text":"<ul> <li>a. Em problemas simples.</li> <li>b. Em qualquer tipo de problema.</li> <li>c. Em projetos de manuten\u00e7\u00e3o.</li> <li>d. Em problemas mais complicados, onde ajuda a estruturar melhor o desenvolvimento.</li> </ul> <p>RESPOSTA: d. Em problemas mais complicados, onde ajuda a estruturar melhor o desenvolvimento.</p> <p>Eu uso TDD quando n\u00e3o tenho uma ideia clara de como projetar, arquitetar ou implementar um requisito espec\u00edfico. Nesses casos, gosto de ir devagar e usar meus testes para experimentar diferentes possibilidades. Se estou trabalhando em um problema que conhe\u00e7o bem e j\u00e1 sei a melhor forma de resolv\u00ea-lo, n\u00e3o me importo em pular alguns ciclos.</p> <p>(Tradu\u00e7\u00e3o Livre de Aniche, 2022, Cap. 8)</p> <p>I use TDD when I don\u2019t have a clear idea of how to design, architect, or implement a specific requirement. In such cases, I like to go slowly and use my tests to experiment with different possibilities. If I am working on a problem I know well, and I already know the best way to solve the problem, I do not mind skipping a few cycles.</p> <p>(Aniche, 2022, Cap. 8)</p> <p>Eu uso TDD quando estou lidando com um problema complexo ou com um problema para o qual n\u00e3o tenho expertise suficiente para resolver. Sempre que enfrento uma implementa\u00e7\u00e3o desafiadora, o TDD me ajuda a dar um passo atr\u00e1s e aprender sobre os requisitos \u00e0 medida que avan\u00e7o, escrevendo testes bem pequenos.</p> <p>(Tradu\u00e7\u00e3o Livre de Aniche, 2022, Cap. 8)</p> <p>I use TDD when dealing with a complex problem or a problem I lack the expertise to solve. Whenever I face a challenging implementation, TDD helps me take a step back and learn about the requirements as I go by writing very small tests.</p> <p>(Aniche, 2022, Cap. 8)</p> <p>Desenvolvedores enfrentam desafios complexos de programa\u00e7\u00e3o todos os dias, e muitas vezes n\u00e3o est\u00e3o preparados para determinar a melhor solu\u00e7\u00e3o. Com frequ\u00eancia, tais projetos dif\u00edceis geram muito estresse e c\u00f3digo ruim. Para obter a for\u00e7a e a coragem necess\u00e1rias para superar tarefas aparentemente herc\u00faleas, os programadores devem recorrer ao desenvolvimento orientado por testes (TDD), um conjunto comprovado de t\u00e9cnicas que encorajam designs simples e test suites que inspiram confian\u00e7a. (Introdu\u00e7\u00e3o, Beck, 2002)</p> <p>Ao conduzir o desenvolvimento com testes automatizados e depois eliminar duplica\u00e7\u00e3o, qualquer desenvolvedor pode escrever c\u00f3digo confi\u00e1vel e livre de erros, independentemente do n\u00edvel de complexidade. (Introdu\u00e7\u00e3o, Beck, 2002)</p> <p>Os leitores aprender\u00e3o a:</p> <ul> <li>Resolver tarefas complicadas, come\u00e7ando pelas simples e seguindo para as mais complexas.</li> <li>Escrever testes automatizados antes de codificar.</li> <li>Criar testes para l\u00f3gica complicada, incluindo reflex\u00e3o e exce\u00e7\u00f5es. (Introdu\u00e7\u00e3o, Beck, 2002)</li> </ul> <p>Refer\u00eancia: Beck, K. (2002). Test-Driven Development: By Example. Addison-Wesley. Aniche, Maur\u00edcio. Effective Software Testing: A Developer's Guide. Manning, 26 de abril de 2022. ISBN\u201110: 1633439933; ISBN\u201113: 978\u20111633439931.</p>"},{"location":"tpi_tpe/tpi4_tpe4/#q13-em-quais-situacoes-o-uso-do-tdd-nao-e-recomendado","title":"Q13. Em quais situa\u00e7\u00f5es o uso do TDD n\u00e3o \u00e9 recomendado?","text":"<ul> <li>a. Quando o problema \u00e9 bem conhecido e n\u00e3o h\u00e1 necessidade de experimenta\u00e7\u00e3o.</li> <li>b. Quando se est\u00e1 em projetos \u00e1geis.</li> <li>c. Em sistemas embarcados.</li> <li>d. Quando a pir\u00e2mide de testes n\u00e3o \u00e9 aplicada.</li> </ul> <p>RESPOSTA: a. Quando o problema \u00e9 bem conhecido e n\u00e3o h\u00e1 necessidade de experimenta\u00e7\u00e3o.</p> <p>Eu n\u00e3o uso TDD quando n\u00e3o h\u00e1 nada a ser aprendido no processo. Se eu j\u00e1 conhe\u00e7o o problema e sei a melhor forma de resolv\u00ea-lo, fico \u00e0 vontade para codificar a solu\u00e7\u00e3o diretamente. (Mesmo que eu n\u00e3o use TDD, sempre escrevo os testes prontamente. Nunca deixo para o final do dia ou para o fim da sprint. Eu escrevo o c\u00f3digo de produ\u00e7\u00e3o e, em seguida, escrevo o c\u00f3digo de teste. E, se tiver dificuldades, dou um passo atr\u00e1s e desacelero.)</p> <p>(Tradu\u00e7\u00e3o Livre de Aniche, 2022, Cap. 8)</p> <p>I do not use TDD when there is nothing to be learned in the process. If I already know the problem and how to best solve it, I am comfortable coding the solution directly. (Even if I do not use TDD, I always write tests promptly. I never leave it until the end of the day or the end of the sprint. I code the production code, and then I code the test code. And if I have trouble, I take a step back and slow down.)</p> <p>(Aniche, 2022, Cap. 8)</p> <p>O desenvolvimento orientado a testes (TDD) \u00e9 especialmente \u00fatil em situa\u00e7\u00f5es em que n\u00e3o temos certeza de como estruturar a solu\u00e7\u00e3o ou estamos lidando com um problema desconhecido. (Cap\u00edtulo 2, Beck, 2002)</p> <p>Em contrapartida, quando j\u00e1 sabemos exatamente o que fazer e a estrutura do sistema est\u00e1 clara, o valor de escrever testes antes do c\u00f3digo \u00e9 reduzido. (Cap\u00edtulo 2, Beck, 2002)</p> <p>Em projetos onde \u00e9 necess\u00e1rio explorar o design, o ciclo de TDD ajuda a conduzir decis\u00f5es incrementais e iterativas. (Cap\u00edtulo 2, Beck, 2002)</p>"},{"location":"tpi_tpe/tpi4_tpe4/#por-que-as-outras-alternativas-estao-erradas_11","title":"Por que as outras alternativas est\u00e3o erradas","text":"<ul> <li>b. Quando se est\u00e1 em projetos \u00e1geis.</li> </ul> <p>TDD \u00e9 altamente recomendado em projetos \u00e1geis, pois favorece ciclos curtos de feedback e adapta\u00e7\u00e3o cont\u00ednua. (Cap\u00edtulo 1, Beck, 2002)</p> <ul> <li> <p>c. Em sistemas embarcados.</p> </li> <li> <p>d. Quando a pir\u00e2mide de testes n\u00e3o \u00e9 aplicada.</p> </li> </ul> <p>A pir\u00e2mide de testes \u00e9 uma pr\u00e1tica auxiliar, n\u00e3o uma condi\u00e7\u00e3o para aplicar TDD. O TDD foca na escrita de testes automatizados de unidade, independentemente da estrutura completa de testes adotada.</p> <p>Refer\u00eancia: Beck, K. (2002). Test-Driven Development: By Example. Addison-Wesley. Aniche, Maur\u00edcio. Effective Software Testing: A Developer's Guide. Manning, 26 de abril de 2022. ISBN\u201110: 1633439933; ISBN\u201113: 978\u20111633439931.</p>"},{"location":"tpi_tpe/tpi4_tpe4/#q14-qual-a-eficacia-dos-testes-em-tdd","title":"Q14. Qual a efic\u00e1cia dos testes em TDD?","text":"<ul> <li>a. As su\u00edtes de TDD s\u00e3o superiores \u00e0s su\u00edtes sistem\u00e1ticas em v\u00e1rios aspectos.</li> <li>b. As su\u00edtes s\u00e3o equivalentes.</li> <li>c. S\u00e3o inferiores apenas em projetos pequenos.</li> <li>d. TDD foca em desenvolvimento e n\u00e3o gera testes eficazes.</li> </ul> <p>RESPOSTA: a. As su\u00edtes de TDD s\u00e3o superiores \u00e0s su\u00edtes sistem\u00e1ticas em v\u00e1rios aspectos.</p> <p>TDD \u00e9 uma parte t\u00e3o significativa do desenvolvimento de software que n\u00e3o \u00e9 surpresa que pesquisadores tentem avaliar sua efetividade usando m\u00e9todos cient\u00edficos. Como muitas pessoas o tratam como uma bala de prata, acredito fortemente que voc\u00ea deve conhecer o que os profissionais pensam, o que eu penso e o que a pesquisa atualmente sabe sobre o assunto.</p> <p>Pesquisas mostraram diversas situa\u00e7\u00f5es em que o TDD pode melhorar o design de classes:</p> <p>Janzen (2005) mostrou que praticantes de TDD, em compara\u00e7\u00e3o com desenvolvedores que n\u00e3o usam TDD, produziram algoritmos menos complexos e su\u00edtes de testes com maior cobertura.</p> <p>Janzen e Saiedian (2006) demonstraram que o c\u00f3digo produzido com TDD fazia melhor uso de conceitos de orienta\u00e7\u00e3o a objetos, com responsabilidades melhor distribu\u00eddas entre diferentes classes. Em contraste, outras equipes produziram c\u00f3digo mais procedural.</p> <p>George e Williams (2003) mostraram que, embora o TDD possa inicialmente reduzir a produtividade de desenvolvedores inexperientes, 92% dos desenvolvedores em uma an\u00e1lise qualitativa acreditavam que o TDD ajudava a melhorar a qualidade do c\u00f3digo.</p> <p>Dog\u0161a e Bati\u010d (2011) tamb\u00e9m encontraram uma melhoria no design das classes ao se utilizar TDD. Segundo os autores, essa melhoria resultava da simplicidade que o TDD adiciona ao processo.</p> <p>Erdogmus et al. (2005) realizaram um experimento com 24 estudantes de gradua\u00e7\u00e3o e mostraram que o TDD aumentou a produtividade deles, mas n\u00e3o alterou a qualidade do c\u00f3digo produzido.</p> <p>Nagappan e colegas (2008) realizaram tr\u00eas estudos de caso na Microsoft e mostraram que a densidade de defeitos antes do lan\u00e7amento em projetos que usaram TDD caiu entre 40% e 90% em compara\u00e7\u00e3o com projetos que n\u00e3o utilizaram TDD.</p> <p>(Tradu\u00e7\u00e3o Livre de Aniche, 2022, Cap. 8)</p> <p>TDD is such a significant part of software development that it is no wonder researchers try to assess its effectiveness using scientific methods. Because so many people treat it as a silver bullet, I strongly believe that you should know what practitioners think, what I think, and what research currently knows about the subject.</p> <p>Research has shown several situations in which TDD can improve class design:</p> <p>Janzen (2005) showed that TDD practitioners, compared to non-TDDers, produced less-complex algorithms and test suites that covered more.</p> <p>Janzen and Saiedian (2006) showed that the code produced using TDD made better use of object-oriented concepts, and responsibilities were better distributed into different classes. In contrast, other teams produced more procedural code.</p> <p>George and Williams (2003) showed that although TDD can initially reduce the productivity of inexperienced developers, 92% of the developers in a qualitative analysis thought that TDD helped improve code quality.</p> <p>Dog\u0161a and Batic\u02c7 (2011) also found an improvement in class design when using TDD. According to the authors, the improvement resulted from the simplicity TDD adds to the process.</p> <p>Erdogmus et al. (2005) used an experiment with 24 undergraduate students to show that TDD increased their productivity but did not change the quality of the produced code.</p> <p>Nagappan and colleagues (2008) performed three case studies at Microsoft and showed that the pre-release defect density of projects that were TDD\u2019d decreased 40 to 90% in comparison to projects that did not do TDD.</p> <p>(Aniche, 2022, Cap. 8)</p> <p>O TDD \u00e9 uma das pr\u00e1ticas centrais dos m\u00e9todos \u00e1geis, como o XP. Seu uso de testes automatizados se concentra mais na especifica\u00e7\u00e3o do comportamento do software ainda n\u00e3o escrito do que em testes de regress\u00e3o. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 33)</p> <p>A efic\u00e1cia do TDD vem da forma como ele nos permite separar o pensamento sobre o software em duas fases: o que ele deve fazer, e como ele deve fazer. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 33)</p> <p>Quando implementamos a funcionalidade de forma incremental, podemos ver cada teste passar, um por um, \u00e0 medida que escrevemos mais c\u00f3digo. \u00c9 aqui que reside o verdadeiro valor dos testes automatizados: na sua capacidade de fixar o comportamento esperado, garantindo que mudan\u00e7as posteriores n\u00e3o o modifiquem acidentalmente. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 33)</p> <p>O TDD permite a cria\u00e7\u00e3o de especifica\u00e7\u00f5es execut\u00e1veis, que n\u00e3o apenas guiam o design como tamb\u00e9m servem de documenta\u00e7\u00e3o viva e confi\u00e1vel do sistema. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 33)</p>"},{"location":"tpi_tpe/tpi4_tpe4/#por-que-as-outras-alternativas-estao-erradas_12","title":"Por que as outras alternativas est\u00e3o erradas","text":"<ul> <li>b. As su\u00edtes s\u00e3o equivalentes.</li> </ul> <p>O livro indica explicitamente que os testes em TDD t\u00eam papel mais amplo e profundo, tanto em design quanto em valida\u00e7\u00e3o \u2014 n\u00e3o sendo \"equivalentes\", mas sim mais eficazes em v\u00e1rios aspectos. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 33)</p> <ul> <li> <p>c. S\u00e3o inferiores apenas em projetos pequenos.</p> </li> <li> <p>d. TDD foca em desenvolvimento e n\u00e3o gera testes eficazes.</p> </li> </ul> <p>TDD produz testes eficazes, que funcionam como especifica\u00e7\u00f5es automatizadas e garantem confiabilidade cont\u00ednua do sistema. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 33)</p> <p>Refer\u00eancia: Meszaros, G. (2007). xUnit Test Patterns: Refactoring Test Code. Addison-Wesley. Aniche, Maur\u00edcio. Effective Software Testing: A Developer's Guide. Manning, 26 de abril de 2022. ISBN\u201110: 1633439933; ISBN\u201113: 978\u20111633439931.</p>"},{"location":"tpi_tpe/tpi5_tpe5/","title":"Universidade de Bras\u00edlia - Faculdade Gama","text":""},{"location":"tpi_tpe/tpi5_tpe5/#engenharia-de-software","title":"Engenharia de Software","text":"<p>Professora: Elaine Venson Email: elainevenson@unb.br</p>"},{"location":"tpi_tpe/tpi5_tpe5/#seguranca-de-software-e-desenvolvimento-de-software-seguro","title":"Seguran\u00e7a de Software e Desenvolvimento de Software Seguro","text":""},{"location":"tpi_tpe/tpi5_tpe5/#agenda","title":"Agenda","text":"<ul> <li>O problema da Seguran\u00e7a de Software</li> <li>Defini\u00e7\u00f5es</li> <li>Seguran\u00e7a cibern\u00e9tica, seguran\u00e7a de aplica\u00e7\u00f5es, seguran\u00e7a de software</li> <li>Seguran\u00e7a de Software</li> <li>Vulnerabilidades</li> <li>T\u00e9cnicas de preven\u00e7\u00e3o, detec\u00e7\u00e3o e mitiga\u00e7\u00e3o</li> <li>Desenvolvimento de Software Seguro</li> <li>Modelos de ciclo de vida</li> <li>Teste de Seguran\u00e7a</li> <li>DevSecOps</li> </ul>"},{"location":"tpi_tpe/tpi5_tpe5/#referencias-de-videos","title":"Refer\u00eancias de v\u00eddeos","text":"<ul> <li>Hackers desligam carro na rodovia \u2013 com o motorista dentro</li> </ul>"},{"location":"tpi_tpe/tpi5_tpe5/#o-problema-da-seguranca-de-software","title":"O Problema da Seguran\u00e7a de Software","text":"<ul> <li>Vulnerabilidades continuam crescendo</li> <li>O foco de seguran\u00e7a ainda se concentra no fim do ciclo de desenvolvimento</li> <li>Software \u00e9 elemento central na seguran\u00e7a cibern\u00e9tica</li> <li>Defeitos de software t\u00eam impactos diretos na seguran\u00e7a</li> <li>Hackers exploram esses defeitos para invadir sistemas</li> <li>Seguran\u00e7a deve ser incorporada ao longo do ciclo de vida, e n\u00e3o apenas ao final</li> <li>Construir software seguro desde o in\u00edcio \u00e9 melhor que tentar remediar vulnerabilidades depois</li> </ul>"},{"location":"tpi_tpe/tpi5_tpe5/#por-que-o-problema-esta-aumentando","title":"Por que o problema est\u00e1 aumentando?","text":"<ul> <li> <p>Conectividade </p> </li> <li> <p>Extensibilidade </p> </li> <li> <p>Complexidade </p> </li> </ul>"},{"location":"tpi_tpe/tpi5_tpe5/#origem-das-vulnerabilidades","title":"Origem das Vulnerabilidades","text":"<ul> <li> <p>Baseado no US National Vulnerabilities DB (NVD)</p> </li> <li> <p>Mais de 85 mil vulnerabilidades reportadas publicamente</p> </li> <li>93% dos buffer errors envolveram erro simples (verifica\u00e7\u00e3o de limites de arrays)</li> <li> <p>Fonte: Kuhn, M. Raunak, and R. Kacker, IT Professional, 2017</p> </li> <li> <p>Refer\u00eancia adicional: Rashid et al., The Cyber Security Body of Knowledge, 2019</p> </li> </ul>"},{"location":"tpi_tpe/tpi5_tpe5/#definicoes","title":"Defini\u00e7\u00f5es","text":"<ul> <li>Seguran\u00e7a Cibern\u00e9tica (Cybersecurity):   Prote\u00e7\u00e3o de sistemas de computa\u00e7\u00e3o, redes, hardware, software e dados contra roubo, danos ou mau uso.</li> </ul> <p>Schatz, Daniel; Bashroush, Rabih; Wall, Julie (2017)</p> <ul> <li>Seguran\u00e7a de Software:   Desenvolver software que continue funcionando mesmo sob ataque</li> </ul> <p>McGraw, 2004</p>"},{"location":"tpi_tpe/tpi5_tpe5/#objetivos-de-seguranca-de-software","title":"Objetivos de Seguran\u00e7a de Software","text":"<ul> <li>Confidencialidade</li> <li>Integridade</li> <li>Disponibilidade</li> </ul> <p>Vulnerabilidades s\u00e3o falhas de seguran\u00e7a que impedem o sistema de atingir esses objetivos.</p>"},{"location":"tpi_tpe/tpi5_tpe5/#vulnerabilidades","title":"Vulnerabilidades","text":"<ul> <li> <p>CVE (Common Vulnerabilities and Exposures)</p> </li> <li> <p>Lista p\u00fablica de vulnerabilidades</p> </li> <li> <p>https://cve.mitre.org</p> </li> <li> <p>CWE (Common Weakness Enumeration)</p> </li> <li> <p>Cataloga\u00e7\u00e3o de fraquezas de software</p> </li> <li> <p>https://cwe.mitre.org</p> </li> <li> <p>OWASP Top Ten</p> </li> <li> <p>Principais amea\u00e7as de seguran\u00e7a para aplica\u00e7\u00f5es web</p> </li> <li>https://owasp.org/Top10/</li> </ul> <p>### OWASP Top Ten (2021)</p> <ul> <li>A01 - Controle de Acesso Quebrado</li> <li>A02 - Falhas Criptogr\u00e1ficas</li> <li>A03 - Inje\u00e7\u00e3o</li> <li>A04 - Design Inseguro</li> <li>A05 - Configura\u00e7\u00e3o de Seguran\u00e7a Incorreta</li> <li>A06 - Componentes Vulner\u00e1veis e Desatualizados</li> <li>A07 - Falhas de Identifica\u00e7\u00e3o e Autentica\u00e7\u00e3o</li> <li>A08 - Falhas de Integridade de Software e Dados</li> <li>A09 - Falhas de Registro e Monitoramento de Seguran\u00e7a</li> <li>A10 - SSRF (Server-Side Request Forgery)</li> </ul>"},{"location":"tpi_tpe/tpi5_tpe5/#owasp-asvs","title":"OWASP ASVS","text":"<ul> <li> <p>OWASP Application Security Verification Standard (ASVS):   Padr\u00e3o aberto para valida\u00e7\u00e3o da seguran\u00e7a de aplica\u00e7\u00f5es web</p> </li> <li> <p>https://owasp.org/www-project-application-security-verification-standard/</p> </li> </ul>"},{"location":"tpi_tpe/tpi5_tpe5/#categorias-de-vulnerabilidades","title":"Categorias de Vulnerabilidades","text":"<ul> <li>Gerenciamento de mem\u00f3ria: buffer overflow, dangling pointers</li> <li>Gera\u00e7\u00e3o de sa\u00edda estruturada: SQL Injection, Command Injection, XSS</li> <li>Race conditions</li> <li>APIs vulner\u00e1veis</li> <li>Side-channel (tempo de execu\u00e7\u00e3o, consumo de energia, etc.)</li> </ul>"},{"location":"tpi_tpe/tpi5_tpe5/#exemplos","title":"Exemplos","text":""},{"location":"tpi_tpe/tpi5_tpe5/#buffer-overflow","title":"Buffer Overflow","text":"<pre><code>char buff[15];\nint pass = 0;\nprintf(\"\\n Enter the password \\n\");\ngets(buff);\nif(strcmp(buff, \"thegeekstuff\")) {\n    printf (\"\\n Wrong Password \\n\");\n} else {\n    printf (\"\\n Correct Password \\n\");\n    pass = 1;\n}\nif(pass) {\n    printf (\"\\n Root privileges given to the user\\n\");\n}\n</code></pre> <p>Fonte: The Geek Stuff</p>"},{"location":"tpi_tpe/tpi5_tpe5/#sql-injection","title":"SQL Injection","text":"<pre><code>SELECT * FROM Students WHERE name = '$name'\n</code></pre> <p>entrada do atacante:</p> <pre><code>Alice'; DROP TABLE Students; --\n</code></pre>"},{"location":"tpi_tpe/tpi5_tpe5/#contramedidas","title":"Contramedidas","text":"<ul> <li> <p>Preven\u00e7\u00e3o</p> </li> <li> <p>Linguagens seguras</p> </li> <li> <p>Padr\u00f5es de codifica\u00e7\u00e3o</p> </li> <li> <p>Detec\u00e7\u00e3o</p> </li> <li> <p>Revis\u00f5es de c\u00f3digo</p> </li> <li>Testes de penetra\u00e7\u00e3o</li> <li> <p>An\u00e1lise est\u00e1tica</p> </li> <li> <p>Mitiga\u00e7\u00e3o</p> </li> <li> <p>Monitoramento</p> </li> <li>Diversidade de software</li> </ul>"},{"location":"tpi_tpe/tpi5_tpe5/#desenvolvimento-de-software-seguro","title":"Desenvolvimento de Software Seguro","text":"<ul> <li> <p>Deve envolver:</p> </li> <li> <p>Requisitos de seguran\u00e7a</p> </li> <li>Revis\u00f5es de arquitetura</li> <li>Revis\u00f5es de c\u00f3digo</li> <li>Testes orientados a riscos</li> <li>Auditorias</li> <li> <p>An\u00e1lises est\u00e1ticas e din\u00e2micas</p> </li> <li> <p>Engenharia de Software Seguro reduz custos e incidentes</p> </li> </ul>"},{"location":"tpi_tpe/tpi5_tpe5/#microsoft-sdl","title":"Microsoft SDL","text":"<ol> <li>Definir padr\u00f5es de seguran\u00e7a</li> <li>Usar recursos e frameworks seguros</li> <li>Analisar arquitetura e amea\u00e7as</li> <li>Definir padr\u00f5es criptogr\u00e1ficos</li> <li>Proteger cadeia de suprimentos</li> <li>Garantir ambiente seguro</li> <li>Testar seguran\u00e7a</li> <li>Proteger plataforma operacional</li> <li>Monitorar e responder</li> <li>Treinamento de seguran\u00e7a</li> </ol> <p>Microsoft SDL</p>"},{"location":"tpi_tpe/tpi5_tpe5/#sdl-testes-de-seguranca","title":"SDL - Testes de Seguran\u00e7a","text":"<ul> <li>SAST (an\u00e1lise est\u00e1tica)</li> <li>DAST (an\u00e1lise din\u00e2mica)</li> <li>Red/Blue Team</li> <li>Pen tests</li> <li>Bug bounty</li> <li>Testes peri\u00f3dicos</li> </ul>"},{"location":"tpi_tpe/tpi5_tpe5/#safecode-8-praticas","title":"SAFECode - 8 Pr\u00e1ticas","text":"<ol> <li>Defini\u00e7\u00e3o de controles</li> <li>Design seguro</li> <li>Codifica\u00e7\u00e3o segura</li> <li>Gerenciar riscos de terceiros</li> <li>Testes e valida\u00e7\u00f5es</li> <li>Gerenciar findings</li> <li>Resposta a vulnerabilidades</li> <li>Planejar implementa\u00e7\u00e3o segura</li> </ol>"},{"location":"tpi_tpe/tpi5_tpe5/#estrategia-de-testes","title":"Estrat\u00e9gia de Testes","text":"<ul> <li>SAST</li> <li>DAST</li> <li>SCA (an\u00e1lise de composi\u00e7\u00e3o)</li> <li>RASP (prote\u00e7\u00e3o em tempo de execu\u00e7\u00e3o)</li> </ul>"},{"location":"tpi_tpe/tpi5_tpe5/#testes-de-seguranca","title":"Testes de Seguran\u00e7a","text":"<ul> <li>SMPT: testes manuais sistem\u00e1ticos</li> <li>EMPT: testes manuais explorat\u00f3rios</li> <li>DAST: testes din\u00e2micos</li> <li>SAST: testes est\u00e1ticos</li> </ul> <p>Exemplo de ferramenta:</p> <ul> <li>DAST: OWASP ZAP</li> <li>SAST: SonarQube</li> </ul>"},{"location":"tpi_tpe/tpi5_tpe5/#devsecops","title":"DevSecOps","text":"<ul> <li>CSA DevSecOps Automation</li> </ul>"},{"location":"tpi_tpe/tpi5_tpe5/#pilares-do-devsecops","title":"Pilares do DevSecOps","text":"<ol> <li>Responsabilidade coletiva</li> <li>Colabora\u00e7\u00e3o e integra\u00e7\u00e3o</li> <li>Implementa\u00e7\u00e3o pragm\u00e1tica</li> <li>Conformidade e desenvolvimento</li> <li>Automa\u00e7\u00e3o</li> <li>Medir, monitorar, relatar e agir</li> </ol>"},{"location":"tpi_tpe/tpi5_tpe5/#referencias","title":"Refer\u00eancias","text":"<ul> <li>Cifuentes et al. (2023)</li> <li>McGraw (2006)</li> <li>Microsoft SDL</li> <li>Mohan (2022)</li> <li>Rashid et al. (2019)</li> <li>BSIMM (2019)</li> <li>SAFECode (2018)</li> <li>Elder et al. (2022)</li> <li>Cloud Security Alliance DevSecOps</li> </ul> <p>Claro, aqui est\u00e1 a sa\u00edda anterior formatada em Markdown (<code>.md</code>).</p>"},{"location":"tpi_tpe/tpi5_tpe5/#perguntas-e-respostas-sobre-the-six-pillars-of-devsecops-automation","title":"Perguntas e Respostas sobre \"The Six Pillars of DevSecOps: Automation\"","text":""},{"location":"tpi_tpe/tpi5_tpe5/#pergunta-1","title":"Pergunta 1","text":"<p>P: De acordo com a introdu\u00e7\u00e3o do texto, por que a automa\u00e7\u00e3o \u00e9 considerada um componente cr\u00edtico do DevSecOps?</p> <ul> <li>(A) Porque ela substitui completamente a necessidade de equipes de seguran\u00e7a, automatizando todas as suas fun\u00e7\u00f5es e integrando-as aos desenvolvedores.</li> <li>(B) Porque seu foco principal \u00e9 acelerar a velocidade de entrega, mesmo que isso signifique aceitar um n\u00edvel de risco de seguran\u00e7a mais elevado.</li> <li>(C) Porque ela permite a efici\u00eancia do processo, fazendo com que as equipes se concentrem em entregar valor em vez de repetir esfor\u00e7os manuais e erros.</li> <li>(D) Porque ela implementa um framework para execu\u00e7\u00e3o manual de controles de seguran\u00e7a, garantindo que a supervis\u00e3o humana ocorra em todas as etapas do pipeline.</li> <li>(E) Porque ela garante que 100% das vulnerabilidades sejam identificadas e corrigidas durante a fase de design, eliminando a necessidade de testes posteriores.</li> </ul> <p>Resposta Correta: (C)</p> <p>Justificativa: O texto afirma claramente que o valor da automa\u00e7\u00e3o est\u00e1 na efici\u00eancia e na redu\u00e7\u00e3o de trabalho repetitivo, permitindo que as equipes foquem em atividades de maior valor.</p> <p>Trecho do livro: \"Automation is a critical component of DevSecOps because it enables process efficiency, allowing developers, infrastructure, and information security teams to focus on delivering value rather than repeating manual efforts and errors with complex deliverables.\"</p> <p>Tradu\u00e7\u00e3o: \"A automa\u00e7\u00e3o \u00e9 um componente cr\u00edtico do DevSecOps porque ela permite a efici\u00eancia do processo, fazendo com que as equipes de desenvolvedores, infraestrutura e seguran\u00e7a da informa\u00e7\u00e3o se concentrem em entregar valor em vez de repetir esfor\u00e7os manuais e erros com entreg\u00e1veis complexos.\"</p>"},{"location":"tpi_tpe/tpi5_tpe5/#pergunta-2","title":"Pergunta 2","text":"<p>P: Com base nas defini\u00e7\u00f5es da se\u00e7\u00e3o 3, como o teste de seguran\u00e7a de aplica\u00e7\u00e3o est\u00e1tico (SAST) se difere fundamentalmente do teste de seguran\u00e7a de aplica\u00e7\u00e3o din\u00e2mico (DAST)?</p> <ul> <li>(A) O SAST analisa o c\u00f3digo-fonte est\u00e1tico da aplica\u00e7\u00e3o em busca de vulnerabilidades, enquanto o DAST analisa a aplica\u00e7\u00e3o enquanto ela est\u00e1 em execu\u00e7\u00e3o, com base em seu comportamento.</li> <li>(B) O SAST \u00e9 um teste de \"caixa-preta\" que n\u00e3o requer acesso ao c\u00f3digo, enquanto o DAST \u00e9 um teste de \"caixa-branca\" que analisa a estrutura interna.</li> <li>(C) O SAST \u00e9 utilizado exclusivamente para analisar componentes de terceiros e de c\u00f3digo aberto, enquanto o DAST foca apenas no c\u00f3digo desenvolvido internamente.</li> <li>(D) O SAST s\u00f3 pode ser executado em ambientes de produ\u00e7\u00e3o, enquanto o DAST \u00e9 projetado para ser usado no ambiente de desenvolvimento integrado (IDE) do programador.</li> <li>(E) O SAST \u00e9 sempre um processo de revis\u00e3o manual feito por humanos, enquanto o DAST se refere a qualquer tipo de ferramenta de teste automatizado.</li> </ul> <p>Resposta Correta: (A)</p> <p>Justificativa: O texto define SAST como a an\u00e1lise do c\u00f3digo-fonte e DAST como a an\u00e1lise de uma aplica\u00e7\u00e3o em execu\u00e7\u00e3o, o que corresponde exatamente \u00e0 alternativa.</p> <p>Trecho do livro (SAST): \"Security testing that analyzes application source code for software vulnerabilities and gaps against best practices\" Tradu\u00e7\u00e3o (SAST): \"Teste de seguran\u00e7a que analisa o c\u00f3digo-fonte da aplica\u00e7\u00e3o em busca de vulnerabilidades de software e lacunas em rela\u00e7\u00e3o \u00e0s melhores pr\u00e1ticas\"</p> <p>Trecho do livro (DAST): \"Security testing that analyzes a running application by exercising application functionality and detecting vulnerabilities based on application behavior and response\" Tradu\u00e7\u00e3o (DAST): \"Teste de seguran\u00e7a que analisa uma aplica\u00e7\u00e3o em execu\u00e7\u00e3o, exercitando a funcionalidade da aplica\u00e7\u00e3o e detectando vulnerabilidades com base no comportamento e na resposta da aplica\u00e7\u00e3o\"</p>"},{"location":"tpi_tpe/tpi5_tpe5/#pergunta-3","title":"Pergunta 3","text":"<p>P: Utilizando a tabela de exemplo da se\u00e7\u00e3o 5.3, como seria classificado o pipeline de uma mudan\u00e7a de risco baixo (1) em uma aplica\u00e7\u00e3o de risco alto (3) com um hist\u00f3rico de confiabilidade m\u00e9dio (2)?</p> <ul> <li>(A) Seria classificada na \"faixa vermelha\" (red lane), pois qualquer aplica\u00e7\u00e3o de risco alto exige o n\u00edvel m\u00e1ximo de rigor, independentemente dos outros fatores.</li> <li>(B) Seria classificada na \"faixa verde\" (green lane), pois a mudan\u00e7a em si tem um risco baixo, o que permite otimizar a entrega cont\u00ednua.</li> <li>(C) Seria classificada na \"faixa amarela\" (yellow lane), pois a pontua\u00e7\u00e3o total dos fatores de risco (1+3+2=6) est\u00e1 na faixa que exige mais escrut\u00ednio.</li> <li>(D) A classifica\u00e7\u00e3o n\u00e3o seria poss\u00edvel, pois a tabela de exemplo n\u00e3o contempla a combina\u00e7\u00e3o de um risco de mudan\u00e7a baixo com um risco de aplica\u00e7\u00e3o alto.</li> <li>(E) Seria classificada na \"faixa vermelha\" (red lane), pois o risco do hist\u00f3rico m\u00e9dio anula o risco baixo da mudan\u00e7a, elevando a pontua\u00e7\u00e3o total para 7.</li> </ul> <p>Resposta Correta: (C)</p> <p>Justificativa: O texto estabelece um sistema de pontua\u00e7\u00e3o onde um total de 5 ou mais classifica o pipeline como \"faixa amarela\", e 7 ou mais como \"faixa vermelha\". A soma dos fatores (1+3+2) resulta em 6.</p> <p>Trecho do livro: \"The numeric values of High (3), Medium (2), and Low (1) are used with a total score of 5 and above considered to be in a \u201cyellow lane,\u201d and 7 and above considered to be in the \u201cred lane.\u201d\" Tradu\u00e7\u00e3o: \"Os valores num\u00e9ricos de Alto (3), M\u00e9dio (2) e Baixo (1) s\u00e3o usados, com uma pontua\u00e7\u00e3o total de 5 ou mais sendo considerada uma \u201cfaixa amarela\u201d, e 7 ou mais sendo considerada uma \u201cfaixa vermelha\u201d.\"</p>"},{"location":"tpi_tpe/tpi5_tpe5/#pergunta-4","title":"Pergunta 4","text":"<p>P: De acordo com a se\u00e7\u00e3o 7.4, qual \u00e9 uma das principais vantagens de implementar loops de feedback cont\u00ednuos e r\u00e1pidos para as equipes de DevSecOps?</p> <ul> <li>(A) Elimina a necessidade de \"quebrar o build\", pois todos os problemas s\u00e3o automaticamente corrigidos antes de serem integrados ao c\u00f3digo principal.</li> <li>(B) Transfere a responsabilidade total pela corre\u00e7\u00e3o de bugs para a equipe de opera\u00e7\u00f5es, que \u00e9 a \u00fanica a receber os alertas de seguran\u00e7a.</li> <li>(C) Reduz a complexidade e o custo da remedia\u00e7\u00e3o de um defeito, permitindo que os desenvolvedores o corrijam rapidamente enquanto o contexto ainda est\u00e1 fresco em suas mentes.</li> <li>(D) Permite que a organiza\u00e7\u00e3o ignore permanentemente vulnerabilidades de baixa severidade, focando o feedback exclusivamente em problemas de alta criticidade.</li> <li>(E) Garante que os testes ass\u00edncronos (out-of-band) n\u00e3o sejam mais necess\u00e1rios, pois todos os tipos de verifica\u00e7\u00e3o de seguran\u00e7a podem ser feitos em tempo real.</li> </ul> <p>Resposta Correta: (C)</p> <p>Justificativa: O texto enfatiza que o feedback r\u00e1pido reduz o custo da corre\u00e7\u00e3o e capacita os desenvolvedores a agir de forma mais eficaz, pois o contexto da mudan\u00e7a ainda \u00e9 recente.</p> <p>Trecho do livro: \"The longer a security defect exists in the application, the more likely further changes and deployment will add to the complexity and cost of remediating the defect. [...] timely feedback empowers individuals to diagnose and remediate changes that caused the vulnerability quickly, allowing them to perform root cause analysis while the accompanying context is still fresh in mind.\" Tradu\u00e7\u00e3o: \"Quanto mais tempo um defeito de seguran\u00e7a existe na aplica\u00e7\u00e3o, maior a probabilidade de que mudan\u00e7as e implanta\u00e7\u00f5es futuras aumentem a complexidade e o custo para remediar o defeito. [...] o feedback oportuno capacita os indiv\u00edduos a diagnosticar e remediar rapidamente as mudan\u00e7as que causaram a vulnerabilidade, permitindo-lhes realizar a an\u00e1lise de causa raiz enquanto o contexto associado ainda est\u00e1 fresco na mente.\"</p>"},{"location":"tpi_tpe/tpi5_tpe5/#pergunta-5","title":"Pergunta 5","text":"<p>P: O texto descreve o teste ass\u00edncrono (out-of-band) como uma pr\u00e1tica importante. Para quais duas categorias gerais de atividades ele \u00e9 recomendado?</p> <ul> <li>(A) Para todos os testes de unidade e integra\u00e7\u00e3o, que devem rodar fora do pipeline principal para n\u00e3o atrasar os desenvolvedores.</li> <li>(B) Apenas para a verifica\u00e7\u00e3o de vulnerabilidades de baixa severidade e para a revis\u00e3o de c\u00f3digo por pares, que n\u00e3o s\u00e3o consideradas cr\u00edticas.</li> <li>(C) Exclusivamente para a varredura de cont\u00eaineres e a an\u00e1lise de componentes de software (SCA), pois essas atividades sempre requerem interven\u00e7\u00e3o manual.</li> <li>(D) Para atividades cruciais que exigem intelig\u00eancia humana (como pentest) e para testes automatizados muito demorados (como um SAST completo).</li> <li>(E) Para a gest\u00e3o de segredos (secrets management) e a configura\u00e7\u00e3o de firewalls de aplica\u00e7\u00e3o web (WAF), que s\u00e3o processos cont\u00ednuos e n\u00e3o pontuais.</li> </ul> <p>Resposta Correta: (D)</p> <p>Justificativa: A se\u00e7\u00e3o 7.3 divide explicitamente os testes ass\u00edncronos nessas duas categorias: os que precisam de intelig\u00eancia humana e os que s\u00e3o automatizados, mas muito longos para o pipeline principal.</p> <p>Trecho do livro: \"There are generally two categories of asynchronous testing: Certain crucial security activities cannot be fully automated as they require human intelligence. These include threat modeling, penetration testing, and peer code review. Heavyweight automated tests that take a long time to perform, such as SAST.\" Tradu\u00e7\u00e3o: \"Geralmente, existem duas categorias de testes ass\u00edncronos: certas atividades de seguran\u00e7a cruciais n\u00e3o podem ser totalmente automatizadas, pois exigem intelig\u00eancia humana. Estas incluem modelagem de amea\u00e7as, testes de penetra\u00e7\u00e3o e revis\u00e3o de c\u00f3digo por pares. Testes automatizados pesados que levam muito tempo para serem executados, como o SAST.\"</p>"}]}