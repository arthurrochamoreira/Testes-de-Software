{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"aae3/aae3/","title":"1. Relat\u00f3rio de Cobertura MC/DC \u2014 Atividade AAE-3","text":""},{"location":"aae3/aae3/#11-objetivo","title":"1.1 Objetivo","text":"<p>Elaborar o menor conjunto de casos de teste que garanta 100% de cobertura segundo o crit\u00e9rio MC/DC para o m\u00e9todo <code>isNumber(String number)</code> abaixo:</p> <pre><code>public boolean isNumber(String number) {\n    if (number == null || number.isEmpty()) {\n        return false;\n    }\n\n    if (number.length() == 1 &amp;&amp; (number.charAt(0) == '-' || number.charAt(0) == '+')) {\n        return false;\n    }\n\n    for (int i = 0; i &lt; number.length(); i++) {\n        char c = number.charAt(i);\n\n        if (i == 0 &amp;&amp; (c == '-' || c == '+')) {\n            continue;\n        } else if (!Character.isDigit(c)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n</code></pre>"},{"location":"aae3/aae3/#12-recapitulando-o-que-e-mcdc","title":"1.2 Recapitulando o que \u00e9 MC/DC?","text":"<p>MC/DC significa Cobertura de Decis\u00e3o/Condi\u00e7\u00e3o Modificada. \u00c9 uma t\u00e9cnica de teste que garante que:</p> <ol> <li>Cada condi\u00e7\u00e3o booleana dentro de uma decis\u00e3o l\u00f3gica (<code>if</code>, <code>while</code>, etc.) seja avaliada como verdadeira e falsa.</li> <li>Cada condi\u00e7\u00e3o seja respons\u00e1vel, sozinha, por mudar o resultado final da decis\u00e3o.</li> </ol>"},{"location":"aae3/aae3/#13-etapas-para-resolver-o-exercicio","title":"1.3 Etapas para resolver o exerc\u00edcio","text":""},{"location":"aae3/aae3/#131-quebrar-as-condicoes","title":"1.3.1 Quebrar as condi\u00e7\u00f5es","text":"<p>Vamos identificar as decis\u00f5es do c\u00f3digo (as instru\u00e7\u00f5es <code>if</code>) e decompor cada uma em suas condi\u00e7\u00f5es.</p>"},{"location":"aae3/aae3/#2-primeira-decisao-linha-2","title":"2. Primeira decis\u00e3o (linha 2)","text":"<pre><code>if (number == null || number.isEmpty())\n</code></pre>"},{"location":"aae3/aae3/#21-quebrando-a-expressao","title":"2.1 Quebrando a express\u00e3o","text":"<ul> <li>C1: <code>number == null</code> \u2192 Verifica se a string \u00e9 nula</li> <li>C2: <code>number.isEmpty()</code> \u2192 Verifica se a string est\u00e1 vazia</li> </ul>"},{"location":"aae3/aae3/#estrutura-logica","title":"Estrutura l\u00f3gica:","text":"<pre><code>C1 || C2\n</code></pre> <p>Se a string for nula OU estiver vazia, retorna false</p>"},{"location":"aae3/aae3/#22-tabela-verdade-de-c1-c2","title":"2.2 Tabela Verdade de <code>C1 || C2</code>","text":"Teste C1 C2 Resultado T1 F F F T2 F V V T3 V F V T4 V V V"},{"location":"aae3/aae3/#23-justificativas-dos-pares-mcdc-primeira-decisao","title":"2.3 Justificativas dos Pares MC/DC - Primeira Decis\u00e3o","text":"<p>Par C1: T1 vs T3</p> <ul> <li>C2 est\u00e1 F nas duas linhas.  </li> <li>C1 muda de F \u2192 V.  </li> <li>Resultado muda de F \u2192 V.  </li> <li>Isso prova que C1 sozinha pode mudar o resultado \u2192 cobre independ\u00eancia de C1.</li> </ul> <p>Par C2: T1 vs T2</p> <ul> <li>C1 est\u00e1 F nas duas linhas.  </li> <li>C2 muda de F \u2192 V.  </li> <li>Resultado muda de F \u2192 V.  </li> <li>Isso prova que C2 sozinha pode mudar o resultado \u2192 cobre independ\u00eancia de C2.</li> </ul>"},{"location":"aae3/aae3/#24-pares-de-mcdc","title":"2.4 Pares de MC/DC","text":"<ul> <li>C1: T1 vs T3  </li> <li>C2: T1 vs T2</li> </ul>"},{"location":"aae3/aae3/#3-segunda-decisao-numberlength-1-numbercharat0-numbercharat0","title":"3. Segunda decis\u00e3o \u2014 <code>(number.length() == 1 &amp;&amp; (number.charAt(0) == '-' || number.charAt(0) == '+'))</code>","text":""},{"location":"aae3/aae3/#31-quebrando-a-expressao","title":"3.1 Quebrando a express\u00e3o","text":"<ul> <li>C3: <code>number.length() == 1</code> \u2192 A string tem apenas 1 caractere</li> <li>C4: <code>number.charAt(0) == '-'</code> \u2192 O caractere \u00e9 \u2018-\u2019 </li> <li>C5: <code>number.charAt(0) == '+'</code> \u2192 O caractere \u00e9 \u2018+\u2019</li> </ul>"},{"location":"aae3/aae3/#estrutura-logica_1","title":"Estrutura l\u00f3gica:","text":"<p>```java C3 &amp;&amp; (C4 || C5) ````</p> <p>Se a string tem 1 caractere E esse caractere \u00e9 '+' OU '-', retorna false</p>"},{"location":"aae3/aae3/#32-tabela-verdade-de-c3-c4-c5","title":"3.2 Tabela Verdade de 'C3 &amp;&amp; (C4 || C5)'","text":"Teste C3 (<code>len == 1</code>) C4 (<code>== '-'</code>) C5 (<code>== '+'</code>) Resultado T5 V V F V T6 V F V V T7 V F F F T8 F V F F"},{"location":"aae3/aae3/#33-justificativas-dos-pares-mcdc-segunda-decisao","title":"3.3 Justificativas dos Pares MC/DC - Segunda Decis\u00e3o","text":"<p>Par C3: T5 vs T8</p> <ul> <li>C4 = V e C5 = F nas duas linhas.</li> <li>C3 muda de V \u2192 F.</li> <li>Resultado muda de V \u2192 F.</li> <li>Isso prova que C3 sozinha pode mudar o resultado \u2192 cobre independ\u00eancia de C3.</li> </ul> <p>Par C4: T5 vs T7</p> <ul> <li>C3 = V e C5 = F nas duas linhas.</li> <li>C4 muda de V \u2192 F.</li> <li>Resultado muda de V \u2192 F.</li> <li>Isso prova que C4 sozinha pode mudar o resultado \u2192 cobre independ\u00eancia de C4.</li> </ul> <p>Par C5: T6 vs T7</p> <ul> <li>C3 = V e C4 = F nas duas linhas.</li> <li>C5 muda de V \u2192 F.</li> <li>Resultado muda de V \u2192 F.</li> <li>Isso prova que C5 sozinha pode mudar o resultado \u2192 cobre independ\u00eancia de C5.</li> </ul>"},{"location":"aae3/aae3/#34-pares-de-mcdc","title":"3.4 Pares de MC/DC","text":"<ul> <li>C3: T5 vs T8</li> <li>C4: T5 vs T7</li> <li>C5: T6 vs T7</li> </ul>"},{"location":"aae3/aae3/#4-o-que-voce-quer-alcancar-com-tudo-isso","title":"4. O que voc\u00ea quer alcan\u00e7ar com tudo isso?","text":"<p>Garantir que todas as condi\u00e7\u00f5es do c\u00f3digo s\u00e3o testadas de forma independente, provando que cada pedacinho da l\u00f3gica influencia o resultado final. Isso d\u00e1 seguran\u00e7a de que o c\u00f3digo est\u00e1 funcionando corretamente e que voc\u00ea n\u00e3o deixou passar nenhum caminho l\u00f3gico importante.</p>"},{"location":"aae3/aae3/#5-referencias-bibliograficas","title":"5. Refer\u00eancias Bibliogr\u00e1ficas","text":"<ol> <li>Myers, G. J., Sandler, C., &amp; Badgett, T. (2011). The Art of Software Testing (3rd ed.). Wiley. pp. 46\u201348.</li> </ol>"},{"location":"aae3/mc_dc/","title":"Modified Condition/Decision Coverage (MC/DC)","text":"<p>O Modified Condition/Decision Coverage (MC/DC) \u00e9 um dos crit\u00e9rios de cobertura estrutural mais exigentes para software de alta criticidade (avia\u00e7\u00e3o, automotivo, ferrovi\u00e1rio etc.). O MC/DC est\u00e1 definido no DO-178B/C da FAA e \u00e9 referenciado em normas como ISO\u00a026262 (Automotivo) e IEC\u00a061508 (Industrial). Uma apresenta\u00e7\u00e3o detalhada pode ser encontrada em Hayhurst et al. (2001).</p>"},{"location":"aae3/mc_dc/#1-definicao-formal","title":"1. Defini\u00e7\u00e3o Formal","text":"<p>De acordo com o DO-178C </p> <p>O MC/DC requer que, para cada decis\u00e3o (uma express\u00e3o booleana composta) no c\u00f3digo, sejam atendidos simultaneamente:</p> <ol> <li>Cada ponto de entrada e sa\u00edda seja invocado ao menos uma vez.</li> <li>A decis\u00e3o tome cada um de seus poss\u00edveis resultados (verdadeiro/falso).</li> <li>Cada condi\u00e7\u00e3o atinja cada valor (verdadeiro/falso) ao menos uma vez.</li> <li>Cada condi\u00e7\u00e3o seja mostrada como tendo influ\u00eancia independente sobre o resultado da decis\u00e3o, mudando-a quando somente ela for invertida, mantendo-se fixas todas as demais.</li> </ol> <p>O item 4 \u00e9 o que diferencia o MC/DC: deve-se provar que apenas invertendo uma condi\u00e7\u00e3o \u2014 sem alterar as demais \u2014 o resultado da decis\u00e3o tamb\u00e9m inverte.</p>"},{"location":"aae3/mc_dc/#2-exemplo-pratico","title":"2. Exemplo Pr\u00e1tico","text":"<p>Considere a decis\u00e3o:</p> <pre><code>D \u2261 A &amp;&amp; B &amp;&amp; C\n</code></pre> Caso A B C D = A\u2227B\u2227C 1 True True True True 2 True True False False 3 True False True False 4 True False False False 5 False True True False 6 False True False False 7 False False True False 8 False False False False <p>Para atingir 100\u202f% de MC/DC, al\u00e9m de cobrir as condi\u00e7\u00f5es e decis\u00f5es, precisamos demonstrar a independ\u00eancia de cada condi\u00e7\u00e3o.</p>"},{"location":"aae3/mc_dc/#21-independencia-de-a","title":"2.1. Independ\u00eancia de A","text":"<p>Mant\u00e9m B = True e C = True, varia apenas A:</p> Caso A B C D = A\u2227B\u2227C 1 True True True True 5 False True True False"},{"location":"aae3/mc_dc/#22-independencia-de-b","title":"2.2. Independ\u00eancia de B","text":"<p>Mant\u00e9m A = True e C = True, varia apenas B:</p> Caso A B C D = A\u2227B\u2227C 1 True True True True 3 True False True False"},{"location":"aae3/mc_dc/#23-independencia-de-c","title":"2.3. Independ\u00eancia de C","text":"<p>Mant\u00e9m A = True e B = True, varia apenas C:</p> Caso A B C D = A\u2227B\u2227C 1 True True True True 2 True True False False"},{"location":"aae3/mc_dc/#3-vantagens-e-aplicacoes","title":"3. Vantagens e Aplica\u00e7\u00f5es","text":"<ul> <li>Redu\u00e7\u00e3o de riscos: garante que cada condi\u00e7\u00e3o individualmente impacta o resultado, revelando erros mascarados.</li> <li>Requisito normativo: n\u00edvel A em avia\u00e7\u00e3o exige 100\u202f% MC/DC (DO-178C, Tabela A-7); tamb\u00e9m recomendado para SIL\u202f4 (IEC\u00a061508) e ASIL\u202fD (ISO\u00a026262).</li> <li>Efici\u00eancia: exige menos testes que a cobertura de todas as combina\u00e7\u00f5es (Multiple Condition Coverage), mantendo rigor.</li> </ul>"},{"location":"aae3/mc_dc/#4-referencias-bibliograficas","title":"4. Refer\u00eancias Bibliogr\u00e1ficas","text":"<ol> <li>Kelly\u00a0J. Hayhurst, Dan\u00a0S. Veerhusen, John\u00a0D. Chilenski e Leanna\u00a0R. Rierson. A Practical Tutorial on Modified Condition/Decision Coverage, NASA TM-2001-210876, 2001.</li> <li>FAA. Guidelines for the Use of the Modified Condition/Decision Coverage (MC/DC) Criterion, CAST-10, 2020.</li> <li>RTCA/DO-178C. Software Considerations in Airborne Systems and Equipment Certification, 2011.</li> <li>ISO\u00a026262:2011. Road vehicles \u2013 Functional safety, Parte\u00a06.</li> <li>IEC\u00a061508-3:2010. Functional safety of electrical/electronic/programmable electronic safety-related systems, Anexo\u00a0B.</li> <li>Myers, G. J., Sandler, C., &amp; Badgett, T. (2011). The Art of Software Testing (3rd ed.). Wiley. pp. 46\u201348.</li> </ol>"},{"location":"aae3/unit_test/","title":"Cap\u00edtulo 5 \u2013 Teste de M\u00f3dulo (Unidade)","text":""},{"location":"aae3/unit_test/#teste-de-modulo-unidade","title":"Teste de M\u00f3dulo (Unidade)","text":"<p>At\u00e9 este ponto, ignoramos amplamente a mec\u00e2nica dos testes e o tamanho do programa que est\u00e1 sendo testado. No entanto, como grandes programas (digamos, de 500 instru\u00e7\u00f5es ou mais de 50 classes) requerem tratamento especial de teste, neste cap\u00edtulo consideramos um passo inicial na estrutura\u00e7\u00e3o do teste de um grande programa: teste de m\u00f3dulo. Os cap\u00edtulos 6 e 7 enumeram as etapas restantes.</p> <p>Teste de m\u00f3dulo (ou teste de unidade) \u00e9 um processo de testar os subprogramas, sub-rotinas, classes ou procedimentos individuais em um programa. Mais especificamente, em vez de testar inicialmente o programa como um todo, o teste \u00e9 primeiro focado nos blocos de constru\u00e7\u00e3o menores do programa. As motiva\u00e7\u00f5es para fazer isso s\u00e3o tr\u00eas:</p> <ol> <li>Gerenciar os elementos combinados de teste, focando inicialmente em unidades menores do programa.  </li> <li>Facilitar a depura\u00e7\u00e3o (o processo de identificar e corrigir um erro descoberto), pois, quando um erro \u00e9 encontrado, sabe-se que ele existe em um m\u00f3dulo espec\u00edfico.  </li> <li>Introduzir paralelismo no processo de teste do programa, apresentando-nos a oportunidade de testar v\u00e1rios m\u00f3dulos simultaneamente.  </li> </ol> <p>O objetivo do teste de m\u00f3dulo \u00e9 comparar a fun\u00e7\u00e3o de um m\u00f3dulo com alguma especifica\u00e7\u00e3o funcional ou de interface que define o m\u00f3dulo. Para enfatizar novamente o objetivo de todos os processos de teste, o objetivo aqui n\u00e3o \u00e9 mostrar que o m\u00f3dulo atende \u00e0 sua especifica\u00e7\u00e3o, mas sim que o m\u00f3dulo contradiz a especifica\u00e7\u00e3o. </p> <p>Neste cap\u00edtulo, abordamos o teste de m\u00f3dulos de tr\u00eas pontos de vista:</p> <ol> <li>A maneira como os casos de teste s\u00e3o projetados.  </li> <li>A ordem em que os m\u00f3dulos devem ser testados e integrados.  </li> <li>Conselhos sobre a realiza\u00e7\u00e3o dos testes.  </li> </ol>"},{"location":"aae3/unit_test/#design-de-caso-de-teste","title":"Design de Caso de Teste","text":"<p>Voc\u00ea precisa de dois tipos de informa\u00e7\u00f5es ao projetar casos de teste para um m\u00f3dulo de teste: uma especifica\u00e7\u00e3o para o m\u00f3dulo e o c\u00f3digo-fonte do m\u00f3dulo. A especifica\u00e7\u00e3o normalmente define os par\u00e2metros de entrada e sa\u00edda do m\u00f3dulo e sua fun\u00e7\u00e3o.</p> <p>O teste de m\u00f3dulo \u00e9 amplamente orientado para a caixa branca. Um dos motivos \u00e9 que, \u00e0 medida que voc\u00ea testa entidades maiores, como programas inteiros (o que ser\u00e1 o caso dos processos de teste subsequentes), o teste de caixa branca se torna menos vi\u00e1vel. Uma segunda raz\u00e3o \u00e9 que os processos de teste subsequentes s\u00e3o orientados para encontrar diferentes tipos de erros (por exemplo, erros n\u00e3o necessariamente associados \u00e0 l\u00f3gica do programa, como o programa n\u00e3o atender aos requisitos de seus usu\u00e1rios).</p> <p>Portanto, o procedimento de design de caso de teste para um teste de m\u00f3dulo \u00e9 o seguinte:</p> <ol> <li>Analise a l\u00f3gica do m\u00f3dulo usando um ou mais dos m\u00e9todos de caixa branca.  </li> <li>Em seguida, complemente esses casos de teste aplicando m\u00e9todos de caixa preta \u00e0 especifica\u00e7\u00e3o do m\u00f3dulo.</li> </ol> <p>Os m\u00e9todos de design de caso de teste que usaremos foram definidos no Cap\u00edtulo 4. Vamos ilustrar seu uso em um teste de m\u00f3dulo aqui por meio de um exemplo.</p> <p>Suponha que desejamos testar um m\u00f3dulo chamado BONUS, cuja fun\u00e7\u00e3o \u00e9:</p> <ul> <li>Adicionar R\\$ 2.000 ao sal\u00e1rio de todos os funcion\u00e1rios do departamento (ou departamentos) com a maior receita de vendas.  </li> <li>No entanto, se o sal\u00e1rio atual de um funcion\u00e1rio eleg\u00edvel for de R\\$ 150.000 ou mais, ou se o funcion\u00e1rio for um gerente, o sal\u00e1rio deve ser aumentado em apenas R\\$ 1.000.</li> </ul> <p>As entradas para o m\u00f3dulo s\u00e3o mostradas nas tabelas da Figura 5.1.  </p> <p>Se o m\u00f3dulo executar sua fun\u00e7\u00e3o corretamente, ele retornar\u00e1 um c\u00f3digo de erro 0. Se a tabela de funcion\u00e1rios ou de departamentos n\u00e3o contiver entradas, retornar\u00e1 um c\u00f3digo de erro 1. Se n\u00e3o encontrar funcion\u00e1rios em um departamento qualificado, retornar\u00e1 um c\u00f3digo de erro 2.</p> <p>O c\u00f3digo-fonte do m\u00f3dulo \u00e9 mostrado na Figura 5.2. Os par\u00e2metros de entrada ESIZE e DSIZE cont\u00eam o n\u00famero de entradas nas tabelas de empregados e de departamentos. Observe que, embora o m\u00f3dulo seja escrito em PL/1, a discuss\u00e3o a seguir \u00e9 amplamente independente da linguagem; as t\u00e9cnicas s\u00e3o aplic\u00e1veis a programas codificados em outras linguagens. Al\u00e9m disso, como a l\u00f3gica em PL/1 no m\u00f3dulo \u00e9 bastante simples, praticamente qualquer leitor, mesmo aqueles que n\u00e3o est\u00e3o familiarizados com PL/1, dever\u00e1 ser capaz de entend\u00ea-la.  </p>"},{"location":"aae3/unit_test/#employee-table","title":"Employee table","text":"Name Job code Dept. Salary <p>(Preencha at\u00e9 tantas linhas quanto necess\u00e1rio.)</p>"},{"location":"aae3/unit_test/#department-table","title":"Department table","text":"Dept. Sales <p>(Preencha at\u00e9 tantas linhas quanto necess\u00e1rio.)</p>"},{"location":"aae3/unit_test/#barra-lateral-51-plano-de-fundo-pl1","title":"Barra Lateral 5.1: Plano de fundo PL/1","text":"<pre><code>BONUS : PROCEDURE(EMPTAB,DEPTTAB,ESIZE,DSIZE,ERRCODE);\nDECLARE 1 EMPTAB (*),\n    2 NAME CHAR(6),\n    2 CODE CHAR(1),\n    2 DEPT CHAR(3),\n    2 SALARY FIXED DECIMAL(7,2);\nDECLARE 1 DEPTTAB (*),\n    2 DEPT CHAR(3),\n    2 SALES FIXED DECIMAL(8,2);\nDECLARE (ESIZE,DSIZE) FIXED BINARY;\nDECLARE ERRCODE FIXED DECIMAL(1);\nDECLARE MAXSALES FIXED DECIMAL(8,2) INIT(0); /*MAX. SALES IN DEPTTAB*/\nDECLARE (I,J,K) FIXED BINARY;           /*COUNTERS*/\nDECLARE FOUND BIT(1);                   /*TRUE IF ELIGIBLE DEPT. HAS EMPLOYEES*/\nDECLARE SINC FIXED DECIMAL(7,2) INIT(200.00); /*STANDARD INCREMENT*/\nDECLARE LINC FIXED DECIMAL(7,2) INIT(100.00); /*LOWER INCREMENT*/\nDECLARE LSALARY FIXED DECIMAL(7,2) INIT(15000.00); /*SALARY BOUNDARY*/\nDECLARE MGR CHAR(1) INIT('M');\n</code></pre>"},{"location":"aae3/unit_test/#figure-52-module-bonus","title":"FIGURE 5.2 Module BONUS.","text":"<pre><code>1  ERRCODE=0;\n2  IF(ESIZE&lt;=0)|(DSIZE&lt;=0)\n3  THEN ERRCODE=1; /*EMPTAB OR DEPTTAB ARE EMPTY*/\n4  ELSE DO;\n5    DO I = 1 TO DSIZE; /*FIND MAXSALES AND MAXDEPTS*/\n6      IF(SALES(I)&gt;=MAXSALES) THEN MAXSALES=SALES(I);\n7    END;\n8    DO J = 1 TO DSIZE;\n9      IF(SALES(J)=MAXSALES) /*ELIGIBLE DEPARTMENT*/\n10     THEN DO;\n11       FOUND='0'B;\n12       DO K = 1 TO ESIZE;\n13         IF(EMPTAB.DEPT(K)=DEPTTAB.DEPT(J))\n14         THEN DO;\n15           FOUND='1'B;\n16           IF(SALARY(K)&gt;=LSALARY)|CODE(K)=MGR)\n17           THEN SALARY(K)=SALARY(K)+LINC;\n18           ELSE SALARY(K)=SALARY(K)+SINC;\n19         END;\n20       END;\n21       IF(-FOUND) THEN ERRCODE=2;\n22     END;\n23   END;\n24 END;\n25 END;\n</code></pre> <p>Barra Lateral 5.1: Contexto do PL/1</p> <p>Os leitores novos no desenvolvimento de software podem n\u00e3o estar familiarizados com o PL/1 e pensar que \u00e9 uma linguagem \u201cmorta\u201d. \u00c9 verdade que provavelmente h\u00e1 muito pouco desenvolvimento novo usando PL/1, mas a manuten\u00e7\u00e3o dos sistemas existentes continua, e as constru\u00e7\u00f5es PL/1 ainda s\u00e3o uma boa maneira de aprender sobre procedimentos de programa\u00e7\u00e3o.</p> <p>PL/1, que significa Programming Language One, foi desenvolvido na d\u00e9cada de 1960 pela IBM para fornecer um ambiente de desenvolvimento semelhante ao ingl\u00eas para suas m\u00e1quinas de classe mainframe, come\u00e7ando com o IBM System/360. Nessa \u00e9poca da hist\u00f3ria da computa\u00e7\u00e3o, muitos programadores estavam migrando para linguagens especializadas, como COBOL (projetada para aplicativos de neg\u00f3cios) e Fortran (projetado para aplicativos cient\u00edficos). (Veja a Barra Lateral 3.1 no Cap\u00edtulo 3 para mais sobre essas linguagens.)</p> <p>Um dos principais objetivos dos projetistas do PL/1 era criar uma linguagem de desenvolvimento que pudesse competir com sucesso tanto com COBOL quanto com Fortran, ao mesmo tempo em que fornecia uma sintaxe mais natural e f\u00e1cil de aprender. Nem todos os objetivos iniciais do PL/1 foram plenamente alcan\u00e7ados, mas o PL/1 foi refinado e atualizado ao longo dos anos e ainda est\u00e1 em uso em alguns ambientes hoje.</p> <p>Em meados da d\u00e9cada de 1990, o PL/1 foi estendido para outras plataformas de computador, incluindo OS/2, Linux, UNIX e Windows. Esse novo suporte trouxe extens\u00f5es de linguagem para fornecer mais flexibilidade e funcionalidade.</p> <p>Independentemente de qual t\u00e9cnica de cobertura l\u00f3gica voc\u00ea use, o primeiro passo \u00e9 listar as decis\u00f5es condicionais no programa. Neste m\u00f3dulo, as decis\u00f5es s\u00e3o todas as instru\u00e7\u00f5es <code>IF</code> e <code>DO</code>. Observamos que cada <code>DO</code> \u00e9 uma itera\u00e7\u00e3o simples cujo limite \u00e9 igual ou maior que o valor inicial (ou seja, o corpo do loop sempre ser\u00e1 executado ao menos uma vez) e s\u00f3 pode sair por meio da pr\u00f3pria instru\u00e7\u00e3o <code>DO</code>. Portanto, n\u00e3o \u00e9 necess\u00e1ria aten\u00e7\u00e3o especial \u00e0s instru\u00e7\u00f5es <code>DO</code>: qualquer caso de teste que invoque um <code>DO</code> j\u00e1 exercitar\u00e1 sua ramifica\u00e7\u00e3o de entrada e sa\u00edda.</p> <p>As declara\u00e7\u00f5es <code>IF</code> a serem analisadas s\u00e3o (n\u00fameros \u00e0 esquerda indicam a ordem no c\u00f3digo):</p> <pre><code>2   IF (ESIZE &lt; 1/4 * 0)  OR  (DSIZE &lt; 1/4 * 0)\n6   IF (SALES(I) &gt; 1/4 * MAXSALES)\n9   IF (SALES(J) &gt; 1/4 * MAXSALES)\n13  IF (EMPTAB.DEPT(K) &gt; DEPTTAB.DEPT(J))\n16  IF (SALARY(K) &gt; LSALARY)  OR  (CODE(K) = MGR)\n21  IF (\u00acFOUND) THEN ERRCODE = 1/4 290\n</code></pre> Decis\u00e3o Resultado verdadeiro Resultado falso 2 ESIZE &lt; 1/4 * 0 ou DSIZE &lt; 1/4 * 0 ESDIMENSIONAR e DSIZE &gt; 0 6 Sempre ocorrer\u00e1 pelo menos uma vez. Solicite o DEPTTAB para que ocorra um departamento com vendas mais baixas ap\u00f3s um departamento com vendas mais altas. 9 Sempre ocorrer\u00e1 pelo menos uma vez. Todos os departamentos n\u00e3o t\u00eam as mesmas vendas. 13 H\u00e1 um funcion\u00e1rio em um departamento eleg\u00edvel. H\u00e1 um funcion\u00e1rio que n\u00e3o est\u00e1 em um departamento eleg\u00edvel. 16 Um funcion\u00e1rio eleg\u00edvel \u00e9 um gerente ou ganha LSALARY ou mais. Um funcion\u00e1rio eleg\u00edvel n\u00e3o \u00e9 um gerente e ganha menos do que LSALARY. 21 Todos os departamentos eleg\u00edveis n\u00e3o cont\u00eam funcion\u00e1rios. Um departamento eleg\u00edvel cont\u00e9m pelo menos um funcion\u00e1rio. <p>Dado o pequeno n\u00famero de decis\u00f5es, provavelmente devemos optar pela cobertura de v\u00e1rias condi\u00e7\u00f5es, mas examinaremos todos os crit\u00e9rios de cobertura l\u00f3gica (exceto a cobertura de instru\u00e7\u00e3o, que sempre \u00e9 muito limitada para ser usada) para ver seus efeitos.</p> <p>Para satisfazer o crit\u00e9rio de cobertura de decis\u00e3o, precisamos de casos de teste suficientes para invocar ambos os resultados de cada uma das seis decis\u00f5es. As situa\u00e7\u00f5es de entrada necess\u00e1rias para invocar todos os resultados da decis\u00e3o est\u00e3o listadas na Tabela 5.1. Como dois dos resultados sempre ocorrer\u00e3o, h\u00e1 10 situa\u00e7\u00f5es que precisam ser for\u00e7adas por casos de teste. Observe que, para construir a Tabela 5.1, as circunst\u00e2ncias do resultado da decis\u00e3o tiveram que ser rastreadas atrav\u00e9s da l\u00f3gica do programa para determinar as circunst\u00e2ncias de entrada correspondentes adequadas. Por exemplo, a decis\u00e3o 16 n\u00e3o \u00e9 invocada por nenhum funcion\u00e1rio que atenda \u00e0s condi\u00e7\u00f5es; o funcion\u00e1rio deve estar em um departamento eleg\u00edvel.</p> <p>As 10 situa\u00e7\u00f5es de interesse na Tabela 5.1 podem ser invocadas pelos dois casos de teste mostrados na Figura 5.3. Observe que cada caso de teste inclui uma defini\u00e7\u00e3o do resultado esperado, de acordo com os princ\u00edpios discutidos no Cap\u00edtulo 2. Embora esses dois casos de teste atendam ao crit\u00e9rio de cobertura de decis\u00e3o, deve ser \u00f3bvio que pode haver muitos tipos de erros no m\u00f3dulo que n\u00e3o s\u00e3o detectados por esses dois casos de teste. Por exemplo, os casos de teste n\u00e3o exploram as circunst\u00e2ncias em que o c\u00f3digo de erro \u00e9 0, um funcion\u00e1rio \u00e9 um gerente ou a tabela de departamentos est\u00e1 vazia (DSIZE &lt; 1/40).</p>"},{"location":"aae3/unit_test/#figura-53-casos-de-teste-para-satisfazer-o-criterio-de-cobertura-de-decisao","title":"Figura 5.3: Casos de teste para satisfazer o crit\u00e9rio de cobertura de decis\u00e3o","text":"<p>Um teste mais satisfat\u00f3rio pode ser obtido usando o crit\u00e9rio de cobertura de condi\u00e7\u00e3o. Aqui precisamos de casos de teste suficientes para invocar ambos os resultados de cada condi\u00e7\u00e3o nas decis\u00f5es. As condi\u00e7\u00f5es e situa\u00e7\u00f5es de entrada necess\u00e1rias para invocar todos os resultados est\u00e3o listadas na Tabela 5.2. Como dois dos resultados sempre ocorrer\u00e3o, existem 14 situa\u00e7\u00f5es que devem ser for\u00e7adas por casos de teste.</p> <p>Novamente, essas situa\u00e7\u00f5es podem ser invocadas por apenas dois casos de teste, conforme mostrado na Figura 5.4.</p> Caso de teste Entrada Sa\u00edda esperada 1 <pre>ESIZE = 0  \nAll other inputs are irrelevant</pre> <pre>ERRCODE = 1  \nESIZE, DSIZE, EMPTAB e DEPTTAB permanecem inalterados</pre> 2 <pre>ESIZE \u2013 DSIZE = 3</pre> EMPTAB NomeC\u00f3digoDepartamentoSal\u00e1rio JONESED4221.000,00 SMITHED3214.000,00 LORINED4210.200,00 DEPTTAB DepartamentoVendas D4210.000,00 D328.000,00 D9510.000,00 <pre>ERRCODE = 2  \nESIZE, DSIZE e DEPTTAB permanecem inalterados</pre> EMPTAB (ap\u00f3s execu\u00e7\u00e3o) NomeC\u00f3digoDepartamentoSal\u00e1rio JONESED4221.100,00 SMITHED3214.000,00 LORINED4210.200,00 <p>Os casos de teste na Figura 5.4 foram projetados para ilustrar um problema. Uma vez que invocam todos os resultados da Tabela 5.2, eles satisfazem o crit\u00e9rio de cobertura de condi\u00e7\u00e3o, mas provavelmente s\u00e3o um conjunto de casos de teste mais pobre do que os da Figura 5.3 em termos de satisfa\u00e7\u00e3o do crit\u00e9rio de cobertura de decis\u00e3o. A raz\u00e3o \u00e9 que eles n\u00e3o executam todas as instru\u00e7\u00f5es \u2014 por exemplo, o estado 18 nunca \u00e9 executado. Al\u00e9m disso, eles n\u00e3o realizam muito mais do que os casos de teste na Figura 5.3. Eles n\u00e3o causam a situa\u00e7\u00e3o de sa\u00edda ERRORCODE = 1/40. Se a instru\u00e7\u00e3o 2 tivesse definido erroneamente ESIZE = 1/40 e DSIZE = 1/40, esse erro n\u00e3o seria detectado. \u00c9 claro que um conjunto alternativo de casos de teste pode resolver esses problemas, mas o fato \u00e9 que os dois casos de teste na Figura 5.4 satisfazem o crit\u00e9rio de cobertura de condi\u00e7\u00e3o.</p> <p>O uso do crit\u00e9rio combinado de cobertura de decis\u00e3o/condi\u00e7\u00e3o eliminaria a maior fraqueza nos casos de teste na Figura 5.4. Aqui, fornecer\u00edamos casos de teste suficientes para que todos os resultados de todas as condi\u00e7\u00f5es e decis\u00f5es fossem invocados pelo menos uma vez. Fazer de Jones um gerente e de Lorin um n\u00e3o-gerente conseguiria isso, resultando em executar tamb\u00e9m a instru\u00e7\u00e3o 18.</p> Decis\u00e3o Condi\u00e7\u00e3o Resultado verdadeiro Resultado falso 2 <code>ESIZE &lt; 1/4 * 0</code> <code>ESIZE &lt; 1/4 * 0</code> <code>ESIZE &gt; 0</code> 2 <code>DSIZE &lt; 1/4 * 0</code> <code>DSIZE &lt; 1/4 * 0</code> <code>DSIZE &gt; 0</code> 6 <code>SALES(I) &gt; 1/4 * MAXSALES</code> Ao menos um departamento tem vendas &gt; 1/4 * MAXSALES Todos os departamentos t\u00eam vendas \u2264 1/4 * MAXSALES 9 <code>SALES(J) &gt; 1/4 * MAXSALES</code> Ao menos um departamento tem vendas &gt; 1/4 * MAXSALES Todos os departamentos t\u00eam vendas \u2264 1/4 * MAXSALES 13 <code>EMPTAB.DEPT(K) &gt; DEPTTAB.DEPT(J)</code> Existe funcion\u00e1rio em um departamento eleg\u00edvel N\u00e3o existe funcion\u00e1rio em um departamento eleg\u00edvel 16 <code>SALARY(K) &gt; LSALARY</code> Funcion\u00e1rio eleg\u00edvel ganha \u2265 LSALARY Funcion\u00e1rio eleg\u00edvel ganha &lt; LSALARY 16 <code>CODE(K) = MGR</code> Funcion\u00e1rio eleg\u00edvel \u00e9 gerente Funcion\u00e1rio eleg\u00edvel n\u00e3o \u00e9 gerente 21 <code>\u00acFOUND</code> Todos os departamentos eleg\u00edveis n\u00e3o cont\u00eam funcion\u00e1rios Pelo menos um departamento eleg\u00edvel cont\u00e9m pelo menos um funcion\u00e1rio <p>Observa\u00e7\u00f5es sobre corre\u00e7\u00f5es realizadas: - Separei cada condi\u00e7\u00e3o at\u00f4mica em linhas distintas para clareza. - Usei formata\u00e7\u00e3o inline-code para express\u00f5es l\u00f3gicas e aritm\u00e9ticas. - Padronizei o uso de <code>1/4 *</code> em todas as condi\u00e7\u00f5es e os s\u00edmbolos de compara\u00e7\u00e3o. - Ajustei descri\u00e7\u00f5es de \u201cverdadeiro\u201d e \u201cfalso\u201d para refletir corretamente cada condi\u00e7\u00e3o. - Mantive todos os termos originais e adicionei o placeholder para inserir a figura correspondente.  </p>"},{"location":"aae3/unit_test/#figura-54-casos-de-teste-para-satisfazer-o-criterio-de-cobertura-de-condicao","title":"Figura 5.4: Casos de teste para satisfazer o crit\u00e9rio de cobertura de condi\u00e7\u00e3o","text":"<p>Um problema com isso, no entanto, \u00e9 que n\u00e3o \u00e9 essencialmente melhor do que os casos de teste na Figura 5.3. Se o compilador que est\u00e1 sendo usado parar de avaliar uma express\u00e3o assim que determinar que um operando \u00e9 verdadeiro, essa modifica\u00e7\u00e3o resultaria na express\u00e3o <code>CODE(K) = MGR</code> na instru\u00e7\u00e3o 16 nunca tendo um resultado verdadeiro. Portanto, se essa express\u00e3o fosse codificada incorretamente, os casos de teste n\u00e3o detectariam o erro.</p> <p>O \u00faltimo crit\u00e9rio a explorar \u00e9 a cobertura multicondicional. Este crit\u00e9rio requer casos de teste suficientes para que todas as combina\u00e7\u00f5es poss\u00edveis de condi\u00e7\u00f5es em cada decis\u00e3o sejam invocadas pelo menos uma vez. Isso pode ser feito trabalhando na Tabela 5.2. As decis\u00f5es 6, 9, 13 e 21 t\u00eam duas combina\u00e7\u00f5es cada; as decis\u00f5es 2 e 16 t\u00eam quatro combina\u00e7\u00f5es cada. A metodologia para projetar os casos de teste \u00e9:</p> <ol> <li>Selecionar um caso que cubra o maior n\u00famero poss\u00edvel de combina\u00e7\u00f5es.  </li> <li>Selecionar outro que cubra o maior n\u00famero poss\u00edvel de combina\u00e7\u00f5es restantes.  </li> <li>Repetir at\u00e9 que todas as combina\u00e7\u00f5es sejam cobertas.</li> </ol> <p>Um conjunto de casos de teste que satisfaz o crit\u00e9rio de cobertura multicondicional \u00e9 mostrado na Figura 5.5. O conjunto \u00e9 mais abrangente do que os conjuntos anteriores de casos de teste, o que implica que dever\u00edamos ter selecionado esse crit\u00e9rio no in\u00edcio.</p> <p>\u00c9 importante perceber que o m\u00f3dulo BONUS pode ter um n\u00famero t\u00e3o grande de erros que mesmo os testes que satisfazem o crit\u00e9rio de cobertura multicondicional n\u00e3o detectariam todos eles. Por exemplo:</p> <ul> <li>Nenhum caso de teste gera a situa\u00e7\u00e3o em que <code>ERRCODE</code> \u00e9 retornado com valor 0; portanto, se a instru\u00e7\u00e3o 1 estivesse ausente, o erro n\u00e3o seria detectado.  </li> <li>Se o <code>LSALARY</code> fosse inicializado erroneamente para US\\$ 150 000,01, o erro passaria despercebido.  </li> <li>Se a declara\u00e7\u00e3o 16 fosse implementada como <code>SALARY(K) &gt; LSALARY</code> em vez de <code>SALARY(K) &gt; 1/4 * LSALARY</code>, esse erro n\u00e3o seria encontrado.  </li> <li>Al\u00e9m disso, erros off-by-one (como n\u00e3o manipular corretamente a \u00faltima entrada em <code>DEPTTAB</code> ou <code>EMPTAB</code>) dependeriam em grande parte do acaso para serem detectados.</li> </ul> <p>Dois pontos devem ficar claros:</p> <ol> <li>O crit\u00e9rio multicondicional \u00e9 superior aos outros crit\u00e9rios.  </li> <li>Qualquer crit\u00e9rio de cobertura l\u00f3gica n\u00e3o \u00e9 suficiente como \u00fanico meio de derivar testes de m\u00f3dulo.</li> </ol> <p>Portanto, o pr\u00f3ximo passo \u00e9 complementar os testes da Figura 5.5 com um conjunto de testes de caixa preta. Para isso, as especifica\u00e7\u00f5es de interface do m\u00f3dulo BONUS s\u00e3o mostradas a seguir:</p>"},{"location":"aae3/unit_test/#especificacao-de-interface-do-modulo-bonus","title":"Especifica\u00e7\u00e3o de Interface do M\u00f3dulo BONUS","text":"<p>BONUS, um m\u00f3dulo PL/1, recebe cinco par\u00e2metros, simbolicamente referidos aqui como EMPTAB, DEPTTAB, ESIZE, DSIZE e ERRORCODE. Os atributos desses par\u00e2metros s\u00e3o:</p> <p>```pl1 DECLARE 1 EMPTAB(),           / ENTRADA E SA\u00cdDA */     2    CHARACTER NAME(6),     2    CHARACTER CODE(1),     2    CHARACTER DEPT(3),     2    FIXED DECIMAL SALARY(7,2);</p> <p>DECLARE 1 DEPTTAB(),          / ENTRADA */     2    CHARACTER DEPTCODE(3),     2    FIXED DECIMAL SALES(8,2);</p> <p>DECLARE (ESIZE, DSIZE)         / ENTRADA /     BINARY FIXED;</p> <p>DECLARE ERRCODE                 / SA\u00cdDA /     FIXED DECIMAL(1);</p> <p>O m\u00f3dulo pressup\u00f5e que os argumentos transmitidos tenham esses atributos. ESIZE e DSIZE indicam o n\u00famero de entradas em EMPTAB e DEPTTAB, respectivamente. N\u00e3o devem ser feitas suposi\u00e7\u00f5es sobre a ordem das entradas em EMPTAB e DEPTTAB.</p> <p>A fun\u00e7\u00e3o do m\u00f3dulo \u00e9 incrementar o sal\u00e1rio (<code>EMPTAB.SALARY</code>) dos funcion\u00e1rios do departamento (ou departamentos) com o maior valor de vendas (<code>DEPTTAB.SALES</code>).  </p> <ul> <li>Se o sal\u00e1rio atual do funcion\u00e1rio for R\\$ 150.000,00 ou mais, ou se o funcion\u00e1rio for um gerente (<code>EMPTAB.CODE = 'M'</code>), o incremento \u00e9 de R\\$ 1.000,00.  </li> <li>Caso contr\u00e1rio, o incremento para o funcion\u00e1rio eleg\u00edvel \u00e9 de R\\$ 2.000,00.  </li> </ul> <p>O m\u00f3dulo pressup\u00f5e que o sal\u00e1rio incrementado caber\u00e1 no campo <code>EMPTAB.SALARY</code>.  </p> <ol> <li>Se ESIZE \u2264 0 ou DSIZE \u2264 0, ent\u00e3o:</li> <li><code>ERRCODE \u2190 1</code></li> <li> <p>Nenhuma a\u00e7\u00e3o adicional \u00e9 executada.  </p> </li> <li> <p>Caso contr\u00e1rio:</p> </li> <li>A fun\u00e7\u00e3o \u00e9 completamente executada.</li> <li>Se nenhum departamento de vendas m\u00e1ximas tiver funcion\u00e1rio, o processamento continua, mas <code>ERRCODE \u2190 2</code>;  </li> <li>Caso contr\u00e1rio, <code>ERRCODE \u2190 0</code>.  </li> </ol> <p>Esta especifica\u00e7\u00e3o n\u00e3o \u00e9 adequada para gr\u00e1ficos de causa e efeito (n\u00e3o h\u00e1 um conjunto de condi\u00e7\u00f5es de entrada cujas combina\u00e7\u00f5es devam ser exploradas). Assim, ser\u00e1 utilizada an\u00e1lise de valor de contorno. Os limites de entrada identificados s\u00e3o os seguintes:  </p>"},{"location":"aae3/unit_test/#limites-de-valor-de-contorno","title":"Limites de Valor de Contorno","text":""},{"location":"aae3/unit_test/#limites-de-entrada","title":"Limites de Entrada","text":"<ol> <li>EMPTAB tem 1 entrada.  </li> <li>EMPTAB tem o n\u00famero m\u00e1ximo de entradas (65 535).  </li> <li>EMPTAB possui 0 entradas.  </li> <li>DEPTTAB tem 1 entrada.  </li> <li>DEPTTAB tem 65 535 entradas.  </li> <li>DEPTTAB tem 0 entradas.  </li> <li>Um departamento de vendas m\u00e1ximas tem 1 funcion\u00e1rio.  </li> <li>Um departamento de vendas m\u00e1ximas tem 65 535 funcion\u00e1rios.  </li> <li>Um departamento de vendas m\u00e1ximas n\u00e3o tem funcion\u00e1rios.  </li> <li>Todos os departamentos do DEPTTAB t\u00eam as mesmas vendas.  </li> <li>O departamento de vendas m\u00e1ximas \u00e9 a primeira entrada no DEPTTAB.  </li> <li>O departamento de vendas m\u00e1ximas \u00e9 a \u00faltima entrada no DEPTTAB.  </li> <li>Um funcion\u00e1rio eleg\u00edvel \u00e9 a primeira entrada no EMPTAB.  </li> <li>Um funcion\u00e1rio eleg\u00edvel \u00e9 a \u00faltima entrada no EMPTAB.  </li> <li>Um funcion\u00e1rio eleg\u00edvel \u00e9 um gerente.  </li> <li>Um funcion\u00e1rio eleg\u00edvel n\u00e3o \u00e9 um gerente.  </li> <li>Um funcion\u00e1rio eleg\u00edvel n\u00e3o-gerente tem sal\u00e1rio de R\\$ 149 999,99.  </li> <li>Um funcion\u00e1rio eleg\u00edvel n\u00e3o-gerente tem sal\u00e1rio de R\\$ 150 000,00.  </li> <li>Um funcion\u00e1rio eleg\u00edvel n\u00e3o-gerente tem sal\u00e1rio de R\\$ 150 000,01.  </li> </ol>"},{"location":"aae3/unit_test/#limites-de-saida","title":"Limites de Sa\u00edda","text":"<ol> <li><code>ERRCODE = 1/40</code> </li> <li><code>ERRCODE = 1/41</code> </li> <li><code>ERRCODE = 1/42</code> </li> <li>O sal\u00e1rio incrementado de um funcion\u00e1rio eleg\u00edvel \u00e9 de R\\$ 299 999,99.  </li> </ol>"},{"location":"aae3/unit_test/#teste-de-adivinhacao-de-erros","title":"Teste de Adivinha\u00e7\u00e3o de Erros","text":"<ol> <li>Um departamento de vendas m\u00e1ximas sem funcion\u00e1rios \u00e9 seguido no DEPTTAB por outro departamento de vendas m\u00e1ximas com funcion\u00e1rios.  </li> </ol>"},{"location":"aae3/unit_test/#planejamento-de-casos-de-teste-adicionais","title":"Planejamento de Casos de Teste Adicionais","text":"<p>Isso \u00e9 usado para determinar se o m\u00f3dulo encerra erroneamente o processamento da entrada quando encontra uma situa\u00e7\u00e3o <code>ERRCODE = 1/42</code>. Revendo essas 24 condi\u00e7\u00f5es, os n\u00fameros 2, 5 e 8 parecem casos de teste impratic\u00e1veis. Uma vez que eles tamb\u00e9m representam condi\u00e7\u00f5es que nunca ocorrer\u00e3o (geralmente uma suposi\u00e7\u00e3o perigosa a ser feita ao testar, mas aparentemente segura aqui), n\u00f3s os exclu\u00edmos.</p> <p>O pr\u00f3ximo passo \u00e9 comparar as 21 condi\u00e7\u00f5es restantes com o conjunto atual de casos de teste (Figura 5.5) para determinar quais condi\u00e7\u00f5es de contorno ainda n\u00e3o est\u00e3o cobertas. Ao fazer isso, vemos que as condi\u00e7\u00f5es 1, 4, 7, 10, 14, 17, 18, 19, 20, 23 e 24 exigem casos de teste al\u00e9m dos da Figura 5.5.</p> <p>O pr\u00f3ximo passo \u00e9 projetar casos de teste adicionais para cobrir essas 11 condi\u00e7\u00f5es de limite. Uma abordagem \u00e9 mesclar essas condi\u00e7\u00f5es nos casos de teste existentes (por exemplo, modificando o caso de teste 4 na Figura 5.5), mas isso n\u00e3o \u00e9 recomendado porque poderia inadvertidamente perturbar a cobertura completa de m\u00faltiplas condi\u00e7\u00f5es dos casos de teste existentes. Portanto, a abordagem mais segura \u00e9 adicionar casos de teste aos da Figura 5.5.</p> <p>Os tr\u00eas casos de teste na Figura 5.6 conseguem isso:</p> <ul> <li>Caso de Teste 5: abrange as condi\u00e7\u00f5es 7, 10, 14, 17, 18, 19 e 20.  </li> <li>Caso de Teste 6: abrange as condi\u00e7\u00f5es 1, 4 e 23.  </li> <li>Caso de Teste 7: cobre a condi\u00e7\u00e3o 24.  </li> </ul> <p>A premissa aqui \u00e9 que os casos de teste de cobertura l\u00f3gica (caixa branca) na Figura 5.6 formam um teste de m\u00f3dulo razo\u00e1vel para o procedimento BONUS.</p>"},{"location":"aae3/unit_test/#testes-incrementais","title":"Testes Incrementais","text":"<p>Ao executar o processo de teste de m\u00f3dulos, h\u00e1 duas considera\u00e7\u00f5es principais:</p> <ol> <li>Design de um conjunto eficaz de casos de teste (discutido na se\u00e7\u00e3o anterior).  </li> <li>Integra\u00e7\u00e3o: a maneira pela qual os m\u00f3dulos s\u00e3o combinados para formar um programa de trabalho.  </li> </ol> <p>A segunda considera\u00e7\u00e3o \u00e9 importante porque tem as seguintes implica\u00e7\u00f5es:</p> <ul> <li>A forma na qual os casos de teste do m\u00f3dulo s\u00e3o escritos.  </li> <li>Os tipos de ferramentas de teste que podem ser usadas.  </li> </ul>"},{"location":"aae3/unit_test/#figura-56-casos-de-teste-de-analise-de-valor-de-contorno-suplementar-para-bonus","title":"Figura 5.6: Casos de teste de an\u00e1lise de valor de contorno suplementar para BONUS","text":""},{"location":"aae3/unit_test/#testes-incrementais-vs-nao-incrementais","title":"Testes Incrementais vs N\u00e3o Incrementais","text":"<p>A ordem na qual os m\u00f3dulos s\u00e3o codificados e testados influencia diretamente:</p> <ul> <li>O custo de gera\u00e7\u00e3o de casos de teste  </li> <li>O custo de depura\u00e7\u00e3o (localiza\u00e7\u00e3o e reparo de erros detectados)  </li> </ul> <p>Em suma, \u00e9 uma considera\u00e7\u00e3o de import\u00e2ncia substancial. Nesta se\u00e7\u00e3o, discutimos duas abordagens: testes incrementais e testes n\u00e3o incrementais. No pr\u00f3ximo cap\u00edtulo, exploraremos duas abordagens incrementais: top-down e bottom-up.</p> <p>A quest\u00e3o central \u00e9: voc\u00ea deve testar um programa testando cada m\u00f3dulo de forma independente e, em seguida, combinando os m\u00f3dulos para formar o sistema completo, ou testar o programa de outra forma?</p> <p>A primeira abordagem \u00e9 chamada de teste ou integra\u00e7\u00e3o n\u00e3o incremental, ou \u201cbig-bang\u201d. A segunda abordagem \u00e9 conhecida como teste incremental, ou integra\u00e7\u00e3o incremental.</p> <p></p> <p>O programa na Figura 5.7 \u00e9 usado como exemplo. Os ret\u00e2ngulos representam os seis m\u00f3dulos (sub-rotinas ou procedimentos) no programa. As linhas que conectam os m\u00f3dulos representam a hierarquia de controle do programa; ou seja, o m\u00f3dulo A chama os m\u00f3dulos B, C e D; o m\u00f3dulo B chama o m\u00f3dulo E; e assim por diante.</p> <p>O teste n\u00e3o incremental, a abordagem tradicional, \u00e9 realizado da seguinte maneira. Primeiro, um teste de m\u00f3dulo \u00e9 realizado em cada um dos seis m\u00f3dulos, testando cada m\u00f3dulo como uma entidade independente. Os m\u00f3dulos podem ser testados ao mesmo tempo ou sucessivamente, dependendo do ambiente (por exemplo, instala\u00e7\u00f5es de computa\u00e7\u00e3o interativas versus instala\u00e7\u00f5es de processamento em lote) e do n\u00famero de pessoas envolvidas. Finalmente, os m\u00f3dulos s\u00e3o combinados ou integrados (por exemplo, \u201clink editado\u201d) para formar o programa.</p> <p>O teste de cada m\u00f3dulo requer um m\u00f3dulo driver especial e um ou mais m\u00f3dulos stub. Por exemplo, para testar o m\u00f3dulo B, os casos de teste s\u00e3o primeiro projetados e depois alimentados para o m\u00f3dulo B, passando-lhe argumentos de entrada de um m\u00f3dulo driver, um pequeno m\u00f3dulo que deve ser codificado para \u201cconduzir\u201d ou transmitir casos de teste atrav\u00e9s do m\u00f3dulo em teste. (Como alternativa, uma ferramenta de teste pode ser usada.) O m\u00f3dulo driver tamb\u00e9m deve exibir, para o testador, os resultados produzidos por B. Al\u00e9m disso, como o m\u00f3dulo B chama o m\u00f3dulo E, algo deve estar presente para receber o controle quando B chama E. Um m\u00f3dulo stub, um m\u00f3dulo especial com o nome de \u201cE\u201d que deve ser codificado para simular a fun\u00e7\u00e3o do m\u00f3dulo E, realiza isso.</p> <p>Quando o teste de m\u00f3dulo de todos os seis m\u00f3dulos for conclu\u00eddo, os m\u00f3dulos ser\u00e3o combinados para formar o programa.</p> <p>A abordagem alternativa \u00e9 o teste incremental. Em vez de testar cada m\u00f3dulo isoladamente, o pr\u00f3ximo m\u00f3dulo a ser testado \u00e9 primeiro combinado com o conjunto de m\u00f3dulos que j\u00e1 foram testados.</p> <p>\u00c9 prematuro fornecer um procedimento para testar incrementalmente o programa na Figura 5.7, porque h\u00e1 um grande n\u00famero de abordagens incrementais poss\u00edveis. Uma quest\u00e3o fundamental \u00e9 se devemos come\u00e7ar no topo ou na base do programa. No entanto, como discutiremos essa quest\u00e3o na pr\u00f3xima se\u00e7\u00e3o, vamos supor por enquanto que estamos come\u00e7ando de baixo.</p> <p></p> <p>O primeiro passo \u00e9 testar os m\u00f3dulos E, C e F, em paralelo (por tr\u00eas pessoas) ou em s\u00e9rie. Observe que devemos preparar um driver para cada m\u00f3dulo, mas n\u00e3o um stub. O pr\u00f3ximo passo \u00e9 testar B e D; mas, em vez de test\u00e1-los isoladamente, eles s\u00e3o combinados com os m\u00f3dulos E e F, respectivamente. Em outras palavras, para testar o m\u00f3dulo B, um driver \u00e9 escrito incorporando os casos de teste, e o par B\u2013E \u00e9 testado. O processo incremental \u2014 adicionando o pr\u00f3ximo m\u00f3dulo ao conjunto ou subconjunto de m\u00f3dulos testados anteriormente \u2014 \u00e9 continuado at\u00e9 que o \u00faltimo m\u00f3dulo (m\u00f3dulo A, neste caso) seja testado. Observe que esse procedimento poderia ter progredido alternativamente de cima para baixo.</p> <p>V\u00e1rias observa\u00e7\u00f5es devem ser aparentes neste ponto:</p> <ol> <li> <p>O teste n\u00e3o incremental requer mais trabalho. Para o programa na Figura 5.7, cinco drivers e cinco stubs devem ser preparados (supondo que n\u00e3o precisemos de um m\u00f3dulo de driver para o m\u00f3dulo superior). O teste de baixo para cima exigiria cinco drivers, mas nenhum stub. Um teste de cima para baixo exigiria cinco stubs, mas nenhum driver. Menos trabalho \u00e9 necess\u00e1rio porque os m\u00f3dulos testados anteriormente s\u00e3o usados em vez dos m\u00f3dulos de driver (se voc\u00ea come\u00e7ar de cima) ou m\u00f3dulos de stub (se voc\u00ea come\u00e7ar de baixo) necess\u00e1rios na abordagem n\u00e3o incremental.</p> </li> <li> <p>Erros de programa\u00e7\u00e3o relacionados a interfaces incompat\u00edveis ou suposi\u00e7\u00f5es incorretas entre m\u00f3dulos ser\u00e3o detectados mais cedo quando o teste incremental for usado. A raz\u00e3o \u00e9 que as combina\u00e7\u00f5es de m\u00f3dulos s\u00e3o testadas em conjunto desde o in\u00edcio. No entanto, quando testes n\u00e3o incrementais s\u00e3o usados, os m\u00f3dulos n\u00e3o \u201cse veem\u201d at\u00e9 o final do processo.</p> </li> <li> <p>Como resultado, a depura\u00e7\u00e3o deve ser mais f\u00e1cil se o teste incremental for usado. Se assumirmos que existem erros relacionados a interfaces e suposi\u00e7\u00f5es entre m\u00f3dulos (uma boa suposi\u00e7\u00e3o, por experi\u00eancia), ent\u00e3o, se testes n\u00e3o incrementais foram usados, os erros n\u00e3o aparecer\u00e3o at\u00e9 que todo o programa tenha sido combinado. Neste momento, podemos ter dificuldade em identificar o erro, pois ele pode estar em qualquer lugar dentro do programa. Por outro lado, se for utilizado um teste incremental, um erro deste tipo dever\u00e1 ser mais f\u00e1cil de localizar, uma vez que \u00e9 prov\u00e1vel que ele esteja associado ao m\u00f3dulo adicionado mais recentemente.</p> </li> <li> <p>O teste incremental pode resultar em testes mais completos. Se voc\u00ea estiver testando o m\u00f3dulo B, o m\u00f3dulo E ou A (dependendo se voc\u00ea come\u00e7ou de baixo ou de cima) ser\u00e1 executado como consequ\u00eancia. Embora E ou A devessem ter sido exaustivamente testados anteriormente, talvez execut\u00e1-los durante o teste de B invoque uma nova condi\u00e7\u00e3o \u2014 possivelmente uma defici\u00eancia no teste original de E ou A. Por outro lado, no teste n\u00e3o incremental, o teste de B afeta apenas o pr\u00f3prio m\u00f3dulo B. Em outras palavras, o teste incremental substitui os stubs ou drivers necess\u00e1rios na abordagem n\u00e3o incremental pelos m\u00f3dulos reais, dando-lhes mais exposi\u00e7\u00e3o ao final do \u00faltimo teste de m\u00f3dulo.</p> </li> <li> <p>A abordagem n\u00e3o incremental parece usar menos tempo de m\u00e1quina. Se o m\u00f3dulo A da Figura 5.7 estiver sendo testado usando o teste de baixo para cima, os m\u00f3dulos B, C, D, E e F provavelmente ser\u00e3o executados durante a execu\u00e7\u00e3o de A. Em um teste n\u00e3o incremental de A, apenas stubs para B, C e E ser\u00e3o executados. O mesmo ocorre no teste incremental de cima para baixo: se o m\u00f3dulo F estiver sendo testado, os m\u00f3dulos A, B, C, D e E podem ser executados, enquanto no teste n\u00e3o incremental de F, apenas o driver para F e o pr\u00f3prio F s\u00e3o executados. Portanto, o n\u00famero de instru\u00e7\u00f5es de m\u00e1quina executadas em um teste incremental tende a ser maior do que no teste n\u00e3o incremental. Em contrapartida, o teste n\u00e3o incremental exige mais tempo de desenvolvimento de drivers e stubs.</p> </li> <li> <p>No in\u00edcio da fase de teste de m\u00f3dulo, h\u00e1 mais oportunidade para atividades paralelas quando o teste n\u00e3o incremental \u00e9 usado (ou seja, todos os m\u00f3dulos podem ser testados simultaneamente). Isso pode ser significativo em um grande projeto (muitos m\u00f3dulos e pessoas), j\u00e1 que o n\u00famero de funcion\u00e1rios geralmente atinge seu pico no in\u00edcio dessa fase.</p> </li> </ol> <p>Em resumo, as observa\u00e7\u00f5es 1 a 4 s\u00e3o vantagens do teste incremental, enquanto as observa\u00e7\u00f5es 5 e 6 s\u00e3o desvantagens. Dadas as tend\u00eancias atuais na ind\u00fastria da computa\u00e7\u00e3o (os custos de hardware t\u00eam diminu\u00eddo e parecem destinados a continuar a faz\u00ea-lo, enquanto a capacidade de hardware aumenta; por outro lado, os custos de hardware e as consequ\u00eancias de erros de software est\u00e3o aumentando), e dado o fato de que quanto mais cedo um erro \u00e9 encontrado, menor \u00e9 o custo de repar\u00e1-lo, pode-se ver que as observa\u00e7\u00f5es 1 a 4 est\u00e3o crescendo em import\u00e2ncia, enquanto a observa\u00e7\u00e3o 5 est\u00e1 se tornando menos relevante. A observa\u00e7\u00e3o 6 parece ser uma desvantagem fraca, se \u00e9 que existe. Isso leva \u00e0 conclus\u00e3o de que o teste incremental \u00e9 superior.</p>"},{"location":"aae3/unit_test/#teste-de-cima-para-baixo-versus-de-baixo-para-cima","title":"Teste de cima para baixo versus de baixo para cima","text":"<p>Dada a conclus\u00e3o da se\u00e7\u00e3o anterior \u2014 que o teste incremental \u00e9 superior ao teste n\u00e3o incremental \u2014 exploramos a seguir duas estrat\u00e9gias incrementais: teste de cima para baixo e teste de baixo para cima. Antes de entrar nelas, no entanto, devemos esclarecer v\u00e1rios equ\u00edvocos.</p> <p>Primeiro, os termos top-down testing, top-down development e top-down design s\u00e3o frequentemente usados como sin\u00f4nimos. Teste de cima para baixo e desenvolvimento de cima para baixo s\u00e3o sin\u00f4nimos (representam uma estrat\u00e9gia de ordenar a codifica\u00e7\u00e3o e o teste de m\u00f3dulos), mas o design de cima para baixo \u00e9 algo bem diferente e independente. Um programa que foi projetado de cima para baixo pode ser testado de cima para baixo ou de baixo para cima.</p> <p>Em segundo lugar, o teste de baixo para cima (ou desenvolvimento de baixo para cima) \u00e9 frequentemente equiparado erroneamente ao teste n\u00e3o incremental. A raz\u00e3o \u00e9 que o teste de baixo para cima come\u00e7a de maneira id\u00eantica a um teste n\u00e3o incremental (ou seja, quando os m\u00f3dulos inferiores, ou terminais, s\u00e3o testados), mas, como vimos na se\u00e7\u00e3o anterior, o teste de baixo para cima \u00e9 uma estrat\u00e9gia incremental.</p> <p>Finalmente, como ambas as estrat\u00e9gias s\u00e3o incrementais, n\u00e3o repetiremos aqui as vantagens dos testes incrementais; discutiremos apenas as diferen\u00e7as entre teste de cima para baixo e teste de baixo para cima.</p>"},{"location":"aae3/unit_test/#teste-de-cima-para-baixo","title":"Teste de cima para baixo","text":"<p>A estrat\u00e9gia de cima para baixo come\u00e7a com o m\u00f3dulo superior, ou inicial, no programa. Depois disso, n\u00e3o h\u00e1 um \u00fanico procedimento \u201ccorreto\u201d para selecionar o pr\u00f3ximo m\u00f3dulo a ser testado incrementalmente; a \u00fanica regra \u00e9 que, para ser eleg\u00edvel, pelo menos um dos m\u00f3dulos subordinados (chamados) do m\u00f3dulo em teste deve ter sido testado anteriormente.</p> <p></p> <p>A Figura 5.8 \u00e9 usada para ilustrar essa estrat\u00e9gia. A a L s\u00e3o os 12 m\u00f3dulos do programa. Suponha que o m\u00f3dulo J contenha as opera\u00e7\u00f5es de leitura de E/S do programa e o m\u00f3dulo I contenha as opera\u00e7\u00f5es de grava\u00e7\u00e3o.</p> <p>O primeiro passo \u00e9 testar o m\u00f3dulo A. Para isso, os m\u00f3dulos stub que representam B, C e D devem ser escritos. Infelizmente, a produ\u00e7\u00e3o de m\u00f3dulos stub \u00e9 muitas vezes mal compreendida; como evid\u00eancia, frequentemente voc\u00ea pode ver declara\u00e7\u00f5es como \u201cum m\u00f3dulo stub precisa apenas escrever uma mensagem informando \u2018chegamos at\u00e9 aqui\u2019\u201d e \u201cem muitos casos, o m\u00f3dulo stub simplesmente retorna sem fazer nenhum trabalho\u201d. Na maioria das situa\u00e7\u00f5es, essas afirma\u00e7\u00f5es s\u00e3o falsas.</p> <p>Como o m\u00f3dulo A chama o m\u00f3dulo B, A espera que B execute algum trabalho; esse trabalho provavelmente \u00e9 algum resultado (argumentos de sa\u00edda) retornado a A. Se o stub simplesmente retornar o controle ou escrever uma mensagem de erro sem fornecer um resultado significativo, o m\u00f3dulo A falhar\u00e1 \u2014 n\u00e3o por causa de um erro em A, mas por causa da falha do stub em simular o m\u00f3dulo correspondente.</p> <p>Al\u00e9m disso, retornar uma sa\u00edda \u201cconectada\u201d de um m\u00f3dulo stub \u00e9 muitas vezes insuficiente. Por exemplo, considere a tarefa de escrever um stub representando uma rotina de raiz quadrada, uma rotina de pesquisa de tabela de banco de dados, uma rotina de \u201cobter registro de arquivo mestre correspondente\u201d ou algo semelhante. Se o stub retornar uma sa\u00edda fixa \u2014 mas n\u00e3o o valor espec\u00edfico esperado pelo m\u00f3dulo de chamada durante essa invoca\u00e7\u00e3o \u2014 o m\u00f3dulo de chamada poder\u00e1 falhar ou produzir um resultado confuso. Portanto, a produ\u00e7\u00e3o de stubs n\u00e3o \u00e9 uma tarefa trivial.</p> <p>Outra considera\u00e7\u00e3o \u00e9 a forma como os casos de teste s\u00e3o apresentados ao programa, uma considera\u00e7\u00e3o importante que nem mesmo \u00e9 mencionada na maioria das discuss\u00f5es sobre teste de cima para baixo. Em nosso exemplo, a pergunta \u00e9: Como voc\u00ea alimenta casos de teste para o m\u00f3dulo A? O m\u00f3dulo superior em programas t\u00edpicos n\u00e3o recebe argumentos de entrada nem executa opera\u00e7\u00f5es de entrada/sa\u00edda, portanto, a resposta n\u00e3o \u00e9 imediatamente \u00f3bvia. A resposta \u00e9 que os dados de teste s\u00e3o alimentados no m\u00f3dulo (m\u00f3dulo A nesta situa\u00e7\u00e3o) a partir de um ou mais de seus stubs.</p> <p>Para ilustrar, suponha que as fun\u00e7\u00f5es de B, C e D sejam as seguintes: - B \u2014 Obter resumo do arquivo de transa\u00e7\u00e3o. - C \u2014 Determinar se o status semanal atende \u00e0 cota. - D \u2014 Produzir relat\u00f3rio de resumo semanal.</p> <p>Um caso de teste para A, ent\u00e3o, \u00e9 um resumo de transa\u00e7\u00e3o retornado do stub B. O stub D pode conter instru\u00e7\u00f5es para gravar seus dados de entrada em uma impressora, permitindo que os resultados de cada teste sejam examinados.</p> <p>Neste programa, existe outro problema. Presumivelmente, o m\u00f3dulo A chama o m\u00f3dulo B apenas uma vez; portanto, o problema \u00e9 como alimentar mais de um caso de teste para A. Uma solu\u00e7\u00e3o \u00e9 desenvolver v\u00e1rias vers\u00f5es do stub B, cada uma com um conjunto diferente de dados de teste a serem retornados a A. Para executar os casos de teste, o programa \u00e9 executado v\u00e1rias vezes, cada vez com uma vers\u00e3o diferente do stub B. Outra alternativa \u00e9 colocar dados de teste em arquivos externos e fazer com que o stub B leia esses dados e os retorne para A. Em ambos os casos, tendo em mente a discuss\u00e3o anterior, voc\u00ea deve ver que o desenvolvimento de m\u00f3dulos stub \u00e9 mais dif\u00edcil do que muitas vezes parece.</p> <p>Al\u00e9m disso, muitas vezes \u00e9 necess\u00e1rio, devido \u00e0s caracter\u00edsticas do programa, representar um caso de teste em v\u00e1rios stubs abaixo do m\u00f3dulo em teste (ou seja, onde o m\u00f3dulo recebe dados a serem acionados chamando v\u00e1rios m\u00f3dulos). Depois que A for testado, um m\u00f3dulo real substitui um dos stubs e os stubs exigidos por esse m\u00f3dulo s\u00e3o adicionados. Por exemplo, a Figura 5.9 pode representar a pr\u00f3xima vers\u00e3o do programa.</p> <p></p> <p>Depois de testar o m\u00f3dulo superior, v\u00e1rias sequ\u00eancias s\u00e3o poss\u00edveis. Por exemplo, se estivermos realizando todas as sequ\u00eancias de teste, quatro exemplos de quaisquer sequ\u00eancias poss\u00edveis de m\u00f3dulos s\u00e3o:</p> <p>//corrigir  1. UMA B 2. UMA B 3. UMA DCDEFGHEuJKL    EFJCGKDHLEu    HEuKLCGBFJE    BFJDEuECGKHL 4. UMA</p> <p></p> <p>Se ocorrerem testes paralelos, outras alternativas s\u00e3o poss\u00edveis. Por exemplo, depois que o m\u00f3dulo A foi testado, um programador pode testar a combina\u00e7\u00e3o A\u2013B; outro, A\u2013C; e um terceiro, A\u2013D. Em geral, n\u00e3o existe uma sequ\u00eancia \u201cmelhor\u201d, mas duas diretrizes devem ser consideradas:</p> <ol> <li>Se\u00e7\u00f5es cr\u00edticas do programa (por exemplo, o m\u00f3dulo G): uma \u201cse\u00e7\u00e3o cr\u00edtica\u201d pode ser um m\u00f3dulo complexo, com novo algoritmo ou suspeito de ser propenso a erros.  </li> <li>M\u00f3dulos de E/S devem ser adicionados o mais cedo poss\u00edvel.</li> </ol> <p>A motiva\u00e7\u00e3o para a primeira diretriz \u00e9 \u00f3bvia, mas a segunda merece discuss\u00e3o. Lembre-se de que, enquanto alguns stubs devem conter casos de teste, outros precisam gravar suas entradas em impressora ou monitor. Assim que o m\u00f3dulo que aceita a entrada do programa \u00e9 adicionado, a representa\u00e7\u00e3o dos casos de teste se simplifica \u2014 sua forma passa a ser id\u00eantica \u00e0 entrada do programa final (por exemplo, de um arquivo de transa\u00e7\u00e3o ou de um terminal). Da mesma forma, quando o m\u00f3dulo que executa a fun\u00e7\u00e3o de sa\u00edda \u00e9 incorporado, o c\u00f3digo nos stubs para escrever resultados pode deixar de ser necess\u00e1rio.</p> <p>Portanto, se J e I s\u00e3o os m\u00f3dulos de E/S e G \u00e9 o m\u00f3dulo cr\u00edtico, uma sequ\u00eancia incremental poss\u00edvel \u00e9:</p> <p>A \u2192 B \u2192 F \u2192 J \u2192 D \u2192 I \u2192 C \u2192 G \u2192 E \u2192 K \u2192 H \u2192 L</p> <p>O programa ap\u00f3s o sexto incremento (ap\u00f3s D) ficaria conforme ilustrado na Figura 5.10.</p> <p></p> <p>Uma vez atingido o estado intermedi\u00e1rio na Figura 5.10, a representa\u00e7\u00e3o dos casos de teste e a inspe\u00e7\u00e3o dos resultados s\u00e3o simplificadas. Tem ainda outra vantagem, pois voc\u00ea possui uma vers\u00e3o esquel\u00e9tica funcional do programa \u2014 ou seja, uma vers\u00e3o que executa opera\u00e7\u00f5es reais de entrada e sa\u00edda. No entanto, os stubs ainda est\u00e3o simulando alguns dos \u201cinteriores\u201d. Esta vers\u00e3o esquel\u00e9tica inicial:</p> <ul> <li>Permite que voc\u00ea encontre erros e problemas de fator humano.  </li> <li>Possibilita demonstrar o programa ao eventual usu\u00e1rio.  </li> <li>Serve como evid\u00eancia de que o design geral do programa \u00e9 s\u00f3lido.  </li> <li>Serve como um impulsionador do moral.</li> </ul> <p>Esses pontos representam a principal vantagem da estrat\u00e9gia de cima para baixo. Por outro lado, a abordagem de cima para baixo tem algumas defici\u00eancias s\u00e9rias.</p> <p>Suponha que nosso estado atual de teste seja o da Figura 5.10 e que nosso pr\u00f3ximo passo seja substituir o stub H pelo m\u00f3dulo H. O que devemos fazer neste ponto (ou antes) \u00e9 usar os m\u00e9todos descritos anteriormente neste cap\u00edtulo para desincronizar um conjunto de casos de teste para H. Observe, no entanto, que os casos de teste est\u00e3o na forma de entradas reais do programa para o m\u00f3dulo J. Isso apresenta v\u00e1rios problemas. Primeiro, por causa dos m\u00f3dulos intermedi\u00e1rios entre J e H (F, B, A e D), podemos achar imposs\u00edvel representar certos casos de teste para o m\u00f3dulo J que testem todas as situa\u00e7\u00f5es predefinidas em H. Por exemplo, se H \u00e9 o m\u00f3dulo B\u00d4NUS da Figura 5.2, pode ser imposs\u00edvel, devido \u00e0 natureza do m\u00f3dulo intermedi\u00e1rio D, criar alguns dos sete casos de teste das Figuras 5.5 e 5.6.</p> <p>Em segundo lugar, por causa da \u201cdist\u00e2ncia\u201d entre H e o ponto em que os dados de teste entram no programa, mesmo que fosse poss\u00edvel testar todas as situa\u00e7\u00f5es, determinar quais dados alimentar para J a fim de testar essas situa\u00e7\u00f5es em H \u00e9 frequentemente uma tarefa mental complexa.</p> <p>Terceiro, como a sa\u00edda exibida de um teste pode vir de um m\u00f3dulo distante daquele que est\u00e1 sendo testado, correlacionar a sa\u00edda exibida com o que ocorreu no m\u00f3dulo-alvo pode ser dif\u00edcil ou imposs\u00edvel. Por exemplo, ao adicionar o m\u00f3dulo E \u00e0 Figura 5.10, os resultados de cada caso de teste s\u00e3o obtidos examinando a sa\u00edda escrita pelo m\u00f3dulo I, mas, devido aos m\u00f3dulos intermedi\u00e1rios, pode ser complicado deduzir a sa\u00edda real de E (isto \u00e9, os dados retornados a B).</p> <p>A estrat\u00e9gia de cima para baixo, dependendo da abordagem, pode apresentar mais dois problemas. Algumas pessoas acreditam que ela se sobrep\u00f5e \u00e0 fase de design do programa. Por exemplo, ao projetar o programa na Figura 5.8, pode-se supor que, ap\u00f3s definir os dois primeiros n\u00edveis, os m\u00f3dulos A a D possam ser codificados e testados enquanto o design dos n\u00edveis inferiores prossegue. Como enfatizado em outros locais, essa costuma ser uma decis\u00e3o imprudente. O design \u00e9 uma etapa inicial; ao projetar n\u00edveis inferiores, podem surgir mudan\u00e7as ou melhorias desej\u00e1veis nos n\u00edveis superiores. Se estes j\u00e1 tiverem sido codificados e testados, tais melhorias provavelmente ser\u00e3o descartadas, o que \u00e9 prejudicial a longo prazo.</p> <p>Um problema final, comum na pr\u00e1tica, \u00e9 n\u00e3o testar completamente um m\u00f3dulo antes de avan\u00e7ar para o pr\u00f3ximo. Isso acontece por dois motivos: pela dificuldade de incorporar dados de teste em stubs e pelo fato de os n\u00edveis superiores geralmente proverem recursos aos n\u00edveis inferiores. Na Figura 5.8, vimos que testar o m\u00f3dulo A pode exigir v\u00e1rias vers\u00f5es do stub para B. Na pr\u00e1tica, h\u00e1 quem diga: \u201cIsso d\u00e1 muito trabalho; vou postergar alguns casos de teste de A at\u00e9 incluir o m\u00f3dulo J, quando ser\u00e1 mais f\u00e1cil apresentar os dados de teste, e s\u00f3 ent\u00e3o concluirei o teste de A.\u201d O risco \u00e9 esquecer de executar todos os casos de A nessa etapa posterior. Al\u00e9m disso, como os n\u00edveis superiores costumam fornecer recursos (por exemplo, abertura de arquivos) usados pelos n\u00edveis inferiores, \u00e0s vezes s\u00f3 se percebe que um recurso n\u00e3o foi corretamente configurado (por exemplo, arquivo aberto com atributos inadequados) ao testar o m\u00f3dulo que o utiliza.</p>"},{"location":"aae3/unit_test/#teste-incremental-de-baixo-para-cima","title":"Teste incremental de baixo para cima","text":"<p>O pr\u00f3ximo passo \u00e9 examinar a estrat\u00e9gia de teste incremental de baixo para cima. Na maioria das vezes, o teste de baixo para cima \u00e9 o oposto do teste de cima para baixo; assim, as vantagens do teste de cima para baixo tornam-se desvantagens do teste de baixo para cima, e as desvantagens do teste de cima para baixo tornam-se vantagens do teste de baixo para cima. Por isso, a discuss\u00e3o sobre os testes ascendente e descendente \u00e9 mais curta.</p> <p>A estrat\u00e9gia ascendente come\u00e7a com os m\u00f3dulos terminais no programa (aqueles que n\u00e3o chamam outros m\u00f3dulos). Depois que esses m\u00f3dulos forem testados, n\u00e3o existe um procedimento \u00fanico para selecionar o pr\u00f3ximo m\u00f3dulo a ser testado incrementalmente; a \u00fanica regra \u00e9 que, para ser eleg\u00edvel, todos os m\u00f3dulos subordinados (os m\u00f3dulos que ele chama) devem ter sido testados anteriormente.</p> <p>Voltando \u00e0 Figura 5.8, o primeiro passo \u00e9 testar alguns ou todos os m\u00f3dulos E, J, G, K, L e I, em s\u00e9rie ou em paralelo. Para isso, cada m\u00f3dulo precisa de um driver especial: um m\u00f3dulo que fornece entradas de teste, chama o m\u00f3dulo em teste e exibe as sa\u00eddas (ou compara as sa\u00eddas reais com as esperadas). Ao contr\u00e1rio da situa\u00e7\u00e3o com stubs, v\u00e1rias vers\u00f5es de um driver n\u00e3o s\u00e3o necess\u00e1rias, pois o driver pode chamar iterativamente o m\u00f3dulo que est\u00e1 sendo testado. Na maioria dos casos, os drivers s\u00e3o mais f\u00e1ceis de produzir do que os stubs.</p> <p>Como mencionado anteriormente, um fator que influencia a sequ\u00eancia de testes \u00e9 a criticidade dos m\u00f3dulos. Se decidirmos que os m\u00f3dulos D e F s\u00e3o os mais cr\u00edticos, um estado intermedi\u00e1rio do teste incremental de baixo para cima pode ser o da Figura 5.11. As pr\u00f3ximas etapas podem ser testar E e, em seguida, testar B, combinando B com os m\u00f3dulos E, F e J testados anteriormente.</p> <p>Uma desvantagem da estrat\u00e9gia de baixo para cima \u00e9 que n\u00e3o existe o conceito de programa quase esquel\u00e9tico. De fato, o programa funcional n\u00e3o existe at\u00e9 que o \u00faltimo m\u00f3dulo (m\u00f3dulo A) seja adicionado, e ent\u00e3o o programa de trabalho \u00e9 o programa completo. Embora as fun\u00e7\u00f5es de E/S possam ser testadas antes que todo o programa seja integrado (os m\u00f3dulos de E/S est\u00e3o sendo usados na Figura 5.11), as vantagens do programa esquel\u00e9tico precoce n\u00e3o est\u00e3o presentes.</p> <p>Os problemas associados \u00e0 dificuldade de criar todas as situa\u00e7\u00f5es de teste na abordagem top-down n\u00e3o existem aqui. Se voc\u00ea pensar em um driver como uma sonda de teste, a sonda \u00e9 colocada diretamente no m\u00f3dulo em teste; n\u00e3o h\u00e1 m\u00f3dulos intermedi\u00e1rios para complicar a an\u00e1lise. Examinando outros problemas da abordagem de cima para baixo, voc\u00ea n\u00e3o pode tomar a decis\u00e3o imprudente de sobrepor design e teste, uma vez que o teste de baixo para cima n\u00e3o pode come\u00e7ar at\u00e9 que a parte inferior do programa tenha sido designada. Al\u00e9m disso, o problema de n\u00e3o completar o teste de um m\u00f3dulo antes de iniciar outro \u2014 devido \u00e0 dificuldade de codificar dados de teste em vers\u00f5es de um stub \u2014 n\u00e3o existe ao usar o teste de baixo para cima.</p>"},{"location":"aae3/unit_test/#uma-comparacao","title":"Uma compara\u00e7\u00e3o","text":"<p>Seria conveniente se a quest\u00e3o cima para baixo versus baixo para cima fosse t\u00e3o clara quanto incremental versus n\u00e3o incremental, mas infelizmente n\u00e3o \u00e9. A Tabela 5.3 resume as vantagens e desvantagens relativas das duas abordagens (excluindo as vantagens compartilhadas por ambas \u2014 ou seja, as do teste incremental).</p> <p>A primeira vantagem de cada abordagem pode parecer o fator decisivo, mas n\u00e3o h\u00e1 evid\u00eancias de que as principais falhas ocorram com mais frequ\u00eancia nos n\u00edveis superior ou inferior de um programa t\u00edpico. A maneira mais segura de decidir \u00e9 pesar os fatores da Tabela 5.3 em rela\u00e7\u00e3o ao programa espec\u00edfico em teste. Na falta de um programa concreto aqui, as s\u00e9rias consequ\u00eancias da quarta desvantagem do teste de cima para baixo \u2014 e a disponibilidade de ferramentas de teste que eliminam a necessidade de drivers, mas n\u00e3o de stubs \u2014 parecem dar vantagem \u00e0 estrat\u00e9gia de baixo para cima.</p> <p>Al\u00e9m disso, pode ser evidente que os testes de cima para baixo e de baixo para cima n\u00e3o s\u00e3o as \u00fanicas estrat\u00e9gias incrementais poss\u00edveis.</p>"},{"location":"aae3/unit_test/#tabela-53-comparacao-de-testes-de-cima-para-baixo-e-de-baixo-para-cima","title":"Tabela 5.3 Compara\u00e7\u00e3o de testes de cima para baixo e de baixo para cima","text":""},{"location":"aae3/unit_test/#teste-de-cima-para-baixo_1","title":"Teste de cima para baixo","text":"<p>Vantagens 1. Vantajoso quando ocorrem falhas graves no topo do programa. 2. Os m\u00f3dulos de esbo\u00e7o costumam ser mais complicados do que parecem \u00e0 primeira vista. 3. Antes que as fun\u00e7\u00f5es de E/S sejam adicionadas, a representa\u00e7\u00e3o de casos de teste pode ser dif\u00edcil. 4. As condi\u00e7\u00f5es de teste podem ser imposs\u00edveis ou muito dif\u00edceis de criar. 5. A observa\u00e7\u00e3o do resultado do teste \u00e9 mais dif\u00edcil. 6. Leva \u00e0 conclus\u00e3o de que o design e o teste podem ser sobrepostos. 7. Adia a conclus\u00e3o do teste de certos m\u00f3dulos.  </p> <p>Desvantagens 1. Devem ser produzidos m\u00f3dulos stub de topo. 2. Uma vez que as fun\u00e7\u00f5es de E/S s\u00e3o adicionadas, a representa\u00e7\u00e3o de casos \u00e9 mais f\u00e1cil. 3. O programa esquel\u00e9tico inicial permite demonstra\u00e7\u00f5es e aumenta o moral. 4. As condi\u00e7\u00f5es de teste podem ser imposs\u00edveis ou muito dif\u00edceis de criar. 5. A observa\u00e7\u00e3o do resultado do teste \u00e9 mais dif\u00edcil. 6. Leva \u00e0 conclus\u00e3o de que o design e o teste podem ser sobrepostos. 7. Adia a conclus\u00e3o do teste de certos m\u00f3dulos.  </p>"},{"location":"aae3/unit_test/#teste-de-baixo-para-cima","title":"Teste de baixo para cima","text":"<p>Vantagens 1. Vantajoso quando ocorrem falhas graves na parte inferior do programa. 2. As condi\u00e7\u00f5es de teste s\u00e3o mais f\u00e1ceis de criar. 3. A observa\u00e7\u00e3o dos resultados dos testes \u00e9 mais f\u00e1cil.  </p> <p>Desvantagens 1. Devem ser produzidos m\u00f3dulos de driver. 2. O programa, como entidade funcional, s\u00f3 existe ap\u00f3s a adi\u00e7\u00e3o do \u00faltimo m\u00f3dulo.  </p>"},{"location":"aae3/unit_test/#executando-o-teste","title":"Executando o teste","text":"<p>A parte restante do teste de m\u00f3dulo \u00e9 o ato de realmente realizar o teste. Um conjunto de dicas e diretrizes para isso est\u00e1 inclu\u00eddo aqui.</p> <p>Quando um caso de teste produz uma situa\u00e7\u00e3o em que os resultados reais do m\u00f3dulo n\u00e3o correspondem aos resultados esperados, h\u00e1 duas explica\u00e7\u00f5es poss\u00edveis: ou o m\u00f3dulo cont\u00e9m um erro, ou os resultados esperados est\u00e3o incorretos (o caso de teste est\u00e1 incorreto). Para minimizar essa confus\u00e3o, o conjunto de casos de teste deve ser revisado ou inspecionado antes que o teste seja realizado (ou seja, os casos de teste devem ser testados).</p> <p>O uso de ferramentas de teste automatizadas pode minimizar parte do trabalho penoso do processo de teste. Por exemplo, existem ferramentas que eliminam a necessidade de m\u00f3dulos de driver. Ferramentas de an\u00e1lise de fluxo enumeram os caminhos por meio de um programa, encontram instru\u00e7\u00f5es que nunca podem ser executadas (c\u00f3digo \u201cinacess\u00edvel\u201d) e identificam inst\u00e2ncias em que uma vari\u00e1vel \u00e9 usada antes de receber um valor.</p> <p>Como foi pr\u00e1tica anterior neste cap\u00edtulo, lembre-se de que definir o resultado esperado \u00e9 parte necess\u00e1ria de um caso de teste. Ao executar um teste, lembre-se de procurar efeitos colaterais (casos em que um m\u00f3dulo faz algo que n\u00e3o deveria fazer). Em geral, essas situa\u00e7\u00f5es s\u00e3o dif\u00edceis de detectar, mas algumas podem ser encontradas verificando, ap\u00f3s a execu\u00e7\u00e3o do caso de teste, as entradas para o m\u00f3dulo que n\u00e3o devem ter sido alteradas. Por exemplo, o caso de teste 7 na Figura 5.6 afirma que, como parte do resultado esperado, ESIZE, DSIZE e DEPTTAB devem permanecer inalterados. Ao executar esse caso de teste, examine n\u00e3o apenas a sa\u00edda quanto ao resultado correto, mas tamb\u00e9m ESIZE, DSIZE e DEPTTAB para verificar altera\u00e7\u00f5es indevidas.</p> <p>Os problemas psicol\u00f3gicos associados a uma pessoa que tenta testar seus pr\u00f3prios programas tamb\u00e9m se aplicam ao teste de m\u00f3dulo. Em vez de testar seus pr\u00f3prios m\u00f3dulos, os programadores podem troc\u00e1-los; mais especificamente, o programador do m\u00f3dulo de chamada \u00e9 sempre um bom candidato para testar o m\u00f3dulo chamado. Observe que isso se aplica apenas ao teste \u2014 a depura\u00e7\u00e3o de um m\u00f3dulo sempre deve ser realizada pelo programador original.</p> <p>Evite casos de teste descart\u00e1veis; represente-os de forma que possam ser reutilizados no futuro. Lembre-se do fen\u00f4meno contra-intuitivo na Figura 2.2: se for detectado um n\u00famero anormalmente elevado de erros em um subconjunto de m\u00f3dulos, \u00e9 prov\u00e1vel que esses m\u00f3dulos contenham ainda mais erros n\u00e3o detectados. Esses m\u00f3dulos devem ser submetidos a testes adicionais de m\u00f3dulo e, possivelmente, a um passo a passo ou inspe\u00e7\u00e3o de c\u00f3digo adicional.</p> <p>Por fim, lembre-se de que o objetivo de um teste de m\u00f3dulo n\u00e3o \u00e9 demonstrar que o m\u00f3dulo funciona corretamente, mas demonstrar a presen\u00e7a de erros no m\u00f3dulo.</p>"},{"location":"aae3/unit_test/#resumo","title":"Resumo","text":"<p>Neste cap\u00edtulo, apresentamos algumas das mec\u00e2nicas de teste de componentes individuais de programas \u2014 sub-rotinas, subprogramas, classes e procedimentos. No teste de m\u00f3dulo, voc\u00ea compara a funcionalidade do software com a especifica\u00e7\u00e3o que define sua fun\u00e7\u00e3o pretendida. O teste de m\u00f3dulo ou unidade pode ser uma parte importante da caixa de ferramentas de um desenvolvedor para ajudar a obter um aplicativo confi\u00e1vel, especialmente com linguagens orientadas a objetos, como Java e C#. O objetivo no teste de m\u00f3dulo \u00e9 o mesmo que em qualquer outro tipo de teste de software: tentar mostrar como o programa contradiz a especifica\u00e7\u00e3o. Al\u00e9m da especifica\u00e7\u00e3o do software, voc\u00ea precisar\u00e1 do c\u00f3digo-fonte de cada m\u00f3dulo para efetuar o teste.</p> <p>O teste de m\u00f3dulo \u00e9 em grande parte um teste de caixa branca (consulte o Cap\u00edtulo 4 para mais informa\u00e7\u00f5es). Um projeto de teste de m\u00f3dulo completo incluir\u00e1 estrat\u00e9gias incrementais, como t\u00e9cnicas de cima para baixo e de baixo para cima. \u00c9 \u00fatil, ao se preparar para um teste de m\u00f3dulo, revisar os princ\u00edpios psicol\u00f3gicos e econ\u00f4micos estabelecidos no Cap\u00edtulo 2.</p> <p>Mais um ponto: o software de teste de m\u00f3dulos \u00e9 apenas o come\u00e7o de um procedimento de teste exaustivo. Voc\u00ea precisar\u00e1 passar para o teste de ordem superior (Cap\u00edtulo 6) e o teste de usu\u00e1rio (Cap\u00edtulo 7).</p>"},{"location":"aae3/unitv2/","title":"Testes de Unidade e Testes de Integra\u00e7\u00e3o","text":""},{"location":"aae3/unitv2/#sumario","title":"Sum\u00e1rio","text":"<ol> <li>Apresenta\u00e7\u00e3o da Disciplina  </li> <li>Conceitos-Chaves  </li> <li>Pir\u00e2mide de Testes  </li> <li>Outros Formatos de Estrat\u00e9gia de Testes  </li> <li>N\u00edveis de Teste \u2013 Benef\u00edcios  </li> <li>N\u00edveis de Teste \u2013 Considera\u00e7\u00f5es  </li> </ol>"},{"location":"aae3/unitv2/#1-apresentacao-da-disciplina","title":"1. Apresenta\u00e7\u00e3o da Disciplina","text":"<p>Universidade de Bras\u00edlia Faculdade Gama Engenharia de Software</p> <p>Disciplina: <code>206580 \u2013 Testes de Software</code> Tema: Testes de Software: Testes de Unidade e Testes de Integra\u00e7\u00e3o</p> <p>Docente: Elaine Venson elainevenson@unb.br</p>"},{"location":"aae3/unitv2/#2-conceitos-chaves","title":"2. Conceitos-Chaves","text":"<p>N\u00cdVEL - Unit\u00e1rio - Integra\u00e7\u00e3o - Sistema - Aceita\u00e7\u00e3o</p> <p>OBJETIVO (tipo de testes) - Fun\u00e7\u00e3o - Seguran\u00e7a - Estresse - Usabilidade - Avalia\u00e7\u00e3o desempenho</p> <p>T\u00c9CNICA - Caixa-branca - Caixa-preta - Particionamento de equival\u00eancia - An\u00e1lise de valor limite</p> <p>AMBIENTE - mainframe - Cliente-servidor - web - outros</p> <p>Eixos - ONDE TESTAR - QUANDO TESTAR - COMO TESTAR - O QUE TESTAR  </p>"},{"location":"aae3/unitv2/#3-piramide-de-testes","title":"3. Pir\u00e2mide de Testes","text":"<p>Hierarquia de testes com base em velocidade, custo e quantidade:</p> <ul> <li>Topo (menos quantidade, maior custo, menor velocidade): </li> <li> <p>Aceita\u00e7\u00e3o</p> </li> <li> <p>Intermedi\u00e1rios: </p> </li> <li>Sistema  </li> <li> <p>Integra\u00e7\u00e3o  </p> </li> <li> <p>Base (mais quantidade, menor custo, maior velocidade): </p> </li> <li>Unidade</li> </ul> <p>Eixos laterais: - Esquerda: Velocidade (decrescente de cima para baixo) - Direita: Custo (crescente de baixo para cima) - Inferior: Quantidade (crescente da direita para a esquerda)</p>"},{"location":"aae3/unitv2/#4-outros-formatos","title":"4. Outros Formatos","text":"<p>A. The Testing Trophy - Static - Unit - Integration - End to End  </p> <p>Por Kent C. Dodds - End to end com Cypress - Integration &amp; Unit com Jest - Static com Flowtype e ESLint</p> <p>B. Microservices Test Strategy (Spotify Labs) - Integrated - Integration - Implementation Detail</p> <p>Nota: Priorizar testes de Integra\u00e7\u00e3o. Menos testes de detalhe de implementa\u00e7\u00e3o e menos ainda testes integrados (idealmente nenhum).</p>"},{"location":"aae3/unitv2/#5-niveis-de-teste-beneficios","title":"5. N\u00edveis de Teste \u2013 Benef\u00edcios","text":"<ul> <li>Evita redund\u00e2ncia de testes: cada n\u00edvel trata uma classe espec\u00edfica de defeitos.</li> <li>Aplica\u00e7\u00e3o conforme o tamanho do software:</li> <li>Software para uso do pr\u00f3prio autor \u2192 at\u00e9 n\u00edvel de integra\u00e7\u00e3o.</li> <li>Softwares comerciais em larga escala \u2192 requerem testes em n\u00edveis mais elevados.</li> </ul>"},{"location":"aae3/unitv2/#6-niveis-de-teste-consideracoes","title":"6. N\u00edveis de Teste \u2013 Considera\u00e7\u00f5es","text":"<ul> <li>Os n\u00edveis n\u00e3o s\u00e3o necessariamente sequenciais.</li> <li>As caracter\u00edsticas do sistema a ser testado ir\u00e3o determinar:</li> <li>N\u00edveis de teste  </li> <li>Tipos de testes  </li> <li>T\u00e9cnicas de deriva\u00e7\u00e3o de casos de teste</li> </ul>"},{"location":"aae3/unitv2/#7-niveis-de-teste","title":"7. N\u00edveis de Teste","text":"<ol> <li>Testes de unidade  </li> <li>Testes de integra\u00e7\u00e3o  </li> <li>Testes de fun\u00e7\u00e3o  </li> <li>Testes de sistema  </li> <li>Testes de aceita\u00e7\u00e3o</li> </ol>"},{"location":"aae3/unitv2/#8-niveis-de-teste-diagrama","title":"8. N\u00edveis de Teste \u2013 Diagrama","text":"<p>Fonte: [Myers]</p> <p>[End User] \u2193 [Requirements] \u2192 [Acceptance Test] \u2193 [Objectives] \u2192 [System Test] \u2193 [External Specification] \u2192 [Function Test] \u2193 [System Design] \u2192 [Integration Test] \u2193 [Program Structure Design] \u2193 [Module Interface Specifications] \u2192 [Module Test] \u2193 [Code]</p> <p>Esse diagrama mostra como os diferentes n\u00edveis de teste correspondem a diferentes etapas do desenvolvimento de software, desde o c\u00f3digo at\u00e9 a intera\u00e7\u00e3o com o usu\u00e1rio final.</p>"},{"location":"aae3/unitv2/#9-testes-de-unidade","title":"9. Testes de Unidade","text":"<ul> <li>Processo de testar fun\u00e7\u00f5es, m\u00e9todos, procedimentos, sub-rotinas ou subprogramas individualmente.</li> <li>Objetivo: verificar o menor elemento test\u00e1vel de um software.</li> <li>Em linguagens procedurais: pode ser uma fun\u00e7\u00e3o ou procedimento.</li> <li>Em linguagens orientadas a objeto: geralmente \u00e9 um m\u00e9todo.</li> <li>Geralmente realizado pelo desenvolvedor.</li> <li>Casos de teste com foco nos algoritmos e l\u00f3gica de programa\u00e7\u00e3o.</li> <li>Tipicamente caixa-branca, podendo ser complementado com caixa-preta.</li> </ul> <p>Motiva\u00e7\u00f5es: - Gerenciar os elementos do teste, come\u00e7ando pelo menor n\u00edvel. - Facilitar a depura\u00e7\u00e3o (identifica\u00e7\u00e3o do defeito). - Permitir paralelismo na execu\u00e7\u00e3o dos testes.</p>"},{"location":"aae3/unitv2/#10-testes-de-unidade-consideracoes","title":"10. Testes de Unidade \u2013 Considera\u00e7\u00f5es","text":"<ul> <li>Objetivo: comparar a unidade com sua especifica\u00e7\u00e3o funcional ou de interface, demonstrando que ela n\u00e3o atende a essa especifica\u00e7\u00e3o, se for o caso.</li> </ul> <p>Quest\u00f5es importantes: - Como elaborar os casos de teste? - Qual a ordem em que as unidades devem ser testadas e integradas? - Como ser\u00e1 a execu\u00e7\u00e3o dos testes?</p>"},{"location":"aae3/unitv2/#11-elaboracao-dos-casos-de-teste","title":"11. Elabora\u00e7\u00e3o dos Casos de Teste","text":"<p>Informa\u00e7\u00f5es necess\u00e1rias: - A especifica\u00e7\u00e3o da unidade (entradas e sa\u00eddas esperadas). - O c\u00f3digo-fonte da unidade.</p> <p>Procedimento: 1. Analisar o c\u00f3digo utilizando m\u00e9todos caixa-branca. 2. Complementar com casos de teste caixa-preta baseados na especifica\u00e7\u00e3o da unidade.</p>"},{"location":"aae3/unitv2/#12-exemplo-funcao-bonus","title":"12. Exemplo: fun\u00e7\u00e3o BONUS","text":"<p>Especifica\u00e7\u00e3o:</p> <ul> <li>A fun\u00e7\u00e3o <code>BONUS</code> adiciona <code>$200</code> ao sal\u00e1rio de todos os funcion\u00e1rios do(s) departamento(s) com o maior resultado de vendas.</li> <li>Se o sal\u00e1rio de um funcion\u00e1rio eleg\u00edvel for $15.000 ou mais, ou se o funcion\u00e1rio for um gerente, o b\u00f4nus \u00e9 reduzido para $100.</li> <li>Em caso de sucesso, a fun\u00e7\u00e3o retorna 0.</li> <li>Se alguma das tabelas estiver vazia, a fun\u00e7\u00e3o retorna c\u00f3digo de erro 1.</li> <li>Se nenhum funcion\u00e1rio eleg\u00edvel for encontrado, retorna c\u00f3digo de erro 2.</li> </ul>"},{"location":"aae3/unitv2/#13-exemplo-funcao-bonus-variante","title":"13. Exemplo: fun\u00e7\u00e3o BONUS (variante)","text":"<ul> <li>Especifica\u00e7\u00e3o da fun\u00e7\u00e3o BONUS:</li> <li>Adiciona \\$2 000 ao sal\u00e1rio de todos os funcion\u00e1rios no departamento ou departamentos com o maior resultado de vendas.</li> <li>Se o sal\u00e1rio de um funcion\u00e1rio eleg\u00edvel for \\$15 000 ou mais, ou se o funcion\u00e1rio for um gerente, o sal\u00e1rio \u00e9 adicionado em apenas \\$1 000.</li> <li>Retorno:</li> <li><code>0</code>: sucesso.</li> <li><code>1</code>: se ao menos uma das tabelas estiver vazia.</li> <li><code>2</code>: se a fun\u00e7\u00e3o n\u00e3o encontrar funcion\u00e1rios em um departamento eleg\u00edvel.</li> </ul>"},{"location":"aae3/unitv2/#14-primeiro-passo-listar-as-decisoes-do-programa","title":"14. Primeiro passo: listar as decis\u00f5es do programa","text":"<p>Obs.: as instru\u00e7\u00f5es <code>DO</code> n\u00e3o precisam de aten\u00e7\u00e3o especial, pois qualquer caso de teste que execute um <code>DO</code> cobrar\u00e1 ambas as ramifica\u00e7\u00f5es (entrar e pular o corpo do loop).</p>"},{"location":"aae3/unitv2/#15-relembrando-criterios-caixa-branca","title":"15. Relembrando: crit\u00e9rios caixa-branca","text":"<ul> <li>Cobertura de instru\u00e7\u00f5es  </li> <li>Cobertura de decis\u00f5es  </li> <li>Cobertura de condi\u00e7\u00f5es  </li> <li>Cobertura de decis\u00f5es-condi\u00e7\u00f5es  </li> <li>Cobertura de m\u00faltiplas condi\u00e7\u00f5es  </li> </ul>"},{"location":"aae3/unitv2/#16-cobertura-de-decisoes","title":"16. Cobertura de decis\u00f5es","text":"Decis\u00e3o Situa\u00e7\u00e3o para True Situa\u00e7\u00e3o para False 2 <code>ESIZE \u2264 0</code> ou <code>DSIZE \u2264 0</code> <code>ESIZE &gt; 0</code> e <code>DSIZE &gt; 0</code> 6 Vai sempre ocorrer pelo menos uma vez (ordenar DEPTTAB para que um dept. menor em vendas venha depois) 9 Vai sempre ocorrer pelo menos uma vez (departamentos com vendas diferentes) 13 H\u00e1 um empregado em um departamento eleg\u00edvel H\u00e1 um empregado em um departamento n\u00e3o eleg\u00edvel 16 Um empregado de dept. eleg\u00edvel \u00e9 gerente ou recebe \u2265 <code>LSALARY</code> Um empregado de dept. eleg\u00edvel n\u00e3o \u00e9 gerente e recebe &lt; <code>LSALARY</code> 21 Um departamento eleg\u00edvel n\u00e3o cont\u00e9m empregados Um departamento eleg\u00edvel cont\u00e9m ao menos um empregado"},{"location":"aae3/unitv2/#17-cobertura-de-decisoes-continuacao","title":"17. Cobertura de decis\u00f5es (continua\u00e7\u00e3o)","text":"<ul> <li>Elaborar casos de teste suficientes para invocar ambos os resultados de cada uma das decis\u00f5es.  </li> <li>Como duas situa\u00e7\u00f5es (decis\u00f5es 6 e 9) sempre ocorrem, s\u00e3o 10 situa\u00e7\u00f5es que precisam ser consideradas.</li> </ul>"},{"location":"aae3/unitv2/#18-cobertura-de-condicoes","title":"18. Cobertura de condi\u00e7\u00f5es","text":"D Condi\u00e7\u00e3o Situa\u00e7\u00e3o para True Situa\u00e7\u00e3o para False 2 <code>ESIZE \u2264 0</code> <code>ESIZE \u2264 0</code> <code>ESIZE &gt; 0</code> 2 <code>DSIZE \u2264 0</code> <code>DSIZE \u2264 0</code> <code>DSIZE &gt; 0</code> 6 <code>SALES(I) \u2265 MAXSALES</code> Vai sempre ocorrer pelo menos uma vez (ordenar DEPTTAB\u2026) 9 <code>SALES(J) = MAXSALES</code> Vai sempre ocorrer pelo menos uma vez (departamentos com vendas diferentes) 13 <code>EMPTAB.DEPT(K) = DEPTTAB.DEPT(J)</code> H\u00e1 um empregado em um departamento eleg\u00edvel H\u00e1 um empregado em um departamento n\u00e3o eleg\u00edvel 16 <code>SALARY(K) \u2265 LSALARY</code> Empregado de dept. eleg\u00edvel recebe \u2265 <code>LSALARY</code> Empregado de dept. eleg\u00edvel recebe &lt; <code>LSALARY</code> 16 <code>CODE(K) = MGR</code> Empregado de dept. eleg\u00edvel \u00e9 gerente Empregado de dept. eleg\u00edvel n\u00e3o \u00e9 gerente 21 <code>\u00acFOUND</code> Um departamento eleg\u00edvel n\u00e3o cont\u00e9m empregados Um departamento eleg\u00edvel cont\u00e9m ao menos um empregado"},{"location":"aae3/unitv2/#19-cobertura-de-condicoes-continuacao","title":"19. Cobertura de condi\u00e7\u00f5es (continua\u00e7\u00e3o)","text":"<ul> <li>Elaborar casos de teste suficientes para invocar ambos os resultados de cada condi\u00e7\u00e3o em cada decis\u00e3o.  </li> <li>Apenas decis\u00f5es 2 e 16 possuem mais de uma condi\u00e7\u00e3o.  </li> <li>Como duas situa\u00e7\u00f5es v\u00e3o sempre ocorrer, s\u00e3o 14 situa\u00e7\u00f5es que precisam ser consideradas.</li> </ul>"},{"location":"aae3/unitv2/#20-cobertura-de-decisoescondicoes","title":"20. Cobertura de decis\u00f5es/condi\u00e7\u00f5es","text":"<ul> <li>A cobertura combinada decis\u00f5es/condi\u00e7\u00f5es elimina a maioria das fraquezas dos casos de teste baseados apenas em condi\u00e7\u00f5es.  </li> <li>Todos os resultados de todas as condi\u00e7\u00f5es E de todas as decis\u00f5es seriam considerados.  </li> <li>Exemplo: Para a decis\u00e3o 16 gerar ambos resultados, bastaria fazer um funcion\u00e1rio eleg\u00edvel gerente e outro n\u00e3o gerente.  </li> <li>Observa\u00e7\u00e3o: se o compilador usa short-circuit para <code>OR</code>, a condi\u00e7\u00e3o <code>CODE(K)=MGR</code> nunca seria avaliada para <code>TRUE</code> se o primeiro termo j\u00e1 for <code>TRUE</code>.</li> </ul>"},{"location":"aae3/unitv2/#21-cobertura-mcdc","title":"21. Cobertura MC/DC","text":"<ul> <li>Objetivo: cada condi\u00e7\u00e3o que afeta independentemente o resultado de uma decis\u00e3o deve assumir todos os valores poss\u00edveis pelo menos uma vez.</li> </ul> D Condi\u00e7\u00e3o Situa\u00e7\u00e3o para True Situa\u00e7\u00e3o para False 2 <code>ESIZE \u2264 0</code> 2 <code>DSIZE \u2264 0</code> 6 <code>SALES(I) \u2265 MAXSALES</code> 9 <code>SALES(J) = MAXSALES</code> 13 <code>EMPTAB.DEPT(K) = DEPTTAB.DEPT(J)</code> 16 <code>SALARY(K) \u2265 LSALARY</code> 16 <code>CODE(K) = MGR</code> 21 <code>\u00acFOUND</code>"},{"location":"aae3/unitv2/#22-cobertura-mcdc-continuacao","title":"22. Cobertura MC/DC (continua\u00e7\u00e3o)","text":"<ul> <li>Decis\u00f5es 2 e 16 t\u00eam duas condi\u00e7\u00f5es \u2192 s\u00e3o necess\u00e1rios 3 casos de teste cada (n\u00ba de condi\u00e7\u00f5es + 1).  </li> <li>Decis\u00e3o 2:</li> <li>(V F) \u2192 V  \u00a0 e \u00a0 (F F) \u2192 F  </li> <li>(F V) \u2192 V  \u00a0 e \u00a0 (F F) \u2192 F  </li> <li>Decis\u00e3o 16:</li> <li>(V F) \u2192 V  \u00a0 e \u00a0 (F F) \u2192 F  </li> <li>(F V) \u2192 V  \u00a0 e \u00a0 (F F) \u2192 F  </li> </ul>"},{"location":"aae3/unitv2/#23-cobertura-de-multiplas-condicoes","title":"23. Cobertura de m\u00faltiplas condi\u00e7\u00f5es","text":"<ul> <li>Defini\u00e7\u00e3o: invocar todas as combina\u00e7\u00f5es poss\u00edveis de condi\u00e7\u00f5es em cada decis\u00e3o pelo menos uma vez.  </li> <li>Decis\u00f5es 6, 9, 13 e 21 \u2192 2 combina\u00e7\u00f5es cada.  </li> <li>Decis\u00f5es 2 e 16 \u2192 4 combina\u00e7\u00f5es cada.  </li> </ul> D Condi\u00e7\u00e3o Situa\u00e7\u00e3o para True Situa\u00e7\u00e3o para False 2 <code>ESIZE \u2264 0</code> 2 <code>DSIZE \u2264 0</code> \u2026 \u2026 \u2026 \u2026 16 <code>CODE(K) = MGR</code> 21 <code>\u00acFOUND</code>"},{"location":"aae3/unitv2/#24-cobertura-de-multiplas-condicoes-continuacao","title":"24. Cobertura de m\u00faltiplas condi\u00e7\u00f5es (continua\u00e7\u00e3o)","text":"<ul> <li>Alguns problemas permanecem:</li> <li>Retorno = 0 n\u00e3o testado.  </li> <li>Defeitos de inicializa\u00e7\u00e3o de vari\u00e1veis (ex.: <code>LSALARY = 15000.01</code>) podem passar despercebidos.  </li> <li>Compara\u00e7\u00f5es (ex.: <code>&gt;</code> vs <code>\u2265</code>) podem n\u00e3o ser detectadas.  </li> <li>Defeitos ao acessar o \u00faltimo registro das tabelas n\u00e3o seriam detectados.  </li> <li>Conclus\u00e3o: cobertura de m\u00faltiplas condi\u00e7\u00f5es \u00e9 superior a outros crit\u00e9rios, mas n\u00e3o suficiente isoladamente.</li> </ul>"},{"location":"aae3/unitv2/#25-exemplo-funcao-bonus-proximos-passos-caixa-preta","title":"25. Exemplo: fun\u00e7\u00e3o BONUS \u2013 Pr\u00f3ximos passos (caixa-preta)","text":"<p>Valores de entrada (an\u00e1lise de valor limite): 1. <code>EMPTAB</code> tem 1 registro. 2. <code>EMPTAB</code> tem o n\u00famero m\u00e1ximo de registros. 3. <code>EMPTAB</code> tem 0 registros. 4. <code>DEPTTAB</code> tem 1 registro. 5. <code>DEPTTAB</code> tem o n\u00famero m\u00e1ximo de registros. 6. <code>DEPTTAB</code> tem 0 registros. 7. Departamento eleg\u00edvel com 1 funcion\u00e1rio. 8. Departamento eleg\u00edvel com n\u00famero m\u00e1ximo de funcion\u00e1rios. 9. Departamento eleg\u00edvel sem funcion\u00e1rios. 10. Todos os departamentos t\u00eam o mesmo valor de venda. 11. Departamento eleg\u00edvel \u00e9 a primeira entrada em <code>DEPTTAB</code>. 12. Departamento eleg\u00edvel \u00e9 a \u00faltima entrada em <code>DEPTTAB</code>. 13. Funcion\u00e1rio eleg\u00edvel \u00e9 a primeira entrada em <code>EMPTAB</code>. 14. Funcion\u00e1rio eleg\u00edvel \u00e9 a \u00faltima entrada em <code>EMPTAB</code>. 15. Funcion\u00e1rio eleg\u00edvel \u00e9 gerente. 16. Funcion\u00e1rio eleg\u00edvel n\u00e3o \u00e9 gerente. 17. Funcion\u00e1rio eleg\u00edvel (n\u00e3o gerente) recebe \\$ 14 999,99. 18. Funcion\u00e1rio eleg\u00edvel (n\u00e3o gerente) recebe \\$ 15 000. 19. Funcion\u00e1rio eleg\u00edvel (n\u00e3o gerente) recebe \\$ 15 000,01.  </p> <p>Limites de sa\u00edda: 20. <code>ERRCODE = 0</code> 21. <code>ERRCODE = 1</code> 22. <code>ERRCODE = 2</code> 23. Sal\u00e1rio aumentado = \\$ 299 999,99  </p> <p>Baseado em Error-Guessing: 24. Dois departamentos com vendas m\u00e1ximas, um sem funcion\u00e1rios seguido por outro com funcion\u00e1rios.</p>"},{"location":"aae3/unitv2/#26-refino-dos-casos-de-teste-caixa-preta","title":"26. Refino dos casos de teste caixa-preta","text":"<ol> <li>Excluir situa\u00e7\u00f5es impratic\u00e1veis (ex.: situa\u00e7\u00f5es 2, 5, 8).  </li> <li>Confrontar situa\u00e7\u00f5es remanescentes com casos j\u00e1 existentes para identificar valor-limite n\u00e3o cobertos (situa\u00e7\u00f5es 1, 4, 7, 10, 14, 17, 18, 19, 20, 23, 24).  </li> <li>Adicionar novos casos (menor conjunto necess\u00e1rio).   <p>Obs.: n\u00e3o alterar casos existentes para n\u00e3o comprometer cobertura.</p> </li> </ol>"},{"location":"aae3/unitv2/#27-a-ordem-dos-testes","title":"27. A ordem dos testes","text":"<ul> <li>Teste N\u00e3o-Incremental: cada unidade testada isoladamente.  </li> <li>Teste Incremental: combinar com unidades j\u00e1 testadas:</li> <li>Bottom-up </li> <li>Top-down</li> </ul>"},{"location":"aae3/unitv2/#28-a-ordem-dos-testes-de-unidade-comparacao","title":"28. A ordem dos testes de unidade \u2013 Compara\u00e7\u00e3o","text":"Crit\u00e9rio N\u00e3o-incremental Incremental Esfor\u00e7o Mais (criar drivers &amp; stubs) Menos (reusar unidades testadas) Tempo de execu\u00e7\u00e3o Menor Maior Paralelismo Maior Menor Defeitos de integra\u00e7\u00e3o Descobertos tardiamente Detectados mais cedo Depura\u00e7\u00e3o Mais dif\u00edcil Mais f\u00e1cil"},{"location":"aae3/unitv2/#29-a-execucao-dos-testes","title":"29. A execu\u00e7\u00e3o dos testes","text":"<ul> <li>A sa\u00edda esperada faz parte do caso de teste. Discrep\u00e2ncias podem apontar:</li> <li>Defeito na unidade.  </li> <li>Expectativa de sa\u00edda incorreta.  </li> <li>Verificar efeitos colaterais inesperados (valores alterados indevidamente).  </li> <li>Ferramentas de teste podem automatizar:</li> <li>Gera\u00e7\u00e3o de drivers.  </li> <li>An\u00e1lise de fluxo.  </li> </ul>"},{"location":"aae3/unitv2/#30-a-execucao-dos-testes-continuacao","title":"30. A execu\u00e7\u00e3o dos testes (continua\u00e7\u00e3o)","text":"<ul> <li>Desenvolvedores podem trocar as unidades testadas para facilitar.  </li> <li>Evitar casos de teste descart\u00e1veis; torn\u00e1-los reutiliz\u00e1veis.  </li> <li>Se muitos defeitos s\u00e3o encontrados em uma unidade, testar ainda mais.  </li> <li>Lembrar: objetivo n\u00e3o \u00e9 provar que funciona, mas demonstrar defeitos.</li> </ul>"},{"location":"aae3/unitv2/#31-testes-de-integracao-definicoes","title":"31. Testes de Integra\u00e7\u00e3o \u2013 Defini\u00e7\u00f5es","text":"<ol> <li>Garantir que componentes funcionem corretamente quando combinados.  </li> <li>Detectar defeitos nas especifica\u00e7\u00f5es das interfaces dos componentes integrados.</li> </ol>"},{"location":"aae3/unitv2/#32-testes-de-integracao-caracteristicas","title":"32. Testes de Integra\u00e7\u00e3o \u2013 Caracter\u00edsticas","text":"<ol> <li>Normalmente incremental.  </li> <li>Testa partes do sistema e ent\u00e3o as integra at\u00e9 completar o produto.  </li> <li>Estrat\u00e9gias: top-down, bottom-up ou mista, baseadas em acoplamento/coes\u00e3o.</li> </ol>"},{"location":"aae3/unitv2/#33-testes-de-integracao-drivers-e-stubs","title":"33. Testes de Integra\u00e7\u00e3o \u2013 Drivers e Stubs","text":"<ul> <li>Quando nem todos os componentes est\u00e3o dispon\u00edveis:</li> <li>Criar Drivers e Stubs para simular funcionamento e interfaces.</li> </ul>"},{"location":"aae3/unitv2/#34-testes-de-integracao-stub","title":"34. Testes de Integra\u00e7\u00e3o \u2013 Stub","text":"<ul> <li>Stub (esbo\u00e7o de m\u00e9todo):  </li> <li>Substitui componente n\u00e3o operacional.  </li> <li>N\u00e3o implementa l\u00f3gica, apenas responde a entradas predefinidas.  </li> <li>Rela\u00e7\u00e3o est\u00edmulo/resposta programada.</li> </ul>"},{"location":"aae3/unitv2/#35-testes-de-integracao-motivacoes-para-drivers-e-stubs","title":"35. Testes de Integra\u00e7\u00e3o \u2013 Motiva\u00e7\u00f5es para Drivers e Stubs","text":"<ul> <li>Componente em desenvolvimento ou n\u00e3o implementado.  </li> <li>Componente com muitos defeitos que bloqueiam testes.  </li> <li>Componentes que dificultam testes (autentica\u00e7\u00e3o, janela de tempo, etc.).  </li> <li>Componentes que tornam os testes lentos (ex.: inicializa\u00e7\u00e3o de BD).  </li> <li>Provocar situa\u00e7\u00f5es excepcionais (erros de rede, falta de espa\u00e7o em disco).</li> </ul>"},{"location":"aae3/unitv2/#36-testes-de-integracao-estrategia-top-down","title":"36. Testes de Integra\u00e7\u00e3o \u2013 Estrat\u00e9gia Top-Down","text":"<ul> <li>Inicia hierarquia pelos n\u00edveis mais altos de controle.  </li> <li>Requer stubs para substituir componentes ainda n\u00e3o integrados.</li> </ul>"},{"location":"aae3/unitv2/#37-testes-de-integracao-diretrizes-top-down","title":"37. Testes de Integra\u00e7\u00e3o \u2013 Diretrizes Top-Down","text":"<ul> <li>Priorizar unidades cr\u00edticas.  </li> <li>Priorizar unidades que implementam E/S de dados (simplificar cria\u00e7\u00e3o e verifica\u00e7\u00e3o de casos).</li> </ul>"},{"location":"aae3/unitv2/#38-testes-de-integracao-vantagens-top-down","title":"38. Testes de Integra\u00e7\u00e3o \u2013 Vantagens Top-Down","text":"<ul> <li>Detecta erros de fatores humanos cedo.  </li> <li>Permite apresentar vers\u00e3o inicial ao usu\u00e1rio.  </li> <li>Confirma solidez da arquitetura.  </li> <li>Eleva a moral da equipe.</li> </ul>"},{"location":"aae3/unitv2/#39-testes-de-integracao-problemas-top-down","title":"39. Testes de Integra\u00e7\u00e3o \u2013 Problemas Top-Down","text":"<ul> <li>Dificuldade em representar casos de m\u00f3dulos nos n\u00edveis mais baixos.  </li> <li>Dif\u00edcil correlacionar sa\u00edda com resultados de unidades distantes.  </li> <li>Mudan\u00e7as nos m\u00f3dulos do topo exigem retrabalho.  </li> <li>Risco de esquecer testes no topo ap\u00f3s criar stubs.</li> </ul>"},{"location":"aae3/unitv2/#40-testes-de-integracao-estrategia-bottom-up","title":"40. Testes de Integra\u00e7\u00e3o \u2013 Estrat\u00e9gia Bottom-Up","text":"<ul> <li>Inicia pelos componentes de n\u00edveis mais baixos, subindo na hierarquia.  </li> <li>Requer drivers para substituir componentes ainda n\u00e3o integrados.</li> </ul>"},{"location":"aae3/unitv2/#41-testes-de-integracao-drivers","title":"41. Testes de Integra\u00e7\u00e3o \u2013 Drivers","text":"<ul> <li>Disparam testes, fornecem dados, controlam execu\u00e7\u00e3o e relatam resultados.  </li> <li>Controlam execu\u00e7\u00e3o de um ou mais testes, passando informa\u00e7\u00f5es ao componente alvo.  </li> <li>Vantagens: </li> <li>Geralmente mais f\u00e1ceis de implementar que stubs.  </li> <li>N\u00e3o precisam de m\u00faltiplas vers\u00f5es.</li> </ul>"},{"location":"aae3/unitv2/#42-referencias","title":"42. Refer\u00eancias","text":"<ul> <li>Myers, G. J. et al. The Art of Software Testing. John Wiley &amp; Sons, 2012. (Cap. 5)</li> </ul>"},{"location":"aae3/unitv3/","title":"Teste de Unidade v3","text":""},{"location":"aae3/unitv3/#3-piramide-de-testes","title":"3. Pir\u00e2mide de Testes","text":"<p>A Pir\u00e2mide de Testes ilustra como equilibrar velocidade, custo e cobertura ao estruturar sua su\u00edte de testes (Meszaros, 2007):</p> <p></p> N\u00edvel Quantidade de Testes Custo por Teste Velocidade de Execu\u00e7\u00e3o Exemplos de Ferramentas Aceita\u00e7\u00e3o Baixa Alto Muito Lenta Cucumber, Robot Framework Sistema M\u00e9dia M\u00e9dio Lenta Selenium, TestComplete Integra\u00e7\u00e3o M\u00e9dia\u2013Alta Baixo\u2013M\u00e9dio Moderada Pytest + Docker Compose, Postman Unidade Alta Baixo Muito R\u00e1pida pytest, unittest, Jest <ul> <li>Unidade (base) </li> <li>O que: Testes de fun\u00e7\u00e3o/m\u00e9todo isolado.  </li> <li>Por que: R\u00e1pidos e baratos; detectam defeitos de l\u00f3gica interna antes de integrar depend\u00eancias.  </li> <li>Integra\u00e7\u00e3o (camada intermedi\u00e1ria) </li> <li>O que: Testes de m\u00faltiplos m\u00f3dulos funcionando juntos (por exemplo, servi\u00e7o + banco de dados).  </li> <li>Por que: Verifica contratos/interfaces, detecta erros de comunica\u00e7\u00e3o e configura\u00e7\u00e3o.  </li> <li>Sistema (\u00faltima camada antes da aceita\u00e7\u00e3o) </li> <li>O que: Testes fim-a-fim que exercitam todo o sistema em ambiente real ou simulado.  </li> <li>Por que: Confirma fluxo completo (UI \u2192 backend \u2192 DB), mas custa mais manter.  </li> <li>Aceita\u00e7\u00e3o (topo) </li> <li>O que: Valida\u00e7\u00e3o contra requisitos de neg\u00f3cio por meio de cen\u00e1rios escritos em linguagem natural.  </li> <li>Por que: Garante que o software atenda \u00e0s expectativas do usu\u00e1rio, mas demora para rodar.</li> </ul> <p>Eixos - Velocidade: decresce de unidades \u2192 aceita\u00e7\u00e3o. - Custo: cresce de unidades \u2192 aceita\u00e7\u00e3o. - Quantidade: cresce de aceita\u00e7\u00e3o \u2192 unidades.</p>"},{"location":"aae3/unitv3/#4-outros-formatos-de-estrategia","title":"4. Outros Formatos de Estrat\u00e9gia","text":""},{"location":"aae3/unitv3/#a-the-testing-trophy","title":"A. The Testing Trophy","text":"<p>Desenvolvida por Kent C. Dodds para aplica\u00e7\u00f5es web modernas:</p> <p></p> <ul> <li>Static: detec\u00e7\u00e3o de erros sem execu\u00e7\u00e3o (ESLint, mypy).  </li> <li>Unit: l\u00f3gica interna (Jest, pytest).  </li> <li>Integration: contratos entre m\u00f3dulos (Testing Library, pytest-docker).  </li> <li>End to End: simula\u00e7\u00e3o completa de usu\u00e1rio (Cypress, Playwright).   <p>Meta: Keep static and unit tests em larga quantidade, reduzindo gradualmente at\u00e9 E2E (Dodds, 2020).</p> </li> </ul>"},{"location":"aae3/unitv3/#b-microservices-test-strategy","title":"B. Microservices Test Strategy","text":"<p>Abordagem do Spotify Labs para arquiteturas de microsservi\u00e7os:</p> <ol> <li>Implementation Detail: validar l\u00f3gica isolada de cada servi\u00e7o (testes de unidade profundas).  </li> <li>Integration: testar comunica\u00e7\u00e3o entre pares de servi\u00e7os (contratos de API).  </li> <li>Integrated: executar conjunto completo de microsservi\u00e7os simulando produ\u00e7\u00e3o (fluxos end-to-end).   <p>Recomenda\u00e7\u00e3o: minimizar testes de detalhe interno, focar em Integration e Integrated (Spotify Labs, 2019).</p> </li> </ol>"},{"location":"aae3/unitv3/#5-niveis-de-teste-beneficios","title":"5. N\u00edveis de Teste \u2013 Benef\u00edcios","text":"<ol> <li>Evita redund\u00e2ncia </li> <li>Cada n\u00edvel foca em diferentes categorias de defeitos (Myers et al., 2012).  </li> <li>Custo x Risco </li> <li>Detectar cedo (unidade) corrige barato; detectar tarde (aceita\u00e7\u00e3o) corrige caro.  </li> <li>Escalabilidade </li> <li>Pequenos projetos podem parar em integra\u00e7\u00e3o; projetos cr\u00edticos devem chegar \u00e0 aceita\u00e7\u00e3o.  </li> </ol>"},{"location":"aae3/unitv3/#6-niveis-de-teste-consideracoes","title":"6. N\u00edveis de Teste \u2013 Considera\u00e7\u00f5es","text":"<ul> <li>N\u00e3o s\u00e3o sequenciais: escolha n\u00edveis conforme risco, or\u00e7amento e complexidade do projeto.  </li> <li>Fatores a influenciar a estrat\u00e9gia: </li> <li>Grau de acoplamento e coes\u00e3o do sistema.  </li> <li>Frequ\u00eancia de mudan\u00e7as nos componentes.  </li> <li>Recursos de infraestrutura (tempo de build, ambientes de teste).  </li> </ul>"},{"location":"aae3/unitv3/#7-diagrama-de-correspondencia-de-niveis","title":"7. Diagrama de Correspond\u00eancia de N\u00edveis","text":""},{"location":"aae3/unitv3/#8-lista-de-niveis-de-teste","title":"8. Lista de N\u00edveis de Teste","text":"<ol> <li>Unidade \u2013 testar o menor bloco de c\u00f3digo isoladamente.  </li> <li>Integra\u00e7\u00e3o \u2013 validar a intera\u00e7\u00e3o entre m\u00f3dulos.  </li> <li>Fun\u00e7\u00e3o \u2013 foco em funcionalidades discretas, similar a testes de sistema menores.  </li> <li>Sistema \u2013 testes de ponta a ponta num ambiente completo.  </li> <li>Aceita\u00e7\u00e3o \u2013 valida\u00e7\u00e3o contra crit\u00e9rios de aceite do cliente.</li> </ol>"},{"location":"aae3/unitv3/#9-testes-de-unidade","title":"9. Testes de Unidade","text":"<p>Defini\u00e7\u00e3o (Myers, 2012): Processo de testar fun\u00e7\u00f5es, m\u00e9todos, procedimentos, sub-rotinas ou subprogramas individualmente, garantindo que cada unidade isolada se comporte conforme a especifica\u00e7\u00e3o.</p> <ul> <li>Objetivo: verificar o menor elemento test\u00e1vel de um software.  </li> <li>Procedural: fun\u00e7\u00e3o ou procedimento.  </li> <li>Orientado a objeto: m\u00e9todo de classe.  </li> <li>Respons\u00e1vel: geralmente o desenvolvedor.  </li> <li>Enfoque: algoritmos e l\u00f3gica de programa\u00e7\u00e3o.  </li> <li>T\u00e9cnicas: tipicamente caixa-branca, complementada por caixa-preta.</li> </ul> <p>Motiva\u00e7\u00f5es: - Gerenciar incrementalmente os elementos do teste. - Facilitar a depura\u00e7\u00e3o (localiza\u00e7\u00e3o de defeitos). - Permitir paralelismo na execu\u00e7\u00e3o dos testes.</p>"},{"location":"aae3/unitv3/#91-ferramentas-em-python","title":"9.1. Ferramentas em Python","text":"Ferramenta Caracter\u00edsticas Refer\u00eancia <code>unittest</code> Framework padr\u00e3o, estilo xUnit. Python Software Foundation (2024). <code>pytest</code> Sintaxe concisa, fixtures, parametriza\u00e7\u00e3o e plugins. pytest Documentation (2024). <code>coverage.py</code> Medi\u00e7\u00e3o de cobertura de c\u00f3digo. Ned Batchelder (2024)."},{"location":"aae3/unitv3/#92-exemplo-simples-funcao-is_even","title":"9.2. Exemplo Simples: Fun\u00e7\u00e3o <code>is_even</code>","text":"<pre><code># utils.py\ndef is_even(n: int) -&gt; bool:\n    \"\"\"\n    Retorna True se n for par, False caso contr\u00e1rio.\n    \"\"\"\n    return n % 2 == 0\n</code></pre>"},{"location":"aae3/unitv3/#921-testes-com-pytest","title":"9.2.1. Testes com <code>pytest</code>","text":"<pre><code># tests/test_utils.py\nimport pytest\nfrom utils import is_even\n\n@pytest.mark.parametrize(\"input,expected\", [\n    (0, True),\n    (1, False),\n    (2, True),\n    (99, False),\n])\ndef test_is_even(input, expected):\n    assert is_even(input) == expected\n</code></pre> <ul> <li>Casos de teste:</li> <li><code>0</code> \u2192 <code>True</code></li> <li><code>1</code> \u2192 <code>False</code></li> <li><code>2</code> \u2192 <code>True</code></li> <li><code>99</code> \u2192 <code>False</code></li> </ul>"},{"location":"aae3/unitv3/#922-teste-caixa-branca-cobertura-de-decisao","title":"9.2.2. Teste Caixa-Branca (Cobertura de Decis\u00e3o)","text":"<pre><code>def test_is_even_branches():\n    # testa tanto o ramo True quanto o ramo False\n    assert is_even(4) is True\n    assert is_even(5) is False\n</code></pre> <ul> <li>Com isso garantimos que ambas as sa\u00eddas (<code>True</code> e <code>False</code>) ocorram ao menos uma vez.</li> </ul>"},{"location":"aae3/unitv3/#93-criterios-de-cobertura","title":"9.3. Crit\u00e9rios de Cobertura","text":"Crit\u00e9rio Descri\u00e7\u00e3o Cobertura de decis\u00f5es Garante que <code>n % 2 == 0</code> avalie <code>True</code> e <code>False</code> Cobertura de instru\u00e7\u00f5es Garante execu\u00e7\u00e3o da \u00fanica linha da fun\u00e7\u00e3o <pre><code># Gerando relat\u00f3rio de cobertura\ncoverage run -m pytest &amp;&amp; coverage report -m\n</code></pre> <pre><code>Name           Stmts   Miss  Cover\n----------------------------------\nutils.py           3      0   100%\n</code></pre>"},{"location":"aae3/unitv3/#10-testes-de-unidade-consideracoes","title":"10. Testes de Unidade \u2013 Considera\u00e7\u00f5es","text":"<ul> <li>Objetivo: comparar a fun\u00e7\u00e3o <code>is_even</code> com sua especifica\u00e7\u00e3o, demonstrando que ela retorna <code>True</code> somente para n\u00fameros pares e <code>False</code> para \u00edmpares.  </li> <li>Escopo dos testes: </li> <li>Entradas v\u00e1lidas (n\u00fameros inteiros \u2265 0 e &lt; 1000, por exemplo).  </li> <li>Entradas negativas ou tipos incorretos (ex.: strings) para validar robustez.  </li> <li>Quest\u00f5es fundamentais: </li> <li>Como representar valores-limite? (0, 1, maior inteiro par dentro do intervalo)  </li> <li>Como testaremos comportamentos inesperados? (valores negativos, tipos errados)  </li> <li>Como automatizar e integrar ao CI?</li> </ul>"},{"location":"aae3/unitv3/#11-elaboracao-dos-casos-de-teste","title":"11. Elabora\u00e7\u00e3o dos Casos de Teste","text":"<p>Especifica\u00e7\u00e3o da fun\u00e7\u00e3o <code>is_even(n: int) -&gt; bool</code>: - Retorna <code>True</code> se <code>n % 2 == 0</code>. - Retorna <code>False</code> caso contr\u00e1rio.  </p>"},{"location":"aae3/unitv3/#procedimento","title":"Procedimento","text":"<ol> <li>An\u00e1lise caixa-preta: </li> <li>Identificar classes de equival\u00eancia:  <ul> <li>Pares: {..., 0, 2, 4, ...}  </li> <li>\u00cdmpares: {..., 1, 3, 5, ...}  </li> </ul> </li> <li> <p>Valores-limite:  </p> <ul> <li>0 (menor par n\u00e3o-negativo)  </li> <li>1 (menor \u00edmpar)  </li> <li>999 (maior \u00edmpar dentro do intervalo)  </li> <li>1000 (maior par dentro do intervalo)  </li> </ul> </li> <li> <p>An\u00e1lise caixa-branca: </p> </li> <li>Verificar a opera\u00e7\u00e3o <code>% 2</code>: deve executar divis\u00e3o e resto.  </li> <li> <p>Cobertura de decis\u00f5es: ambos os caminhos (<code>== 0</code> True/False).</p> </li> <li> <p>Documenta\u00e7\u00e3o em tabela de decis\u00e3o:</p> </li> </ol> Caso Entrada Sa\u00edda Esperada Tipo C1 n = 0 True Caixa-preta C2 n = 1 False Caixa-preta C3 n = 2 True Caixa-preta C4 n = 999 False Caixa-preta C5 n = 1000 True Caixa-preta C6 n = -1 Error/TypeError Caixa-preta C7 n = 'a' TypeError Caixa-preta C8 n = 4 True Caixa-branca C9 n = 5 False Caixa-branca <ol> <li>Implementa\u00e7\u00e3o dos testes: </li> <li>Usar <code>pytest</code> para casos de equival\u00eancia e limites.  </li> <li> <p>Usar <code>pytest.raises</code> para tipos incorretos.  </p> </li> <li> <p>Execu\u00e7\u00e3o e relat\u00f3rio de cobertura: </p> </li> </ol> <pre><code>pytest --maxfail=1 --disable-warnings -q\ncoverage run -m pytest &amp;&amp; coverage report -m\n</code></pre>"},{"location":"aae3/unitv3/#12-referencias-bibliograficas","title":"12. Refer\u00eancias Bibliogr\u00e1ficas","text":"<ul> <li>Myers, G. J., Sandler, C., &amp; Badgett, T. (2012). The Art of Software Testing. John Wiley &amp; Sons.  </li> <li>pytest Development Team. (2024). pytest documentation. Retrieved from https://docs.pytest.org/  </li> <li>Ned Batchelder. (2024). coverage.py documentation. Retrieved from https://coverage.readthedocs.io/  </li> <li>Meszaros, G. (2007). xUnit Test Patterns: Refactoring Test Code. Addison-Wesley.  </li> <li>Dodds, K. C. (2020). The Testing Trophy.  </li> <li>Spotify Labs. (2019). Microservices Test Strategy</li> </ul>"},{"location":"aae3/white_box_test/","title":"Cap\u00edtulo 4 \u2013  Teste de Caixa Branca","text":"<p>Outra estrat\u00e9gia de teste, o teste de caixa branca (ou orientado por l\u00f3gica), permite que voc\u00ea examine a estrutura interna do programa. Essa estrat\u00e9gia deriva dados de teste de um exame da l\u00f3gica do programa (e muitas vezes, infelizmente, negligenciando a especifica\u00e7\u00e3o).</p> <p>O objetivo neste ponto \u00e9 estabelecer, para esta estrat\u00e9gia, o teste de entrada an\u00e1logo ao exaustivo na abordagem de caixa preta. Fazer com que todas as instru\u00e7\u00f5es do programa sejam executadas pelo menos uma vez pode parecer ser a resposta, mas n\u00e3o \u00e9 dif\u00edcil mostrar que isso \u00e9 altamente inadequado. Sem insistir no ponto aqui, uma vez que esse assunto \u00e9 discutido com mais profundidade no Cap\u00edtulo 4, o an\u00e1logo geralmente \u00e9 considerado um teste de caminho exaustivo. Ou seja, se voc\u00ea executar, via casos de teste, todos os caminhos poss\u00edveis de controle fluem pelo programa, ent\u00e3o, possivelmente, o programa foi completamente testado.</p> <p>Existem duas falhas nesta afirma\u00e7\u00e3o, no entanto. Uma \u00e9 que o n\u00famero de caminhos l\u00f3gicos \u00fanicos atrav\u00e9s de um programa pode ser astronomicamente grande. Para ver isso, considere o programa trivial representado na Figura 2.1. O diagrama \u00e9 um gr\u00e1fico de fluxo de controle. Cada n\u00f3 ou c\u00edrculo representa um segmento de instru\u00e7\u00f5es que s\u00e3o executadas sequencialmente, possivelmente terminando com uma branching statement. Cada aresta ou arco representa uma transfer\u00eancia de controle (ramifica\u00e7\u00e3o) entre segmentos. O diagrama, ent\u00e3o, descreve um programa de 10 a 20 instru\u00e7\u00f5es que consiste em um loop DO que itera at\u00e9 20 vezes. Dentro do corpo do loop DO, h\u00e1 um conjunto de instru\u00e7\u00f5es IF aninhadas. Determinar o n\u00famero de caminhos l\u00f3gicos \u00fanicos \u00e9 o mesmo que determinar o n\u00famero total de maneiras \u00fanicas de se mover do ponto A para o ponto B (assumindo que todas as decis\u00f5es no programa s\u00e3o independentes umas das outras). Este n\u00famero \u00e9 aproximadamente 10\u00b9\u2074.</p> <p>FIGURA 2.1: Gr\u00e1fico de fluxo de controle de um pequeno programa.</p> <p>100 trilh\u00f5es. \u00c9 calculado a partir de 5\u00b2\u2070 + 5\u00b9\u2079 + ... + 5\u00b9, onde 5 \u00e9 o n\u00famero de caminhos atrav\u00e9s do corpo do loop. A maioria das pessoas tem dificuldade em visualizar esse n\u00famero, ent\u00e3o considere desta forma: se voc\u00ea pudesse escrever, executar e verificar um caso de teste a cada cinco minutos, levaria aproximadamente 1 bilh\u00e3o de anos para tentar todos os caminhos. Se voc\u00ea fosse 300 vezes mais r\u00e1pido, completando um teste uma vez por segundo, voc\u00ea poderia completar o trabalho em 3,2 milh\u00f5es de anos, dar ou tirar alguns anos bissextos e s\u00e9culos.</p> <p>\u00c9 claro que, em programas reais, todas as decis\u00f5es n\u00e3o s\u00e3o independentes de todas as outras decis\u00f5es, o que significa que o n\u00famero de caminhos de execu\u00e7\u00e3o poss\u00edveis seria um pouco menor. Por outro lado, os programas reais s\u00e3o muito maiores do que o programa simples representado na Figura 2.1. Portanto, testes exaustivos de caminho, como testes exaustivos de entrada, parecem ser impratic\u00e1veis, se n\u00e3o imposs\u00edveis.</p> <p>A segunda falha na afirma\u00e7\u00e3o \"teste de caminho exaustivo significa um teste completo\" \u00e9 que todos os caminhos em um programa podem ser testados, mas o programa ainda pode estar carregado de erros. Existem tr\u00eas explica\u00e7\u00f5es para isso.</p> <p>A primeira \u00e9 que um teste exaustivo de trajet\u00f3ria n\u00e3o garante, de forma alguma, que um programa corresponda \u00e0 sua especifica\u00e7\u00e3o. Por exemplo, se voc\u00ea fosse solicitado a escrever uma rotina de classifica\u00e7\u00e3o em ordem crescente, mas produzisse por engano uma rotina de classifica\u00e7\u00e3o em ordem decrescente, o teste de caminho exaustivo seria de pouco valor; o programa ainda tem um bug: \u00e9 o programa errado, pois n\u00e3o atende \u00e0 especifica\u00e7\u00e3o.</p> <p>Em segundo lugar, um programa pode estar incorreto devido a caminhos ausentes. O teste exaustivo de caminho, \u00e9 claro, n\u00e3o detectaria a aus\u00eancia de caminhos necess\u00e1rios.</p> <p>Terceiro, um teste de caminho exaustivo pode n\u00e3o revelar erros de confidencialidade de dados. Existem muitos exemplos de tais erros, mas um simples deve ser suficiente. Suponha que, em um programa, voc\u00ea tenha que comparar dois n\u00fameros para converg\u00eancia, isto \u00e9, para ver se a diferen\u00e7a entre os dois n\u00fameros \u00e9 menor do que algum valor predeterminado. Por exemplo, voc\u00ea pode escrever uma instru\u00e7\u00e3o Java IF como:</p> <p>```java if (a - b &lt; c)     System.out.println(\"a - b &lt; c\");</p> <p>Claro, a declara\u00e7\u00e3o cont\u00e9m um erro porque deveria comparar <code>c</code> com o valor absoluto de <code>a - b</code>. A detec\u00e7\u00e3o desse erro, no entanto, depende dos valores usados para <code>a</code> e <code>b</code>, e n\u00e3o seria necessariamente detectada apenas executando todos os caminhos do programa.</p> <p>Em conclus\u00e3o, embora o teste exaustivo de entrada seja superior ao teste de caminho exaustivo, nenhum deles se mostra \u00fatil porque ambos s\u00e3o invi\u00e1veis. Talvez, ent\u00e3o, existam maneiras de combinar elementos de teste de caixa preta e caixa branca para derivar uma estrat\u00e9gia de teste razo\u00e1vel, mas n\u00e3o herm\u00e9tica. Este assunto \u00e9 aprofundado no Cap\u00edtulo 4.</p>"},{"location":"aae3/white_box_test/#principios-de-teste-de-software","title":"Princ\u00edpios de teste de software","text":""},{"location":"aae3/white_box_test/#tabela-21-diretrizes-de-teste-de-programas","title":"Tabela 2.1 \u2013 Diretrizes de teste de programas","text":"N\u00ba Princ\u00edpio 1 Uma parte necess\u00e1ria de um caso de teste \u00e9 uma defini\u00e7\u00e3o da sa\u00edda ou resultado esperado. 2 Um programador deve evitar tentar testar seu pr\u00f3prio programa. 3 Uma organiza\u00e7\u00e3o de programa\u00e7\u00e3o n\u00e3o deve testar seus pr\u00f3prios programas. 4 Qualquer processo de teste deve incluir uma inspe\u00e7\u00e3o completa dos resultados de cada teste. 5 Os casos de teste devem ser gravados para condi\u00e7\u00f5es de entrada inv\u00e1lidas e inesperadas, bem como para aquelas que s\u00e3o v\u00e1lidas e esperadas. 6 Examinar um programa para ver se ele n\u00e3o faz o que deveria fazer \u00e9 apenas metade da batalha; a outra metade \u00e9 ver se o programa faz o que n\u00e3o deveria fazer. 7 Evite casos de teste descart\u00e1veis, a menos que o programa seja realmente um programa descart\u00e1vel. 8 N\u00e3o planeje um esfor\u00e7o de teste sob a suposi\u00e7\u00e3o t\u00e1cita de que nenhum erro ser\u00e1 encontrado. 9 A probabilidade da exist\u00eancia de mais erros em uma se\u00e7\u00e3o de um programa \u00e9 proporcional ao n\u00famero de erros j\u00e1 encontrados nessa se\u00e7\u00e3o. 10 O teste \u00e9 uma tarefa extremamente criativa e intelectualmente desafiadora. <p>Continuando com a premissa principal deste cap\u00edtulo, de que as considera\u00e7\u00f5es mais importantes no teste de software s\u00e3o quest\u00f5es de psicologia, podemos identificar um conjunto de princ\u00edpios ou diretrizes vitais de teste. A maioria desses princ\u00edpios pode parecer \u00f3bvia, mas muitas vezes s\u00e3o negligenciados. A Tabela 2.1 resume esses princ\u00edpios importantes, e cada um \u00e9 discutido com mais detalhes nos par\u00e1grafos a seguir.</p>"},{"location":"aae3/white_box_test/#principio-1","title":"Princ\u00edpio 1","text":"<p>Uma parte necess\u00e1ria de um caso de teste \u00e9 uma defini\u00e7\u00e3o da sa\u00edda ou resultado esperado. Este princ\u00edpio, embora \u00f3bvio, quando negligenciado, \u00e9 a causa de um dos erros mais frequentes no teste de programas. Novamente, \u00e9 algo baseado na psicologia humana. Se o resultado esperado de um caso de teste n\u00e3o foi predefinido, \u00e9 prov\u00e1vel que um resultado plaus\u00edvel, mas err\u00f4neo, seja interpretado como um resultado correto por causa do fen\u00f4meno de \"o olho ver o que quer ver\". Em outras palavras, apesar da defini\u00e7\u00e3o destrutiva adequada de teste, ainda h\u00e1 um desejo subconsciente de ver o resultado correto.</p> <p>Uma maneira de lutar contra essa situa\u00e7\u00e3o consiste em incentivar uma an\u00e1lise pormenorizada de toda a produ\u00e7\u00e3o, especificando com precis\u00e3o, antecipadamente, a produ\u00e7\u00e3o esperada do programa. Portanto, um caso de teste deve consistir em dois componentes:</p> <ol> <li>Uma descri\u00e7\u00e3o dos dados de entrada para o programa.</li> <li>Uma descri\u00e7\u00e3o precisa da sa\u00edda correta do programa para esse conjunto de dados de entrada.</li> </ol> <p>Um problema pode ser caracterizado como um fato ou grupo de fatos para os quais n\u00e3o temos uma explica\u00e7\u00e3o aceit\u00e1vel, que parecem incomuns ou que n\u00e3o se encaixam em nossas expectativas ou preconceitos. Deve ser \u00f3bvio que algumas cren\u00e7as pr\u00e9vias s\u00e3o necess\u00e1rias para que algo pare\u00e7a problem\u00e1tico. Se n\u00e3o houver expectativas, n\u00e3o pode haver surpresas.</p>"},{"location":"aae3/white_box_test/#principio-2","title":"Princ\u00edpio 2","text":"<p>Um programador deve evitar tentar testar seu pr\u00f3prio programa. Qualquer escritor sabe \u2014 ou deveria saber \u2014 que \u00e9 uma m\u00e1 ideia tentar editar ou revisar seu pr\u00f3prio trabalho. Eles sabem o que a pe\u00e7a deve dizer, portanto, podem n\u00e3o reconhecer quando diz o contr\u00e1rio. E eles realmente n\u00e3o querem encontrar erros em seu pr\u00f3prio trabalho. O mesmo se aplica aos autores de software.</p> <p>Outro problema surge com uma mudan\u00e7a de foco em um projeto de software. Depois que um programador projetou e codificou construtivamente um programa, \u00e9 extremamente dif\u00edcil mudar repentinamente a perspectiva para olhar para o programa com um olhar destrutivo.</p> <p>Como muitos propriet\u00e1rios sabem, remover o papel de parede (um processo destrutivo) n\u00e3o \u00e9 f\u00e1cil, mas \u00e9 quase insuportavelmente deprimente se foram suas m\u00e3os que penduraram o papel em primeiro lugar. Da mesma forma, a maioria dos programadores n\u00e3o pode testar efetivamente seus pr\u00f3prios programas porque n\u00e3o consegue mudar as engrenagens mentais para tentar expor erros. Al\u00e9m disso, um programador pode inconscientemente evitar encontrar erros por medo de retalia\u00e7\u00e3o de colegas, de um supervisor, de um cliente ou do propriet\u00e1rio do programa ou sistema que est\u00e1 sendo desenvolvido.</p> <p>Al\u00e9m dessas quest\u00f5es psicol\u00f3gicas, h\u00e1 um segundo problema significativo: o programa pode conter erros devido ao mal-entendido do programador sobre a declara\u00e7\u00e3o ou especifica\u00e7\u00e3o do problema. Se for esse o caso, \u00e9 prov\u00e1vel que o programador leve o mesmo mal-entendido para os testes de seu pr\u00f3prio programa.</p> <p>Isso n\u00e3o significa que seja imposs\u00edvel para um programador testar seu pr\u00f3prio programa. Em vez disso, implica que o teste \u00e9 mais eficaz e bem-sucedido se outra pessoa o fizer. No entanto, como vamos discutir em mais detalhes no Cap\u00edtulo 3, os desenvolvedores podem ser membros valiosos da equipe de teste quando a especifica\u00e7\u00e3o do programa e o pr\u00f3prio c\u00f3digo do programa est\u00e3o sendo avaliados.</p> <p>Observe que esse argumento n\u00e3o se aplica \u00e0 depura\u00e7\u00e3o (corrigir erros conhecidos); a depura\u00e7\u00e3o \u00e9 executada com mais efici\u00eancia pelo programador original.</p>"},{"location":"aae3/white_box_test/#principio-3","title":"Princ\u00edpio 3","text":"<p>Uma organiza\u00e7\u00e3o de programa\u00e7\u00e3o n\u00e3o deve testar seus pr\u00f3prios programas. O argumento aqui \u00e9 semelhante ao feito no princ\u00edpio anterior. Uma organiza\u00e7\u00e3o de projeto ou programa\u00e7\u00e3o \u00e9, em muitos sentidos, uma organiza\u00e7\u00e3o viva com problemas psicol\u00f3gicos semelhantes aos de programadores individuais. Al\u00e9m disso, na maioria dos ambientes, uma organiza\u00e7\u00e3o de programas ou um gerente de projeto \u00e9 amplamente medido pela capacidade de produzir um programa em uma determinada data e por um determinado custo.</p> <p>Uma raz\u00e3o para isso \u00e9 que \u00e9 f\u00e1cil medir os objetivos de tempo e custo, enquanto \u00e9 extremamente dif\u00edcil quantificar a confiabilidade de um programa. Portanto, \u00e9 dif\u00edcil para uma organiza\u00e7\u00e3o de programa\u00e7\u00e3o ser objetiva ao testar seus pr\u00f3prios programas, porque o processo de teste, se abordado com a defini\u00e7\u00e3o adequada, pode ser visto como diminuindo a probabilidade de atingir o cronograma e os objetivos de custo.</p> <p>Novamente, isso n\u00e3o significa que seja imposs\u00edvel para uma organiza\u00e7\u00e3o de programa\u00e7\u00e3o encontrar alguns de seus erros, porque as organiza\u00e7\u00f5es realizam isso com algum grau de sucesso. Em vez disso, implica que \u00e9 mais econ\u00f4mico que os testes sejam realizados por uma parte objetiva e independente.</p>"},{"location":"aae3/white_box_test/#principio-4","title":"Princ\u00edpio 4","text":"<p>Qualquer processo de teste deve incluir uma inspe\u00e7\u00e3o completa dos resultados de cada teste. Este \u00e9 provavelmente o princ\u00edpio mais \u00f3bvio, mas, novamente, \u00e9 algo que muitas vezes \u00e9 esquecido. Vimos v\u00e1rios experimentos que mostram que muitos sujeitos falharam em detectar certos erros, mesmo quando os sintomas desses erros eram claramente observ\u00e1veis nas listas de sa\u00edda. Dito de outra forma, os erros encontrados em testes posteriores foram frequentemente perdidos nos resultados de testes anteriores.</p>"},{"location":"aae3/white_box_test/#principio-5","title":"Princ\u00edpio 5","text":"<p>Os casos de teste devem ser escritos para condi\u00e7\u00f5es de entrada inv\u00e1lidas e inesperadas, bem como para aquelas que s\u00e3o v\u00e1lidas e esperadas. H\u00e1 uma tend\u00eancia natural, ao testar um programa, de se concentrar nas condi\u00e7\u00f5es de entrada v\u00e1lidas e esperadas, negligenciando as condi\u00e7\u00f5es inv\u00e1lidas e inesperadas.</p> <p>Por exemplo, essa tend\u00eancia aparece frequentemente no teste do programa do tri\u00e2ngulo no Cap\u00edtulo 1. Poucas pessoas, por exemplo, alimentam o programa com os n\u00fameros 1, 2, 5 para garantir que o programa n\u00e3o interprete erroneamente isso como um tri\u00e2ngulo equil\u00e1tero em vez de um tri\u00e2ngulo escaleno.</p> <p>Al\u00e9m disso, muitos erros que s\u00e3o descobertos repentinamente no software de produ\u00e7\u00e3o aparecem quando ele \u00e9 usado de alguma maneira nova ou inesperada. \u00c9 dif\u00edcil, se n\u00e3o imposs\u00edvel, definir todos os casos de uso para teste de software. Portanto, os casos de teste que representam condi\u00e7\u00f5es de entrada inesperadas e inv\u00e1lidas parecem ter um rendimento de detec\u00e7\u00e3o de erro maior do que os casos de teste para condi\u00e7\u00f5es de entrada v\u00e1lidas.</p>"},{"location":"aae3/white_box_test/#principio-6","title":"Princ\u00edpio 6","text":"<p>Examinar um programa para ver se ele n\u00e3o faz o que deveria fazer \u00e9 apenas metade da batalha; a outra metade \u00e9 ver se o programa faz o que n\u00e3o deveria fazer. Este \u00e9 um corol\u00e1rio do princ\u00edpio anterior. Os programas devem ser examinados quanto a efeitos colaterais indesejados.</p> <p>Por exemplo, um programa de c\u00e1lculo das folhas de pagamento que produz os contracheques corretos ainda \u00e9 um programa err\u00f4neo se tamb\u00e9m produzir cheques extras para empregados inexistentes ou se sobregravar o primeiro registro do arquivo pessoal.</p>"},{"location":"aae3/white_box_test/#principio-7","title":"Princ\u00edpio 7","text":"<p>Evite casos de teste descart\u00e1veis, a menos que o programa seja realmente um programa descart\u00e1vel. Este problema \u00e9 visto com mais frequ\u00eancia com sistemas interativos para testar programas. Uma pr\u00e1tica comum \u00e9 sentar-se em um terminal e inventar casos de teste em tempo real e, em seguida, enviar esses casos de teste pelo programa.</p> <p>A principal quest\u00e3o \u00e9 que os casos de teste representam um investimento valioso que, neste ambiente, desaparece ap\u00f3s a conclus\u00e3o do teste. Sempre que o programa tiver que ser testado novamente (por exemplo, ap\u00f3s corrigir um erro ou fazer uma melhoria), os casos de teste devem ser reinventados.</p> <p>Na maioria das vezes, uma vez que essa reinven\u00e7\u00e3o requer uma quantidade consider\u00e1vel de trabalho, as pessoas tendem a evit\u00e1-la. Portanto, o teste do programa raramente \u00e9 t\u00e3o rigoroso quanto o teste original, o que significa que, se a modifica\u00e7\u00e3o fizer com que uma parte anteriormente funcional do programa falhe, esse erro geralmente n\u00e3o \u00e9 detectado.</p> <p>Salvar casos de teste e execut\u00e1-los novamente ap\u00f3s altera\u00e7\u00f5es em outros componentes do programa \u00e9 conhecido como teste de regress\u00e3o.</p>"},{"location":"aae3/white_box_test/#principio-8","title":"Princ\u00edpio 8","text":"<p>N\u00e3o planeje um esfor\u00e7o de teste sob a suposi\u00e7\u00e3o t\u00e1cita de que nenhum erro ser\u00e1 encontrado. Este \u00e9 um erro que os gerentes de projeto costumam cometer e \u00e9 um sinal do uso da defini\u00e7\u00e3o incorreta de teste \u2014 ou seja, a suposi\u00e7\u00e3o de que o teste \u00e9 o processo de mostrar que o programa funciona corretamente.</p> <p>Mais uma vez, a defini\u00e7\u00e3o de teste \u00e9 o processo de execu\u00e7\u00e3o de um programa com a inten\u00e7\u00e3o de encontrar erros. E deve ser \u00f3bvio a partir de nossas discuss\u00f5es anteriores que \u00e9 imposs\u00edvel desenvolver um programa que seja completamente livre de erros.</p> <p>Mesmo ap\u00f3s extensos testes e corre\u00e7\u00e3o de erros, \u00e9 seguro assumir que os erros ainda existem; eles simplesmente ainda n\u00e3o foram encontrados.</p>"},{"location":"aae3/white_box_test/#principio-9","title":"Princ\u00edpio 9","text":"<p>A probabilidade da exist\u00eancia de mais erros em uma se\u00e7\u00e3o de um programa \u00e9 proporcional ao n\u00famero de erros j\u00e1 encontrados nessa se\u00e7\u00e3o. Este fen\u00f4meno \u00e9 ilustrado na Figura 2.2. \u00c0 primeira vista, esse conceito pode parecer sem sentido, mas \u00e9 um fen\u00f4meno presente em muitos programas.</p> <p>Por exemplo, se um programa consiste em dois m\u00f3dulos, classes ou sub-rotinas, A e B, e cinco erros foram encontrados no m\u00f3dulo A, e apenas um erro foi encontrado no m\u00f3dulo B, e se o m\u00f3dulo A n\u00e3o foi propositalmente submetido a um teste mais rigoroso, ent\u00e3o este princ\u00edpio nos diz que a probabilidade de mais erros no m\u00f3dulo A \u00e9 maior do que a probabilidade de mais erros no m\u00f3dulo B.</p> <p>Outra maneira de afirmar esse princ\u00edpio \u00e9 dizer que os erros tendem a ocorrer em grupos e que, no programa t\u00edpico, algumas se\u00e7\u00f5es parecem ser muito mais propensas a erros do que outras se\u00e7\u00f5es, embora ningu\u00e9m tenha fornecido uma boa explica\u00e7\u00e3o de por que isso ocorre.</p> <p>FIGURA 2.2: A surpreendente rela\u00e7\u00e3o entre erros remanescentes e erros encontrados.</p> <p>O fen\u00f4meno \u00e9 \u00fatil porque nos d\u00e1 uma vis\u00e3o ou feedback no processo de teste. Se uma se\u00e7\u00e3o espec\u00edfica de um programa parece ser muito mais propensa a erros do que outras se\u00e7\u00f5es, esse fen\u00f4meno nos diz que, em termos de rendimento em nosso investimento em testes, os esfor\u00e7os adicionais de teste s\u00e3o mais bem focados nesta se\u00e7\u00e3o propensa a erros.</p>"},{"location":"aae3/white_box_test/#principio-10","title":"Princ\u00edpio 10","text":"<p>O teste \u00e9 uma tarefa extremamente criativa e intelectualmente desafiadora. Provavelmente \u00e9 verdade que a criatividade necess\u00e1ria para testar um programa grande excede a criatividade necess\u00e1ria para projetar esse programa.</p> <p>J\u00e1 vimos que \u00e9 imposs\u00edvel testar um programa o suficiente para garantir a aus\u00eancia de todos os erros. As metodologias discutidas posteriormente neste livro ajudam voc\u00ea a desenvolver um conjunto razo\u00e1vel de casos de teste para um programa, mas essas metodologias ainda exigem uma quantidade significativa de criatividade.</p>"},{"location":"aae3/white_box_test/#resumo","title":"Resumo","text":"<p>\u00c0 medida que voc\u00ea avan\u00e7a neste livro, tenha em mente estes importantes princ\u00edpios de teste:</p> <ul> <li>Teste \u00e9 o processo de execu\u00e7\u00e3o de um programa com a inten\u00e7\u00e3o de encontrar erros.</li> <li>O teste \u00e9 mais bem-sucedido quando n\u00e3o \u00e9 realizado pelo(s) desenvolvedor(es).</li> <li>Um bom caso de teste \u00e9 aquele que tem uma alta probabilidade de detectar um erro n\u00e3o descoberto.</li> <li>Um caso de teste bem-sucedido \u00e9 aquele que detecta um erro n\u00e3o descoberto.</li> <li>O teste bem-sucedido inclui tamb\u00e9m a defini\u00e7\u00e3o cuidadosa da sa\u00edda esperada como entrada.</li> <li>O teste bem-sucedido inclui o estudo cuidadoso dos resultados do teste.</li> </ul>"},{"location":"aae3/white_box_test/#bibliografia","title":"Bibliografia","text":"<p>MYERS, G. J.; SANDLER, C.; BADGETT, T. The Art of Software Testing. 3rd ed. Cap\u00edtulo 4, Se\u00e7\u00e3o White-Box Testing.</p>"},{"location":"tpi_tpe/tpi3_tpe3/","title":"TPI/TPE(3) - Quest\u00f5es de Testes de Software","text":""},{"location":"tpi_tpe/tpi3_tpe3/#q01-qual-e-a-representacao-de-programa-mais-comumente-utilizada-nos-criterios-de-teste-estrutural","title":"Q01. Qual \u00e9 a representa\u00e7\u00e3o de programa mais comumente utilizada nos crit\u00e9rios de teste estrutural?","text":"<ul> <li>a. Grafo de Causa-Efeito.  </li> <li>b. Grafo de Fluxo de Dados.  </li> <li>c. Grafo de Caminhos Independentes.  </li> <li>d. Grafo de Fluxo de Controle.  </li> </ul> <p>RESPOSTA: d. Grafo de Fluxo de Controle.</p> <p>\u201cThe diagram is a control-flow graph. Each node or circle represents a segment of statements that execute sequentially, possibly terminating with a branching statement. Each edge or arc represents a transfer of control (branch) between segments.\u201d (p. 11, The Art of Software Testing \u2013 3rd Edition)</p> <p>Tradu\u00e7\u00e3o: \u201cO diagrama \u00e9 um grafo de fluxo de controle. Cada n\u00f3 ou c\u00edrculo representa um segmento de instru\u00e7\u00f5es que executam sequencialmente, podendo terminar com uma instru\u00e7\u00e3o de desvio. Cada aresta ou arco representa uma transfer\u00eancia de controle (desvio) entre segmentos.\u201d</p> <p>Refer\u00eancia: The Art of Software Testing \u2013 3rd Edition, p\u00e1gina 11.</p>"},{"location":"tpi_tpe/tpi3_tpe3/#q02-qual-das-seguintes-afirmacoes-e-mais-verdadeira-sobre-o-teste-de-unidade","title":"Q02. Qual das seguintes afirma\u00e7\u00f5es \u00e9 MAIS VERDADEIRA sobre o teste de unidade?","text":"<ul> <li>a. \u00c9 uma abordagem de teste de caixa preta onde a estrutura interna do m\u00f3dulo n\u00e3o \u00e9 considerada.  </li> <li>b. \u00c9 uma abordagem de teste de caixa branca que foca nos componentes individuais de um programa.  </li> <li>c. S\u00f3 \u00e9 usado para grandes programas com mais de 500 instru\u00e7\u00f5es.  </li> <li>d. \u00c9 o mesmo que teste de integra\u00e7\u00e3o, que combina v\u00e1rios componentes.</li> </ul> <p>RESPOSTA: b. \u00c9 uma abordagem de teste de caixa branca que foca nos componentes individuais de um programa.</p> <p>\u201cO teste de unidade \u00e9 amplamente orientado \u00e0 caixa-branca.\u201d (p. 86) Module testing is largely white-box oriented.</p>"},{"location":"tpi_tpe/tpi3_tpe3/#q03-quais-sao-os-dois-principais-motivos-para-realizar-o-teste-de-unidade","title":"Q03. Quais s\u00e3o os dois principais motivos para realizar o teste de unidade?","text":"<ul> <li>a. Documentar a funcionalidade do programa e identificar erros no in\u00edcio do processo de desenvolvimento.  </li> <li>b. Reduzir a complexidade de testar programas grandes e facilitar a depura\u00e7\u00e3o.  </li> <li>c. Atender aos requisitos do usu\u00e1rio e garantir que o programa esteja livre de erros.  </li> <li>d. Melhorar a cobertura do c\u00f3digo e testar o desempenho do programa.  </li> </ul> <p>RESPOSTA: b. Reduzir a complexidade de testar programas grandes e facilitar a depura\u00e7\u00e3o.</p> <p>\u201cThe motivations for doing this are threefold. First, module testing is a way of managing the combined elements of testing, since attention is focused initially on smaller units of the program. Second, module testing eases the task of debugging since attention is focused on a small unit of code and since the interface to the rest of the program is often simulated by a stub module.\u201d (p. 85, The Art of Software Testing \u2013 3rd Edition)</p> <p>\u201cAs motiva\u00e7\u00f5es para fazer isso s\u00e3o tr\u00eas. Primeiro, o teste de m\u00f3dulo \u00e9 uma forma de gerenciar os elementos combinados do teste, j\u00e1 que a aten\u00e7\u00e3o \u00e9 focada inicialmente em unidades menores do programa. Segundo, o teste de m\u00f3dulo facilita a tarefa de depura\u00e7\u00e3o, j\u00e1 que a aten\u00e7\u00e3o est\u00e1 concentrada em uma pequena unidade de c\u00f3digo e, frequentemente, a interface com o restante do programa \u00e9 simulada por um m\u00f3dulo stub.\u201d (p. 85)</p>"},{"location":"tpi_tpe/tpi3_tpe3/#q04-por-que-a-cobertura-de-condicao-pode-nao-satisfazer-a-cobertura-de-decisao","title":"Q04. Por que a cobertura de condi\u00e7\u00e3o pode n\u00e3o satisfazer a cobertura de decis\u00e3o?","text":"<ul> <li>a. Porque a cobertura de condi\u00e7\u00e3o n\u00e3o testa todas as instru\u00e7\u00f5es.  </li> <li>b. Porque algumas condi\u00e7\u00f5es podem mascarar outras.  </li> <li>c. Porque a cobertura de condi\u00e7\u00e3o n\u00e3o inclui os pontos de entrada do programa.  </li> <li>d. Porque a cobertura de condi\u00e7\u00e3o n\u00e3o testa todas as combina\u00e7\u00f5es de condi\u00e7\u00f5es.  </li> </ul> <p>RESPOSTA: b. Porque algumas condi\u00e7\u00f5es podem mascarar outras.</p> <p>\u201cUm ponto fraco da cobertura de condi\u00e7\u00e3o/decis\u00e3o \u00e9 que, embora pare\u00e7a exercitar todos os resultados de todas as condi\u00e7\u00f5es, frequentemente n\u00e3o o faz, porque certas condi\u00e7\u00f5es mascaram outras condi\u00e7\u00f5es.\u201d \u201cA weakness with decision/condition coverage is that although it may appear to exercise all outcomes of all conditions, it frequently does not, because certain conditions mask other conditions.\u201d (p. 46)</p> <p>\u201cPor exemplo, se uma condi\u00e7\u00e3o \u2018and\u2019 for falsa, nenhuma das condi\u00e7\u00f5es subsequentes na express\u00e3o precisa ser avaliada. Da mesma forma, se uma condi\u00e7\u00e3o \u2018or\u2019 for verdadeira, as condi\u00e7\u00f5es subsequentes tamb\u00e9m n\u00e3o precisam ser avaliadas.\u201d \u201cFor instance, if an and condition is false, none of the subsequent conditions in the expression need be evaluated. Likewise, if an or condition is true, none of the subsequent conditions need be evaluated.\u201d (p. 47)</p> <p>Refer\u00eancia: The Art of Software Testing \u2013 3rd Edition, p\u00e1ginas 46\u201347.</p>"},{"location":"tpi_tpe/tpi3_tpe3/#q05-qual-e-a-principal-limitacao-da-cobertura-de-decisao","title":"Q05. Qual \u00e9 a principal limita\u00e7\u00e3o da cobertura de decis\u00e3o?","text":"<ul> <li>a. N\u00e3o garante que todas as instru\u00e7\u00f5es sejam executadas.  </li> <li>b. N\u00e3o considera as m\u00faltiplas condi\u00e7\u00f5es dentro de uma decis\u00e3o.  </li> <li>c. N\u00e3o testa todas as poss\u00edveis combina\u00e7\u00f5es de condi\u00e7\u00f5es.  </li> <li>d. N\u00e3o identifica erros em decis\u00f5es aninhadas.  </li> </ul> <p>RESPOSTA: b. N\u00e3o considera as m\u00faltiplas condi\u00e7\u00f5es dentro de uma decis\u00e3o.</p> <p>\u201cDecision coverage is a stronger criterion than statement coverage, but it still is rather weak.\u201d \u201cA criterion that is sometimes stronger than decision coverage is condition coverage. [...] But, as with decision coverage, this does not always lead to the execution of each statement.\u201d \u201cAlthough the condition coverage criterion appears, at first glance, to satisfy the decision coverage criterion, it does not always do so. [...] The condition coverage tests for the earlier example covered all condition outcomes but only two of the four decision outcomes...\u201d (p. 45\u201346, The Art of Software Testing \u2013 3rd Edition)</p> <p>Tradu\u00e7\u00e3o: \u201cA cobertura de decis\u00e3o \u00e9 um crit\u00e9rio mais forte do que a cobertura de instru\u00e7\u00f5es, mas ainda \u00e9 bastante fraco.\u201d \u201cUm crit\u00e9rio que \u00e0s vezes \u00e9 mais forte do que a cobertura de decis\u00e3o \u00e9 a cobertura de condi\u00e7\u00e3o. [...] Mas, assim como a cobertura de decis\u00e3o, isso nem sempre leva \u00e0 execu\u00e7\u00e3o de cada instru\u00e7\u00e3o.\u201d \u201cEmbora o crit\u00e9rio de cobertura de condi\u00e7\u00e3o pare\u00e7a, \u00e0 primeira vista, satisfazer o crit\u00e9rio de cobertura de decis\u00e3o, isso nem sempre acontece. [...] Os testes de cobertura de condi\u00e7\u00e3o do exemplo anterior cobriram todos os resultados das condi\u00e7\u00f5es, mas apenas dois dos quatro resultados das decis\u00f5es...\u201d</p> <p>Refer\u00eancia: The Art of Software Testing \u2013 3rd Edition, p\u00e1ginas 45\u201346.</p>"},{"location":"tpi_tpe/tpi3_tpe3/#q06-qual-dos-criterios-de-cobertura-de-logica-e-considerado-o-mais-fraco","title":"Q06. Qual dos crit\u00e9rios de cobertura de l\u00f3gica \u00e9 considerado o mais fraco?","text":"<ul> <li>a. Cobertura de condi\u00e7\u00e3o.  </li> <li>b. Cobertura de decis\u00e3o.  </li> <li>c. Cobertura de m\u00faltiplas condi\u00e7\u00f5es.  </li> <li>d. Cobertura de instru\u00e7\u00e3o.  </li> </ul> <p>RESPOSTA: d. Cobertura de instru\u00e7\u00e3o.</p> <p>\u201cEmbora voc\u00ea possa executar todas as instru\u00e7\u00f5es com um \u00fanico teste, esse crit\u00e9rio \u00e9 bastante fraco.\u201d \u201cYou could execute every statement by writing a single test case [...] Unfortunately, this criterion is a rather poor one.\u201d [...] \u201cEm outras palavras, o crit\u00e9rio de cobertura de instru\u00e7\u00e3o \u00e9 t\u00e3o fraco que geralmente \u00e9 in\u00fatil.\u201d \u201cIn other words, the statement coverage criterion is so weak that it generally is useless.\u201d (p. 44)</p> <p>Refer\u00eancia: The Art of Software Testing \u2013 3rd Edition, p\u00e1gina 44</p>"},{"location":"tpi_tpe/tpi3_tpe3/#q07-o-que-o-metodo-mcdc-visa-alcancar","title":"Q07. O que o m\u00e9todo MC/DC visa alcan\u00e7ar?","text":"<ul> <li>a. Testar todas as instru\u00e7\u00f5es do programa pelo menos uma vez.  </li> <li>b. Testar todas as combina\u00e7\u00f5es de decis\u00f5es em um programa.  </li> <li>c. Garantir que cada condi\u00e7\u00e3o em uma decis\u00e3o tenha um resultado verdadeiro e falso pelo menos uma vez.  </li> <li>d. Garantir que cada condi\u00e7\u00e3o independente em uma decis\u00e3o tenha um efeito independente na sa\u00edda da decis\u00e3o.  </li> </ul> <p>RESPOSTA: d. Garantir que cada condi\u00e7\u00e3o independente em uma decis\u00e3o tenha um efeito independente na sa\u00edda da decis\u00e3o.</p> <p>\u201cModified condition/decision coverage (MC/DC) requires that every point of entry and exit in the program has been invoked at least once, every condition in a decision takes on all possible outcomes at least once, and each condition in a decision has been shown to independently affect the decision\u2019s outcome.\u201d (p. 47, The Art of Software Testing \u2013 3rd Edition)</p> <p>Tradu\u00e7\u00e3o: \u201cA cobertura de condi\u00e7\u00e3o/decis\u00e3o modificada (MC/DC) exige que cada ponto de entrada e sa\u00edda do programa tenha sido invocado pelo menos uma vez, que cada condi\u00e7\u00e3o em uma decis\u00e3o assuma todos os resultados poss\u00edveis pelo menos uma vez e que cada condi\u00e7\u00e3o em uma decis\u00e3o tenha mostrado afetar de forma independente o resultado da decis\u00e3o.\u201d</p> <p>Refer\u00eancia: The Art of Software Testing \u2013 3rd Edition, p\u00e1gina 47.</p>"},{"location":"tpi_tpe/tpi3_tpe3/#q08-qual-e-uma-das-principais-vantagens-do-metodo-mcdc-em-relacao-a-outros-criterios-de-cobertura","title":"Q08. Qual \u00e9 uma das principais vantagens do m\u00e9todo MC/DC em rela\u00e7\u00e3o a outros crit\u00e9rios de cobertura?","text":"<ul> <li>a. Requer menos casos de teste para ser implementado.  </li> <li>b. \u00c9 mais f\u00e1cil de entender e aplicar em programas grandes.  </li> <li>c. Garante uma cobertura mais robusta ao testar condi\u00e7\u00f5es de decis\u00e3o.  </li> <li>d. N\u00e3o requer testes de m\u00faltiplas condi\u00e7\u00f5es dentro de uma decis\u00e3o.  </li> </ul> <p>RESPOSTA: c. Garante uma cobertura mais robusta ao testar condi\u00e7\u00f5es de decis\u00e3o.</p> <p>\u201cA criterion that covers this problem, and then some, is multiple-condition coverage.\u201d \u201cThis criterion requires that you write sufficient test cases such that all possible combinations of condition outcomes in each decision, and all points of entry, are invoked at least once.\u201d \u201cAlthough MC/DC does not require all combinations, it improves upon decision/condition coverage by ensuring that each condition independently affects the decision\u2019s outcome.\u201d (p. 47, The Art of Software Testing \u2013 3rd Edition)</p> <p>Tradu\u00e7\u00e3o: \u201cUm crit\u00e9rio que cobre esse problema, e vai al\u00e9m, \u00e9 a cobertura de m\u00faltiplas condi\u00e7\u00f5es.\u201d \u201cEsse crit\u00e9rio exige que voc\u00ea escreva casos de teste suficientes para que todas as combina\u00e7\u00f5es poss\u00edveis de resultados de condi\u00e7\u00f5es em cada decis\u00e3o, e todos os pontos de entrada, sejam invocados pelo menos uma vez.\u201d \u201cEmbora o MC/DC n\u00e3o exija todas as combina\u00e7\u00f5es, ele melhora a cobertura de decis\u00e3o/condi\u00e7\u00e3o ao garantir que cada condi\u00e7\u00e3o afete independentemente o resultado da decis\u00e3o.\u201d</p> <p>Refer\u00eancia: The Art of Software Testing \u2013 3rd Edition, p\u00e1gina 47.</p>"},{"location":"tpi_tpe/tpi3_tpe3/#q09-qual-das-seguintes-afirmacoes-melhor-descreve-o-primeiro-passo-ao-usar-tecnicas-de-cobertura-logica-no-teste-de-software","title":"Q09. Qual das seguintes afirma\u00e7\u00f5es melhor descreve o primeiro passo ao usar t\u00e9cnicas de cobertura l\u00f3gica no teste de software?","text":"<ul> <li>a. Identificar todas as vari\u00e1veis no programa e garantir que cada uma seja testada em diferentes condi\u00e7\u00f5es.  </li> <li>b. Listar as decis\u00f5es condicionais no programa, focando em declara\u00e7\u00f5es IF, DO e similares.  </li> <li>c. Criar casos de teste para todas as funcionalidades do software sem considerar a estrutura interna do c\u00f3digo.  </li> <li>d. Garantir que todas as declara\u00e7\u00f5es IF no programa sejam testadas de forma isolada para verificar seu comportamento.  </li> </ul> <p>RESPOSTA: b. Listar as decis\u00f5es condicionais no programa, focando em declara\u00e7\u00f5es IF, DO e similares.</p> <p>\u201cRegardless of which of the logic coverage techniques you use, the first step is to list the conditional decisions in the program. Candidates in this program are all IF and DO statements.\u201d (p. 89, The Art of Software Testing \u2013 3rd Edition)</p> <p>Tradu\u00e7\u00e3o: \u201cIndependentemente da t\u00e9cnica de cobertura l\u00f3gica utilizada, o primeiro passo \u00e9 listar as decis\u00f5es condicionais no programa. Os candidatos neste programa s\u00e3o todas as instru\u00e7\u00f5es IF e DO.\u201d</p> <p>Refer\u00eancia: The Art of Software Testing \u2013 3rd Edition, p\u00e1gina 89.</p>"},{"location":"tpi_tpe/tpi3_tpe3/#q10-qual-das-seguintes-afirmacoes-melhor-descreve-uma-caracteristica-do-criterio-de-cobertura-de-multiplas-condicoes","title":"Q10. Qual das seguintes afirma\u00e7\u00f5es melhor descreve uma caracter\u00edstica do crit\u00e9rio de cobertura de m\u00faltiplas condi\u00e7\u00f5es?","text":"<ul> <li>a. O crit\u00e9rio de cobertura de m\u00faltiplas condi\u00e7\u00f5es \u00e9 suficiente para detectar todos os erros poss\u00edveis em uma unidade.  </li> <li>b. Mesmo testes que satisfazem o crit\u00e9rio de cobertura de m\u00faltiplas condi\u00e7\u00f5es podem n\u00e3o detectar certos erros, como valores iniciais incorretos.  </li> <li>c. O crit\u00e9rio de cobertura de m\u00faltiplas condi\u00e7\u00f5es se concentra apenas em testes de caixa-preta.  </li> <li>d. O crit\u00e9rio de cobertura de m\u00faltiplas condi\u00e7\u00f5es garante que todos os caminhos de execu\u00e7\u00e3o do c\u00f3digo sejam testados.  </li> </ul> <p>RESPOSTA: b. Mesmo testes que satisfazem o crit\u00e9rio de cobertura de m\u00faltiplas condi\u00e7\u00f5es podem n\u00e3o detectar certos erros, como valores iniciais incorretos.</p> <p>\u201cAlthough these two test cases meet the decision coverage criterion, it should be obvious that there could be many types of errors in the module that are not detected by these two test cases. For instance, the test cases do not explore the circumstances where the error code is 0, an employee is a manager, or the department table is empty (DSIZE &lt;= 0).\u201d (p. 90, The Art of Software Testing \u2013 3rd Edition)</p> <p>Tradu\u00e7\u00e3o: \u201cEmbora esses dois casos de teste atendam ao crit\u00e9rio de cobertura de decis\u00e3o, deve ser \u00f3bvio que pode haver muitos tipos de erros no m\u00f3dulo que n\u00e3o s\u00e3o detectados por esses dois casos. Por exemplo, os casos de teste n\u00e3o exploram circunst\u00e2ncias como quando o c\u00f3digo de erro \u00e9 0, um funcion\u00e1rio \u00e9 gerente ou a tabela de departamentos est\u00e1 vazia (DSIZE \u2264 0).\u201d</p> <p>Refer\u00eancia: The Art of Software Testing \u2013 3rd Edition, p\u00e1gina 90.</p>"},{"location":"tpi_tpe/tpi3_tpe3/#q11-qual-e-uma-vantagem-importante-do-teste-incremental-sobre-o-teste-nao-incremental","title":"Q11. Qual \u00e9 uma vantagem importante do teste incremental sobre o teste n\u00e3o incremental?","text":"<ul> <li>a. Requer menos m\u00f3dulos de driver e stub.  </li> <li>b. Necessita de menos tempo de m\u00e1quina.  </li> <li>c. Permite que todos os m\u00f3dulos sejam testados simultaneamente.  </li> <li>d. Reduz a possibilidade de detectar erros nas interfaces dos m\u00f3dulos.  </li> </ul> <p>RESPOSTA: a. Requer menos m\u00f3dulos de driver e stub.</p> <p>\u201cNonincremental testing requires more work. For the program in Figure 5.7, five drivers and five stubs must be prepared [...]. The bottom-up incremental test would require five drivers but no stubs. A top-down incremental test would require five stubs but no drivers. Less work is required because previously tested modules are used instead of the driver modules (if you start from the top) or stub modules (if you start from the bottom) needed in the nonincremental approach.\u201d (p. 99, The Art of Software Testing \u2013 3rd Edition)</p> <p>Tradu\u00e7\u00e3o: \u201cO teste n\u00e3o incremental exige mais trabalho. Para o programa da Figura 5.7, cinco drivers e cinco stubs devem ser preparados [...]. O teste incremental bottom-up exigiria cinco drivers, mas nenhum stub. Um teste incremental top-down exigiria cinco stubs, mas nenhum driver. Menos trabalho \u00e9 necess\u00e1rio porque os m\u00f3dulos previamente testados s\u00e3o usados em vez dos m\u00f3dulos driver (se come\u00e7ar do topo) ou dos m\u00f3dulos stub (se come\u00e7ar pela base) exigidos na abordagem n\u00e3o incremental.\u201d</p> <p>Refer\u00eancia: The Art of Software Testing \u2013 3rd Edition, p\u00e1gina 99.</p>"},{"location":"tpi_tpe/tpi3_tpe3/#q12-qual-das-seguintes-observacoes-e-uma-vantagem-do-teste-nao-incremental","title":"Q12. Qual das seguintes observa\u00e7\u00f5es \u00e9 uma vantagem do teste n\u00e3o incremental?","text":"<ul> <li>a. Detecta erros de interfaces de m\u00f3dulos mais cedo.  </li> <li>b. Reduz a necessidade de drivers e stubs.  </li> <li>c. Permite mais atividades paralelas no in\u00edcio da fase de testes de m\u00f3dulo.  </li> <li>d. Resulta em testes mais completos dos m\u00f3dulos.  </li> </ul> <p>RESPOSTA: c. Permite mais atividades paralelas no in\u00edcio da fase de testes de m\u00f3dulo.</p> <p>\u201cAt the beginning of the module testing phase, there is more opportunity for parallel activities when nonincremental testing is used (that is, all the modules can be tested simultaneously). This might be of significance in a large project (many modules and people), since the head count of a project is usually at its peak at the start of the module test phase.\u201d (p. 100, The Art of Software Testing \u2013 3rd Edition)</p> <p>Tradu\u00e7\u00e3o: \u201cNo in\u00edcio da fase de testes de m\u00f3dulo, h\u00e1 mais oportunidade para atividades paralelas quando se utiliza o teste n\u00e3o incremental (isto \u00e9, todos os m\u00f3dulos podem ser testados simultaneamente). Isso pode ser significativo em projetos grandes (com muitos m\u00f3dulos e pessoas), j\u00e1 que o n\u00famero de integrantes do projeto geralmente atinge seu pico no in\u00edcio dessa fase.\u201d</p> <p>Refer\u00eancia: The Art of Software Testing \u2013 3rd Edition, p\u00e1gina 100.</p>"},{"location":"tpi_tpe/tpi3_tpe3/#q13-qual-e-uma-das-principais-vantagens-do-teste-top-down","title":"Q13. Qual \u00e9 uma das principais vantagens do teste top-down?","text":"<ul> <li>a. N\u00e3o requer a cria\u00e7\u00e3o de stubs.  </li> <li>b. Facilita a representa\u00e7\u00e3o de casos de teste uma vez que as fun\u00e7\u00f5es de entrada e sa\u00edda s\u00e3o adicionadas.  </li> <li>c. Permite a identifica\u00e7\u00e3o de todos os erros poss\u00edveis no programa.  </li> <li>d. Garante que todos os m\u00f3dulos s\u00e3o testados simultaneamente.  </li> </ul> <p>RESPOSTA: b. Facilita a representa\u00e7\u00e3o de casos de teste uma vez que as fun\u00e7\u00f5es de entrada e sa\u00edda s\u00e3o adicionadas.</p> <p>\u201cOnce the I/O functions are added, representation of cases is easier.\u201d (p. 109, The Art of Software Testing \u2013 3rd Edition)</p> <p>Tradu\u00e7\u00e3o: \u201cUma vez que as fun\u00e7\u00f5es de entrada/sa\u00edda s\u00e3o adicionadas, a representa\u00e7\u00e3o dos casos \u00e9 facilitada.\u201d</p> <p>Refer\u00eancia: The Art of Software Testing \u2013 3rd Edition, p\u00e1gina 109.</p>"},{"location":"tpi_tpe/tpi3_tpe3/#q14-qual-e-uma-desvantagem-do-teste-bottom-up","title":"Q14. Qual \u00e9 uma desvantagem do teste bottom-up?","text":"<ul> <li>a. A produ\u00e7\u00e3o de m\u00f3dulos driver \u00e9 mais dif\u00edcil que a produ\u00e7\u00e3o de stubs.  </li> <li>b. N\u00e3o permite a cria\u00e7\u00e3o de um esqueleto inicial do programa.  </li> <li>c. Requer que todos os m\u00f3dulos sejam testados simultaneamente.  </li> <li>d. Aumenta a possibilidade de erros humanos durante a fase de design.  </li> </ul> <p>RESPOSTA: b. N\u00e3o permite a cria\u00e7\u00e3o de um esqueleto inicial do programa.</p> <p>\u201cA drawback of the bottom-up strategy is that there is no concept of an early skeletal program. In fact, the working program does not exist until the last module (module A) is added, and this working program is the complete program.\u201d (p. 107, The Art of Software Testing \u2013 3rd Edition)</p> <p>Tradu\u00e7\u00e3o: \u201cUma desvantagem da estrat\u00e9gia bottom-up \u00e9 que n\u00e3o h\u00e1 conceito de um programa esquel\u00e9tico inicial. De fato, o programa funcional n\u00e3o existe at\u00e9 que o \u00faltimo m\u00f3dulo (m\u00f3dulo A) seja adicionado, e esse programa funcional \u00e9 o programa completo.\u201d</p> <p>Refer\u00eancia: The Art of Software Testing \u2013 3rd Edition, p\u00e1gina 107.</p>"},{"location":"tpi_tpe/tpi4_tpe4/","title":"Question\u00e1rio sobre Dubl\u00eas de Teste e TDD","text":""},{"location":"tpi_tpe/tpi4_tpe4/#q01-o-que-sao-objetos-dummy","title":"Q01. O que s\u00e3o objetos dummy?","text":"<ul> <li>a. Objetos que possuem implementa\u00e7\u00f5es reais, mas simplificadas.</li> <li>b. Objetos passados para a classe em teste, mas nunca utilizados.</li> <li>c. Objetos que fornecem respostas codificadas para chamadas realizadas durante o teste.</li> <li>d. Objetos que gravam todas as intera\u00e7\u00f5es e permitem fazer asser\u00e7\u00f5es posteriormente.</li> </ul> <p>RESPOSTA: b. Objetos passados para a classe em teste, mas nunca utilizados.</p> <p>Objetos Dummy s\u00e3o uma forma degenerada de Test Double. Eles existem apenas para serem passados de m\u00e9todo para m\u00e9todo; eles nunca s\u00e3o utilizados. (p. 728, Meszaros, 2007) Dummy Objects are a degenerate form of Test Double. They exist solely so that they can be passed around from method to method; they are never used. (p. 728, Meszaros, 2007)</p> <p>Um objeto dummy \u00e9 passado para preencher uma lista de par\u00e2metros, mas nunca \u00e9 usado. Eles s\u00e3o mais frequentemente usados para preencher par\u00e2metros obrigat\u00f3rios em m\u00e9todos ou construtores. (p. 728, Meszaros, 2007) A Dummy Object is passed in to fill a parameter list but never used. They are most often used to fill required parameters in methods or constructors. (p. 728, Meszaros, 2007)</p> <p>Algumas linguagens exigem que forne\u00e7amos valores para todos os par\u00e2metros formais de um m\u00e9todo; objetos dummy nos permitem satisfazer esse requisito sem afetar o comportamento do teste. (p. 728, Meszaros, 2007) Some programming languages require us to supply values for all formal parameters of a method; Dummy Objects let us satisfy that requirement without affecting the behavior of the test. (p. 728, Meszaros, 2007)</p>"},{"location":"tpi_tpe/tpi4_tpe4/#por-que-as-outras-alternativas-estao-erradas","title":"Por que as outras alternativas est\u00e3o erradas","text":"<ul> <li>a. Objetos que possuem implementa\u00e7\u00f5es reais, mas simplificadas.</li> </ul> <p>Isso define um Fake Object: substitu\u00edmos um componente do SUT por uma implementa\u00e7\u00e3o funcional mais leve. (p. 551, Meszaros, 2007) Fake Object \u2013 We replace a component that the SUT depends on with a much lighter-weight implementation. (p. 551, Meszaros, 2007)</p> <ul> <li>c. Objetos que fornecem respostas codificadas para chamadas realizadas durante o teste.</li> </ul> <p>Isso define um Test Stub: substitu\u00edmos um objeto real por um objeto de teste que fornece entradas indiretas. (p. 529, Meszaros, 2007) Test Stub \u2013 A Test Double that feeds indirect inputs into the SUT. (p. 529, Meszaros, 2007)</p> <ul> <li>d. Objetos que gravam todas as intera\u00e7\u00f5es e permitem fazer asser\u00e7\u00f5es posteriormente.</li> </ul> <p>Isso corresponde a um Test Spy: usamos um Test Double para capturar as chamadas indiretas feitas pelo SUT para posterior verifica\u00e7\u00e3o. (p. 538, Meszaros, 2007) Test Spy \u2013 We use a Test Double to capture the indirect output calls made to another component by the SUT for later verification by the test. (p. 538, Meszaros, 2007)</p> <p>Refer\u00eancia: Meszaros, G. (2007). xUnit Test Patterns: Refactoring Test Code. Addison-Wesley.</p>"},{"location":"tpi_tpe/tpi4_tpe4/#q02-qual-a-principal-caracteristica-de-objetos-fake","title":"Q02. Qual a principal caracter\u00edstica de objetos fake?","text":"<ul> <li>a. Eles t\u00eam implementa\u00e7\u00f5es reais, mas geralmente fazem a tarefa de forma mais simples.</li> <li>b. Eles fornecem respostas codificadas para chamadas realizadas durante o teste.</li> <li>c. Eles gravam todas as intera\u00e7\u00f5es e permitem fazer asser\u00e7\u00f5es posteriormente.</li> <li>d. Eles envolvem o objeto real e observam seu comportamento.</li> </ul> <p>RESPOSTA: a. Eles t\u00eam implementa\u00e7\u00f5es reais, mas geralmente fazem a tarefa de forma mais simples.</p> <p>Um Fake Object \u00e9 um dubl\u00ea de teste que substitui um componente do SUT com uma implementa\u00e7\u00e3o funcional, geralmente mais leve. (p. 551, Meszaros, 2007) A Fake Object is a Test Double that replaces a component that the SUT depends on with a working implementation, usually much lighter-weight. (p. 551, Meszaros, 2007)</p> <p>Muitas vezes, usamos fakes para evitar depend\u00eancias de infraestrutura como banco de dados ou servi\u00e7os de rede. Por exemplo, um fake pode ser um banco de dados em mem\u00f3ria simples usado em vez de um real. (p. 551, Meszaros, 2007) We often use fakes to avoid using infrastructure components such as databases or network services. For example, we might use an in-memory database implementation instead of a real one. (p. 551, Meszaros, 2007)</p> <p>Um fake geralmente implementa a mesma interface que o objeto real, mas com um comportamento mais simples, suficiente para os testes. (p. 551, Meszaros, 2007) A fake usually implements the same interface as the real component but provides a simpler behavior that is sufficient for the tests. (p. 551, Meszaros, 2007)</p>"},{"location":"tpi_tpe/tpi4_tpe4/#por-que-as-outras-alternativas-estao-erradas_1","title":"Por que as outras alternativas est\u00e3o erradas","text":"<ul> <li>b. Eles fornecem respostas codificadas para chamadas realizadas durante o teste.</li> </ul> <p>Isso define um Test Stub, n\u00e3o um fake. (p. 529, Meszaros, 2007) A Test Stub is a Test Double that feeds indirect inputs into the SUT. (p. 529, Meszaros, 2007)</p> <ul> <li>c. Eles gravam todas as intera\u00e7\u00f5es e permitem fazer asser\u00e7\u00f5es posteriormente.</li> </ul> <p>Essa \u00e9 a defini\u00e7\u00e3o de um Test Spy. (p. 538, Meszaros, 2007) A Test Spy is a Test Double that captures the indirect output calls made to another component by the SUT for later verification by the test. (p. 538, Meszaros, 2007)</p> <ul> <li>d. Eles envolvem o objeto real e observam seu comportamento.</li> </ul> <p>Isso descreve um Mock Object, especialmente um mock din\u00e2mico que usa proxying para observar intera\u00e7\u00f5es. (p. 544, Meszaros, 2007) Mocks are pre-programmed with expectations which form a specification of the calls they are expected to receive. (p. 544, Meszaros, 2007)</p> <p>Refer\u00eancia: Meszaros, G. (2007). xUnit Test Patterns: Refactoring Test Code. Addison-Wesley.</p>"},{"location":"tpi_tpe/tpi4_tpe4/#q03-como-os-stubs-diferem-dos-objetos-fake","title":"Q03. Como os stubs diferem dos objetos fake?","text":"<ul> <li>a. Stubs t\u00eam implementa\u00e7\u00f5es reais, mas simplificadas.</li> <li>b. Stubs s\u00e3o usados apenas para observar o comportamento de uma depend\u00eancia real.</li> <li>c. Stubs fornecem respostas codificadas e n\u00e3o t\u00eam uma implementa\u00e7\u00e3o funcional.</li> <li>d. Stubs permitem fazer asser\u00e7\u00f5es sobre as intera\u00e7\u00f5es ap\u00f3s o teste.</li> </ul> <p>RESPOSTA: c. Stubs fornecem respostas codificadas e n\u00e3o t\u00eam uma implementa\u00e7\u00e3o funcional.</p> <p>Um Stub \u00e9 um Dubl\u00ea de Teste que fornece entradas indiretas para o SUT, retornando valores codificados em resposta a chamadas feitas durante o teste. (p. 529, Meszaros, 2007) A Test Stub is a Test Double that feeds indirect inputs into the SUT. (p. 529, Meszaros, 2007)</p> <p>Os stubs n\u00e3o possuem comportamento funcional; eles apenas retornam valores predefinidos quando chamados. (p. 529, Meszaros, 2007) Stubs typically implement only the methods that are needed for the test and return hard-coded values. (p. 529, Meszaros, 2007)</p> <p>Em contraste, um Fake Object substitui um componente por uma implementa\u00e7\u00e3o funcional mais leve, como um banco de dados em mem\u00f3ria. (p. 551, Meszaros, 2007) A Fake Object is a Test Double that replaces a component that the SUT depends on with a working implementation, usually much lighter-weight. (p. 551, Meszaros, 2007)</p> <p>Um Fake geralmente \u00e9 uma implementa\u00e7\u00e3o funcional completa (mas simples), o que o difere fundamentalmente de um stub que apenas devolve valores fixos. (p. 551, Meszaros, 2007) A Fake usually implements the same interface as the real component but provides a simpler behavior that is sufficient for the tests. (p. 551, Meszaros, 2007)</p>"},{"location":"tpi_tpe/tpi4_tpe4/#por-que-as-outras-alternativas-estao-erradas_2","title":"Por que as outras alternativas est\u00e3o erradas","text":"<ul> <li>a. Stubs t\u00eam implementa\u00e7\u00f5es reais, mas simplificadas.</li> </ul> <p>Essa \u00e9 a defini\u00e7\u00e3o de um Fake, n\u00e3o de um Stub. (p. 551, Meszaros, 2007) A Fake Object is a Test Double that replaces a component [...] with a working implementation. (p. 551, Meszaros, 2007)</p> <ul> <li>b. Stubs s\u00e3o usados apenas para observar o comportamento de uma depend\u00eancia real.</li> </ul> <p>Isso descreve um Test Spy ou um Mock, e n\u00e3o um Stub. (p. 538, Meszaros, 2007) A Test Spy is a Test Double that captures the indirect output calls made to another component by the SUT for later verification by the test. (p. 538, Meszaros, 2007)</p> <ul> <li>d. Stubs permitem fazer asser\u00e7\u00f5es sobre as intera\u00e7\u00f5es ap\u00f3s o teste.</li> </ul> <p>Quem permite isso s\u00e3o os Test Spies, n\u00e3o os Stubs. (p. 538, Meszaros, 2007) A Test Spy captures the calls so that they can be asserted on later. (p. 538, Meszaros, 2007)</p> <p>Refer\u00eancia: Meszaros, G. (2007). xUnit Test Patterns: Refactoring Test Code. Addison-Wesley.</p>"},{"location":"tpi_tpe/tpi4_tpe4/#q04-qual-a-vantagem-principal-dos-objetos-mocks-em-comparacao-com-os-stubs","title":"Q04. Qual a vantagem principal dos objetos mocks em compara\u00e7\u00e3o com os stubs?","text":"<ul> <li>a. Mocks t\u00eam implementa\u00e7\u00f5es reais.</li> <li>b. Mocks s\u00e3o mais f\u00e1ceis de controlar do que stubs.</li> <li>c. Mocks podem gravar intera\u00e7\u00f5es e permitir asser\u00e7\u00f5es sobre elas.</li> <li>d. Mocks fornecem respostas codificadas para chamadas realizadas durante o teste.</li> </ul> <p>RESPOSTA: c. Mocks podem gravar intera\u00e7\u00f5es e permitir asser\u00e7\u00f5es sobre elas.</p> <p>Um Mock Object \u00e9 um dubl\u00ea de teste que \u00e9 pr\u00e9-programado com expectativas, que representam uma especifica\u00e7\u00e3o das chamadas que ele deve receber. O mock verifica automaticamente se essas chamadas ocorrem e, se n\u00e3o, o teste falha. (p. 544, Meszaros, 2007) A Mock Object is a Test Double that is pre-programmed with expectations which form a specification of the calls they are expected to receive. (p. 544, Meszaros, 2007)</p> <p>Os mocks s\u00e3o frequentemente criados por meio de bibliotecas que permitem especificar as intera\u00e7\u00f5es esperadas. Essas intera\u00e7\u00f5es s\u00e3o registradas durante a execu\u00e7\u00e3o, e as bibliotecas de mocks verificam automaticamente se o comportamento ocorreu como esperado. (p. 544, Meszaros, 2007) Mocks are usually created by using a library that allows us to specify the expected interactions. These interactions are recorded during the test execution, and the mock library automatically verifies that the expected behavior occurred. (p. 544, Meszaros, 2007)</p> <p>Em contraste, um Stub apenas fornece valores de retorno predefinidos e n\u00e3o verifica intera\u00e7\u00f5es com o SUT. (p. 529, Meszaros, 2007) A Test Stub is a Test Double that feeds indirect inputs into the SUT. (p. 529, Meszaros, 2007)</p> <p>Os stubs n\u00e3o sabem se foram chamados corretamente; s\u00e3o usados apenas para injetar entradas indiretas no SUT. (p. 529, Meszaros, 2007) Stubs typically implement only the methods that are needed for the test and return hard-coded values. They don't know whether they were called correctly. (p. 529, Meszaros, 2007)</p>"},{"location":"tpi_tpe/tpi4_tpe4/#por-que-as-outras-alternativas-estao-erradas_3","title":"Por que as outras alternativas est\u00e3o erradas","text":"<ul> <li>a. Mocks t\u00eam implementa\u00e7\u00f5es reais.</li> </ul> <p>Isso define um Fake Object, que \u00e9 uma implementa\u00e7\u00e3o funcional simplificada, n\u00e3o um Mock. (p. 551, Meszaros, 2007) A Fake Object is a Test Double that replaces a component [...] with a working implementation. (p. 551, Meszaros, 2007)</p> <ul> <li>b. Mocks s\u00e3o mais f\u00e1ceis de controlar do que stubs.</li> </ul> <p>O livro n\u00e3o afirma que mocks s\u00e3o \"mais f\u00e1ceis de controlar\". Ele aponta que mocks s\u00e3o usados para verificar intera\u00e7\u00f5es, enquanto stubs s\u00e3o usados para fornecer entradas indiretas. (p. 544 vs. 529, Meszaros, 2007)</p> <ul> <li>d. Mocks fornecem respostas codificadas para chamadas realizadas durante o teste.</li> </ul> <p>Quem faz isso s\u00e3o os Stubs, n\u00e3o os Mocks. (p. 529, Meszaros, 2007) Stubs typically implement only the methods that are needed for the test and return hard-coded values. (p. 529, Meszaros, 2007)</p> <p>Refer\u00eancia: Meszaros, G. (2007). xUnit Test Patterns: Refactoring Test Code. Addison-Wesley.</p>"},{"location":"tpi_tpe/tpi4_tpe4/#q05-uma-classe-que-simula-uma-base-de-dados-usando-uma-lista-pode-ser-classificada-como","title":"Q05. Uma classe que simula uma base de dados usando uma lista pode ser classificada como:","text":"<ul> <li>a. Fake object</li> <li>b. Dummy object</li> <li>c. Mock</li> <li>d. Stub</li> </ul> <p>RESPOSTA: a. Fake object</p> <p>Um Fake Object \u00e9 um Dubl\u00ea de Teste que substitui um componente de que o SUT depende com uma implementa\u00e7\u00e3o funcional, geralmente mais leve. (p. 551, Meszaros, 2007) A Fake Object is a Test Double that replaces a component that the SUT depends on with a working implementation, usually much lighter-weight. (p. 551, Meszaros, 2007)</p> <p>Um exemplo comum de fake \u00e9 uma implementa\u00e7\u00e3o em mem\u00f3ria de um banco de dados, usada em vez de um banco real durante os testes. (p. 551, Meszaros, 2007) A common example is an in-memory database implementation that is used instead of a real one during testing. (p. 551, Meszaros, 2007)</p> <p>Fakes s\u00e3o apropriados quando a implementa\u00e7\u00e3o alternativa \u00e9 mais r\u00e1pida ou f\u00e1cil de configurar do que a real, mas ainda fornece o comportamento necess\u00e1rio para os testes. (p. 551, Meszaros, 2007) They are appropriate when the alternative implementation is easier or faster to work with and still provides the correct behavior for the tests. (p. 551, Meszaros, 2007)</p>"},{"location":"tpi_tpe/tpi4_tpe4/#por-que-as-outras-alternativas-estao-erradas_4","title":"Por que as outras alternativas est\u00e3o erradas","text":"<ul> <li>b. Dummy object</li> </ul> <p>Dummies s\u00e3o passados para preencher par\u00e2metros, mas nunca s\u00e3o usados. (p. 728, Meszaros, 2007) Dummy Objects are a degenerate form of Test Double. They exist solely so that they can be passed around from method to method; they are never used. (p. 728, Meszaros, 2007) Uma lista simulando uma base de dados \u00e9 usada funcionalmente, portanto n\u00e3o \u00e9 um dummy.</p> <ul> <li>c. Mock</li> </ul> <p>Mocks s\u00e3o configurados com expectativas de chamadas e verificam se elas ocorreram; n\u00e3o s\u00e3o usados para simular l\u00f3gica funcional como um banco de dados. (p. 544, Meszaros, 2007) A Mock Object is a Test Double that is pre-programmed with expectations which form a specification of the calls they are expected to receive. (p. 544, Meszaros, 2007)</p> <ul> <li>d. Stub</li> </ul> <p>Stubs s\u00e3o usados para fornecer respostas codificadas a chamadas do SUT, mas n\u00e3o t\u00eam comportamento funcional completo como um banco de dados em mem\u00f3ria. (p. 529, Meszaros, 2007) Test Stubs typically implement only the methods that are needed for the test and return hard-coded values. (p. 529, Meszaros, 2007)</p> <p>Refer\u00eancia: Meszaros, G. (2007). xUnit Test Patterns: Refactoring Test Code. Addison-Wesley.</p>"},{"location":"tpi_tpe/tpi4_tpe4/#q06-o-que-pode-ser-necessario-para-injetar-dubles-de-teste","title":"Q06. O que pode ser necess\u00e1rio para injetar dubl\u00eas de teste?","text":"<ul> <li>a. Criar um tipo especial de dubl\u00ea que intercepte chamadas.</li> <li>b. Refatorar o construtor da classe de teste para instanciar a depend\u00eancia.</li> <li>c. Usar um framework de mocking para inje\u00e7\u00e3o autom\u00e1tica.</li> <li>d. Alterar o c\u00f3digo da classe sendo testada para aceitar a depend\u00eancia via construtor.</li> </ul> <p>RESPOSTA: d. Alterar o c\u00f3digo da classe sendo testada para aceitar a depend\u00eancia via construtor.</p> <p>Inje\u00e7\u00e3o por Construtor: informamos ao SUT qual DOC usar quando o constru\u00edmos. (p. 680, Meszaros, 2007) Constructor Injection: We tell the SUT which DOC to use when we construct it. (p. 680, Meszaros, 2007)</p> <p>Para converter o SUT para usar Inje\u00e7\u00e3o por Construtor, podemos fazer um refatoramento do tipo \"Introduce Field\" para manter o DOC em um campo que \u00e9 inicializado no construtor existente. (p. 684, Meszaros, 2007) To convert the SUT to use Constructor Injection, we can do an Introduce Field refactoring to hold the DOC in a field that is initialized in the existing constructor. (p. 684, Meszaros, 2007)</p> <p>Quando um teste deseja substituir o DOC real por um dubl\u00ea de teste, ele o passa para o construtor ao construir o SUT. (p. 681, Meszaros, 2007) When a test wants to replace the real DOC with a Test Double, it passes in the Test Double to the constructor when it builds the SUT. (p. 681, Meszaros, 2007)</p> <p>Quando o SUT n\u00e3o suporta inje\u00e7\u00e3o de depend\u00eancia \"de f\u00e1brica\", pode ser necess\u00e1rio refatorar o c\u00f3digo da classe sendo testada para permitir isso. (p. 682, Meszaros, 2007) When the SUT does not support any of these options \"out of the box\", we may need to retrofit this capability... (p. 682, Meszaros, 2007)</p>"},{"location":"tpi_tpe/tpi4_tpe4/#por-que-as-outras-alternativas-estao-erradas_5","title":"Por que as outras alternativas est\u00e3o erradas","text":"<ul> <li>a. Criar um tipo especial de dubl\u00ea que intercepte chamadas.</li> </ul> <p>O livro descreve mocks e spies como dubl\u00eas configur\u00e1veis, mas n\u00e3o afirma que a inje\u00e7\u00e3o exige criar um tipo especial que intercepte chamadas. Isso n\u00e3o \u00e9 necess\u00e1rio para inje\u00e7\u00e3o. (p. 522 e p. 544, Meszaros, 2007)</p> <ul> <li>b. Refatorar o construtor da classe de teste para instanciar a depend\u00eancia.</li> </ul> <p>O que precisa ser refatorado \u00e9 o construtor da classe sendo testada (SUT), n\u00e3o o da classe de teste. (p. 684, Meszaros, 2007) We can define a new constructor that takes the DOC as a parameter... (p. 684, Meszaros, 2007)</p> <ul> <li>c. Usar um framework de mocking para inje\u00e7\u00e3o autom\u00e1tica.</li> </ul> <p>O livro menciona que frameworks de mock como JMock facilitam a cria\u00e7\u00e3o de mocks, mas n\u00e3o substituem a necessidade de refatorar o SUT para aceitar inje\u00e7\u00e3o. (p. 565, Meszaros, 2007) We still need to inject the mock using setter or constructor injection. (p. 565, Meszaros, 2007)</p> <p>Refer\u00eancia: Meszaros, G. (2007). xUnit Test Patterns: Refactoring Test Code. Addison-Wesley.</p>"},{"location":"tpi_tpe/tpi4_tpe4/#q07-qual-a-principal-vantagem-de-configurar-dubles-para-lancar-excecoes","title":"Q07. Qual a principal vantagem de configurar dubl\u00eas para lan\u00e7ar exce\u00e7\u00f5es?","text":"<ul> <li>a. Permite testar como os sistemas se comportariam em cen\u00e1rios inesperados, simulando falhas.</li> <li>b. Garante que todos os m\u00e9todos sejam chamados ao menos uma vez.</li> <li>c. Facilita respostas codificadas.</li> <li>d. Substitui testes de integra\u00e7\u00e3o com sistemas externos.</li> </ul> <p>RESPOSTA: a. Permite testar como os sistemas se comportariam em cen\u00e1rios inesperados, simulando falhas.</p> <p>Certamente n\u00e3o queremos que o c\u00f3digo de tratamento de exce\u00e7\u00f5es seja executado pela primeira vez em produ\u00e7\u00e3o. E se ele estiver implementado incorretamente? \u00c9 altamente desej\u00e1vel ter testes automatizados para esse c\u00f3digo. O desafio no teste \u00e9 fazer com que o DOC (componente dependente) lance uma exce\u00e7\u00e3o para que o caminho de erro possa ser testado. (p. 127, Meszaros, 2007) We certainly would rather not have the exception-handling code execute for the first time in production. What if it was coded incorrectly? Clearly, it would be highly desirable to have automated tests for such code. The testing challenge is to somehow cause the DOC to throw an exception so that the error path can be tested. (p. 127, Meszaros, 2007)</p> <p>A exce\u00e7\u00e3o que esperamos que o DOC lance \u00e9 um bom exemplo de uma condi\u00e7\u00e3o de entrada indireta. Nosso meio de injetar essa entrada \u00e9 um ponto de controle. (p. 127, Meszaros, 2007) The exception we expect the DOC to throw is a good example of an indirect input test condition. Our means of injecting this input is a control point. (p. 127, Meszaros, 2007)</p> <p>Um Saboteur \u00e9 um tipo especial de Test Stub que lan\u00e7a exce\u00e7\u00f5es ou erros para injetar entradas indiretas anormais no SUT. (p. 135, Meszaros, 2007) A Saboteur is a special Test Stub that raises exceptions or errors to inject abnormal indirect inputs into the SUT. (p. 135, Meszaros, 2007)</p> <p>Um Expected Exception Test nos ajuda a verificar se os cen\u00e1rios de erro foram codificados corretamente. O modo mais comum de for\u00e7ar esses erros \u00e9 usar um Test Stub para controlar a entrada indireta e lan\u00e7ar as exce\u00e7\u00f5es apropriadas. (p. 350, Meszaros, 2007) An Expected Exception Test helps us verify that the error scenarios have been coded correctly. [...] The most common way to do so is to use a Test Stub to control the indirect input of the SUT and raise the appropriate errors in the Test Stub. (p. 350, Meszaros, 2007)</p>"},{"location":"tpi_tpe/tpi4_tpe4/#por-que-as-outras-alternativas-estao-erradas_6","title":"Por que as outras alternativas est\u00e3o erradas","text":"<ul> <li>b. Garante que todos os m\u00e9todos sejam chamados ao menos uma vez.</li> </ul> <p>Isso n\u00e3o \u00e9 relacionado ao lan\u00e7amento de exce\u00e7\u00f5es. Verificar se m\u00e9todos s\u00e3o chamados pertence ao comportamento de Mocks (verifica\u00e7\u00e3o de intera\u00e7\u00f5es), n\u00e3o ao uso de exce\u00e7\u00f5es. (p. 544, Meszaros, 2007)</p> <ul> <li>c. Facilita respostas codificadas.</li> </ul> <p>Quem faz isso s\u00e3o os Stubs do tipo Responder, usados para retornar valores predefinidos \u2014 n\u00e3o para lan\u00e7ar exce\u00e7\u00f5es. (p. 529, Meszaros, 2007)</p> <ul> <li>d. Substitui testes de integra\u00e7\u00e3o com sistemas externos.</li> </ul> <p>Dubl\u00eas podem ajudar a simular sistemas externos, mas o foco do uso de exce\u00e7\u00f5es n\u00e3o \u00e9 substituir testes de integra\u00e7\u00e3o, e sim permitir testar o comportamento em situa\u00e7\u00f5es de falha. (p. 127, Meszaros, 2007)</p> <p>Refer\u00eancia: Meszaros, G. (2007). xUnit Test Patterns: Refactoring Test Code. Addison-Wesley.</p>"},{"location":"tpi_tpe/tpi4_tpe4/#q08-qual-e-uma-das-principais-desvantagens-de-usar-dubles","title":"Q08. Qual \u00e9 uma das principais desvantagens de usar dubl\u00eas?","text":"<ul> <li>a. O acoplamento com o c\u00f3digo de produ\u00e7\u00e3o, que pode levar a falhas ao mudar intera\u00e7\u00f5es.</li> <li>b. Dificuldade de configura\u00e7\u00e3o e manuten\u00e7\u00e3o.</li> <li>c. Incapacidade de simular comportamentos complexos.</li> <li>d. Modifica\u00e7\u00e3o excessiva do c\u00f3digo de produ\u00e7\u00e3o.</li> </ul> <p>RESPOSTA: a. O acoplamento com o c\u00f3digo de produ\u00e7\u00e3o, que pode levar a falhas ao mudar intera\u00e7\u00f5es.</p> <p>Podemos tamb\u00e9m implementar o Test Double criando uma subclasse da DOC real e sobrescrevendo os m\u00e9todos cujo comportamento queremos mudar. Infelizmente, essa abordagem pode ter consequ\u00eancias imprevis\u00edveis se o SUT chamar outros m\u00e9todos da DOC que n\u00e3o foram sobrescritos. Isso tamb\u00e9m acopla fortemente o c\u00f3digo de teste \u00e0 implementa\u00e7\u00e3o da DOC, o que pode resultar em software superespecificado. (p. 570, Meszaros, 2007) We can also implement the Hard-Coded Test Double by subclassing the real DOC and overriding the behavior of the methods we expect the SUT to call as we exercise it. Unfortunately, this approach can have unpredictable consequences if the SUT calls other DOC methods that we have not overridden. It also ties our test code very closely to the implementation of the DOC and can result in Over-specified Software. (p. 570, Meszaros, 2007)</p> <p>Testes fr\u00e1geis indicam que os testes est\u00e3o muito acoplados ao SUT. Isso causa alto custo de manuten\u00e7\u00e3o, pois os testes precisam ser revisados com frequ\u00eancia, mesmo quando mudan\u00e7as m\u00ednimas s\u00e3o feitas. (p. 266, Meszaros, 2007) Fragile Test indicates that tests are too closely coupled to the SUT. They result in High Test Maintenance Cost because they need to be revisited and \"jiggled\" after all manner of minor changes that really shouldn't affect them. (p. 266, Meszaros, 2007)</p> <p>O custo alto de manuten\u00e7\u00e3o dos testes decorre do fato de que os testes ficam excessivamente dif\u00edceis de entender e manter. (p. 265, Meszaros, 2007) High Test Maintenance Cost occurs when the tests become overly difficult to understand and maintain. (p. 265, Meszaros, 2007)</p>"},{"location":"tpi_tpe/tpi4_tpe4/#por-que-as-outras-alternativas-estao-erradas_7","title":"Por que as outras alternativas est\u00e3o erradas","text":"<ul> <li>b. Dificuldade de configura\u00e7\u00e3o e manuten\u00e7\u00e3o.</li> </ul> <p>O livro trata da manuten\u00e7\u00e3o como uma consequ\u00eancia de outros problemas (como acoplamento excessivo e duplica\u00e7\u00e3o de c\u00f3digo), mas n\u00e3o afirma que os dubl\u00eas s\u00e3o dif\u00edceis de configurar por si s\u00f3. Pelo contr\u00e1rio, Configurable Test Doubles s\u00e3o justamente uma solu\u00e7\u00e3o para facilitar isso. (p. 558, Meszaros, 2007)</p> <ul> <li>c. Incapacidade de simular comportamentos complexos.</li> </ul> <p>N\u00e3o \u00e9 mencionado como limita\u00e7\u00e3o. Pelo contr\u00e1rio, mocks e fakes s\u00e3o usados justamente para simular comportamentos complexos e dif\u00edceis de reproduzir com o objeto real. (p. 544, 551, Meszaros, 2007)</p> <ul> <li>d. Modifica\u00e7\u00e3o excessiva do c\u00f3digo de produ\u00e7\u00e3o.</li> </ul> <p>O livro recomenda pr\u00e1ticas como Dependency Injection para evitar altera\u00e7\u00f5es desnecess\u00e1rias no c\u00f3digo de produ\u00e7\u00e3o, ou seja, altera\u00e7\u00f5es s\u00e3o uma solu\u00e7\u00e3o e n\u00e3o um problema causado por dubl\u00eas. (p. 678\u2013682, Meszaros, 2007)</p> <p>Refer\u00eancia: Meszaros, G. (2007). xUnit Test Patterns: Refactoring Test Code. Addison-Wesley.</p>"},{"location":"tpi_tpe/tpi4_tpe4/#q09-qual-e-o-ciclo-repetido-no-processo-de-tdd","title":"Q09. Qual \u00e9 o ciclo repetido no processo de TDD?","text":"<ul> <li>a. Teste passa \u2192 implementa\u00e7\u00e3o \u2192 refatora\u00e7\u00e3o</li> <li>b. Teste falha \u2192 implementa\u00e7\u00e3o \u2192 refatora\u00e7\u00e3o</li> <li>c. Implementa\u00e7\u00e3o \u2192 teste passa \u2192 refatora\u00e7\u00e3o</li> <li>d. Refatora\u00e7\u00e3o \u2192 teste falha \u2192 implementa\u00e7\u00e3o</li> </ul> <p>RESPOSTA: b. Teste falha \u2192 implementa\u00e7\u00e3o \u2192 refatora\u00e7\u00e3o</p> <p>O ciclo geral do TDD \u00e9 o seguinte: 1. Escreva um teste. 2. Fa\u00e7a com que ele funcione. Colocar a barra verde rapidamente domina tudo. 3. Fa\u00e7a certo. Agora que o sistema se comporta, remova duplica\u00e7\u00f5es. (Cap\u00edtulo 2, Beck, 2002) The general TDD cycle goes as follows: Write a test. Think about how you would like the operation in your mind to appear in your code. Make it run. Quickly getting that bar to go to green dominates everything else. Make it right. Now that the system is behaving, remove the duplication. (Chapter 2, Beck, 2002)</p> <p>Lembre-se, o ciclo \u00e9 o seguinte: Adicione um pequeno teste. Execute todos os testes e veja falhar. Fa\u00e7a uma pequena mudan\u00e7a. Execute todos os testes e veja passar. Refatore para remover duplica\u00e7\u00f5es. (Cap\u00edtulo 1, Beck, 2002) Remember, the cycle is as follows: Add a little test. Run all tests and fail. Make a little change. Run the tests and succeed. Refactor to remove duplication. (Chapter 1, Beck, 2002)</p> <p>TDD responde \u00e0 contradi\u00e7\u00e3o com um paradoxo \u2014 teste o programa antes de escrev\u00ea-lo. (Introdu\u00e7\u00e3o, Beck, 2002) Test-driven development replies to this contradiction with a paradox\u2014test the program before you write it. (Introduction, Beck, 2002)</p>"},{"location":"tpi_tpe/tpi4_tpe4/#por-que-as-outras-alternativas-estao-erradas_8","title":"Por que as outras alternativas est\u00e3o erradas","text":"<ul> <li>a. Teste passa \u2192 implementa\u00e7\u00e3o \u2192 refatora\u00e7\u00e3o</li> </ul> <p>Isso inverte a ordem correta, j\u00e1 que o teste precisa falhar primeiro para guiar a implementa\u00e7\u00e3o.</p> <ul> <li>c. Implementa\u00e7\u00e3o \u2192 teste passa \u2192 refatora\u00e7\u00e3o</li> </ul> <p>Esta \u00e9 a abordagem tradicional, mas n\u00e3o \u00e9 TDD, pois ignora a cria\u00e7\u00e3o do teste antes da implementa\u00e7\u00e3o.</p> <ul> <li>d. Refatora\u00e7\u00e3o \u2192 teste falha \u2192 implementa\u00e7\u00e3o</li> </ul> <p>Tamb\u00e9m est\u00e1 fora da ordem. A refatora\u00e7\u00e3o vem depois que os testes est\u00e3o passando.</p> <p>Refer\u00eancia: Beck, K. (2002). Test-Driven Development: By Example. Addison-Wesley.</p>"},{"location":"tpi_tpe/tpi4_tpe4/#q10-por-que-o-tdd-facilita-a-identificacao-de-problemas","title":"Q10. Por que o TDD facilita a identifica\u00e7\u00e3o de problemas?","text":"<ul> <li>a. Porque desenvolvedores escrevem c\u00f3digo antes dos testes.</li> <li>b. Porque desenvolvedores focam no produto final.</li> <li>c. Porque todos os testes s\u00e3o escritos antes da implementa\u00e7\u00e3o.</li> <li>d. Porque o ciclo incremental permite detectar problemas ap\u00f3s pequenas altera\u00e7\u00f5es.</li> </ul> <p>RESPOSTA: d. Porque o ciclo incremental permite detectar problemas ap\u00f3s pequenas altera\u00e7\u00f5es.</p> <p>O processo de desenvolvimento orientado a testes (TDD) incentiva a \u201cescrever um teste\u201d e depois \u201cescrever algum c\u00f3digo\u201d para fazer esse teste passar. Esse processo n\u00e3o envolve escrever todos os testes antes de qualquer c\u00f3digo, mas sim escrever testes e c\u00f3digo de forma intercalada em passos muito pequenos. (Cap\u00edtulo 4, Meszaros, 2007) The test-driven development process encourages us to \u201cwrite a test\u201d and then \u201cwrite some code\u201d to pass that test. This process isn\u2019t a case of all tests being written before any code, but rather the writing of tests and code being interleaved in a very fine-grained way. (Chapter 4, Meszaros, 2007)</p> <p>Isso \u00e9 desenvolvimento incremental no seu melhor. Muitos adeptos do TDD relatam que raramente usam o depurador, porque os testes em pequenas etapas localizam claramente o defeito e a \u00faltima altera\u00e7\u00e3o feita (que causou o problema) ainda est\u00e1 fresca na mem\u00f3ria. (Cap\u00edtulo 4, Meszaros, 2007) Many test drivers report not using the debugger very much because the fine-grained testing and incremental development leave little doubt about why tests are failing; the tests provide Defect Localization while the last change we made (which caused the problem) is still fresh in our minds. (Chapter 4, Meszaros, 2007)</p> <p>Lembre-se, o ciclo \u00e9 o seguinte: 1. Adicione um pequeno teste. 2. Execute todos os testes e veja falhar. 3. Fa\u00e7a uma pequena mudan\u00e7a. 4. Execute todos os testes e veja passar. 5. Refatore para remover duplica\u00e7\u00f5es. (Cap\u00edtulo 1, Beck, 2002) Remember, the cycle is as follows: Add a little test. Run all tests and fail. Make a little change. Run the tests and succeed. Refactor to remove duplication. (Chapter 1, Beck, 2002)</p> <p>O TDD permite que qualquer desenvolvedor escreva c\u00f3digo confi\u00e1vel e livre de erros, n\u00e3o importa o qu\u00e3o complexo ele seja. O desenvolvimento com testes automatizados e elimina\u00e7\u00e3o de duplica\u00e7\u00f5es encoraja mudan\u00e7as pequenas e constantes, facilitando identificar o que quebrou e quando. (Introdu\u00e7\u00e3o, Beck, 2002) TDD encourages small, steady steps that make it easy to tell what broke and when. (Introduction, Beck, 2002)</p>"},{"location":"tpi_tpe/tpi4_tpe4/#por-que-as-outras-alternativas-estao-erradas_9","title":"Por que as outras alternativas est\u00e3o erradas","text":"<ul> <li>a. Porque desenvolvedores escrevem c\u00f3digo antes dos testes.</li> </ul> <p>Falso. TDD prop\u00f5e exatamente o contr\u00e1rio: escrevemos o teste antes do c\u00f3digo. (Introdu\u00e7\u00e3o, Beck, 2002)</p> <ul> <li>b. Porque desenvolvedores focam no produto final.</li> </ul> <p>O foco est\u00e1 no comportamento incremental e test\u00e1vel, n\u00e3o no \"produto final\". (Cap\u00edtulo 4, Meszaros, 2007)</p> <ul> <li>c. Porque todos os testes s\u00e3o escritos antes da implementa\u00e7\u00e3o.</li> </ul> <p>N\u00e3o \u00e9 verdade. O TDD escreve um teste de cada vez, intercalado com c\u00f3digo. (Cap\u00edtulo 4, Meszaros, 2007)</p> <p>Refer\u00eancias: Beck, K. (2002). Test-Driven Development: By Example. Addison-Wesley. Meszaros, G. (2007). xUnit Test Patterns: Refactoring Test Code. Addison-Wesley.</p>"},{"location":"tpi_tpe/tpi4_tpe4/#q11-como-o-tdd-afeta-o-design","title":"Q11. Como o TDD afeta o design?","text":"<ul> <li>a. Testes n\u00e3o influenciam o design.</li> <li>b. O teste \u00e9 o primeiro cliente da classe, influenciando seu design.</li> <li>c. TDD encoraja designs mais complexos.</li> <li>d. TDD desencoraja refatora\u00e7\u00e3o.</li> </ul> <p>RESPOSTA: b. O teste \u00e9 o primeiro cliente da classe, influenciando seu design.</p> <p>O TDD incentiva designs simples e conjuntos de testes que inspiram confian\u00e7a. (Introdu\u00e7\u00e3o, Beck, 2002) TDD encourages simple designs and test suites that inspire confidence. (Introduction, Beck, 2002)</p> <p>Voc\u00ea escrever\u00e1 um teste. Imagine como gostaria que a opera\u00e7\u00e3o parecesse em seu c\u00f3digo. Voc\u00ea est\u00e1 escrevendo uma hist\u00f3ria. Invente a interface que gostaria de ter. (Cap\u00edtulo 2, Beck, 2002) Write a test. Think about how you would like the operation in your mind to appear in your code. You are writing a story. Invent the interface you wish you had. (Chapter 2, Beck, 2002)</p> <p>Como resultado, o teste se torna o primeiro cliente da classe, moldando seu design de forma natural, orientada por uso real. (Cap\u00edtulo 17, Beck, 2002) As a result, the test becomes the first client of the class, shaping its design naturally, based on actual usage. (Chapter 17, Beck, 2002)</p> <p>Cres\u00e7a o design organicamente, por meio de refatora\u00e7\u00f5es, adicionando decis\u00f5es de design uma de cada vez. (Introdu\u00e7\u00e3o, Beck, 2002) Grow a design organically by refactoring to add design decisions one at a time. (Introduction, Beck, 2002)</p>"},{"location":"tpi_tpe/tpi4_tpe4/#por-que-as-outras-alternativas-estao-erradas_10","title":"Por que as outras alternativas est\u00e3o erradas","text":"<ul> <li>a. Testes n\u00e3o influenciam o design.</li> </ul> <p>Falso. O TDD molda o design desde o in\u00edcio, com o teste sendo o primeiro cliente da API. (Cap\u00edtulo 17, Beck, 2002)</p> <ul> <li>c. TDD encoraja designs mais complexos.</li> </ul> <p>Pelo contr\u00e1rio, TDD incentiva designs simples e incrementais. (Introdu\u00e7\u00e3o, Beck, 2002)</p> <ul> <li>d. TDD desencoraja refatora\u00e7\u00e3o.</li> </ul> <p>Falso. Refatora\u00e7\u00e3o \u00e9 uma das etapas essenciais do ciclo TDD. (Cap\u00edtulo 2, Beck, 2002)</p> <p>Refer\u00eancia: Beck, K. (2002). Test-Driven Development: By Example. Addison-Wesley.</p>"},{"location":"tpi_tpe/tpi4_tpe4/#q12-quando-o-tdd-e-mais-vantajoso","title":"Q12. Quando o TDD \u00e9 mais vantajoso?","text":"<ul> <li>a. Em problemas simples.</li> <li>b. Em qualquer tipo de problema.</li> <li>c. Em projetos de manuten\u00e7\u00e3o.</li> <li>d. Em problemas mais complicados, onde ajuda a estruturar melhor o desenvolvimento.</li> </ul> <p>RESPOSTA: d. Em problemas mais complicados, onde ajuda a estruturar melhor o desenvolvimento.</p> <p>Desenvolvedores enfrentam desafios complexos de programa\u00e7\u00e3o todos os dias, e muitas vezes n\u00e3o est\u00e3o preparados para determinar a melhor solu\u00e7\u00e3o. Com frequ\u00eancia, tais projetos dif\u00edceis geram muito estresse e c\u00f3digo ruim. Para obter a for\u00e7a e a coragem necess\u00e1rias para superar tarefas aparentemente herc\u00faleas, os programadores devem recorrer ao desenvolvimento orientado por testes (TDD), um conjunto comprovado de t\u00e9cnicas que encorajam designs simples e test suites que inspiram confian\u00e7a. (Introdu\u00e7\u00e3o, Beck, 2002) Developers face complex programming challenges every day, yet they are not always readily prepared to determine the best solution. More often than not, such difficult projects generate a great deal of stress and bad code. To garner the strength and courage needed to surmount seemingly Herculean tasks, programmers should look to test-driven development (TDD), a proven set of techniques that encourage simple designs and test suites that inspire confidence. (Introduction, Beck, 2002)</p> <p>Ao conduzir o desenvolvimento com testes automatizados e depois eliminar duplica\u00e7\u00e3o, qualquer desenvolvedor pode escrever c\u00f3digo confi\u00e1vel e livre de erros, independentemente do n\u00edvel de complexidade. (Introdu\u00e7\u00e3o, Beck, 2002) By driving development with automated tests and then eliminating duplication, any developer can write reliable, bug-free code no matter what its level of complexity. (Introduction, Beck, 2002)</p> <p>Os leitores aprender\u00e3o a: - Resolver tarefas complicadas, come\u00e7ando pelas simples e seguindo para as mais complexas. - Escrever testes automatizados antes de codificar. - Criar testes para l\u00f3gica complicada, incluindo reflex\u00e3o e exce\u00e7\u00f5es. (Introdu\u00e7\u00e3o, Beck, 2002) Readers will learn to: - Solve complicated tasks, beginning with the simple and proceeding to the more complex. - Create tests for more complicated logic, including reflection and exceptions. (Introduction, Beck, 2002)</p> <p>Refer\u00eancia: Beck, K. (2002). Test-Driven Development: By Example. Addison-Wesley.</p>"},{"location":"tpi_tpe/tpi4_tpe4/#q13-em-quais-situacoes-o-uso-do-tdd-nao-e-recomendado","title":"Q13. Em quais situa\u00e7\u00f5es o uso do TDD n\u00e3o \u00e9 recomendado?","text":"<ul> <li>a. Quando o problema \u00e9 bem conhecido e n\u00e3o h\u00e1 necessidade de experimenta\u00e7\u00e3o.</li> <li>b. Quando se est\u00e1 em projetos \u00e1geis.</li> <li>c. Em sistemas embarcados.</li> <li>d. Quando a pir\u00e2mide de testes n\u00e3o \u00e9 aplicada.</li> </ul> <p>RESPOSTA: a. Quando o problema \u00e9 bem conhecido e n\u00e3o h\u00e1 necessidade de experimenta\u00e7\u00e3o.</p> <p>O desenvolvimento orientado a testes (TDD) \u00e9 especialmente \u00fatil em situa\u00e7\u00f5es em que n\u00e3o temos certeza de como estruturar a solu\u00e7\u00e3o ou estamos lidando com um problema desconhecido. (Cap\u00edtulo 2, Beck, 2002) Test-driven development is especially useful when we don\u2019t know how to structure the solution or we\u2019re tackling an unknown problem. (Chapter 2, Beck, 2002)</p> <p>Em contrapartida, quando j\u00e1 sabemos exatamente o que fazer e a estrutura do sistema est\u00e1 clara, o valor de escrever testes antes do c\u00f3digo \u00e9 reduzido. (Cap\u00edtulo 2, Beck, 2002) On the other hand, when we know exactly what to do and the structure is clear, the value of writing tests before the code is reduced. (Chapter 2, Beck, 2002)</p> <p>Em projetos onde \u00e9 necess\u00e1rio explorar o design, o ciclo de TDD ajuda a conduzir decis\u00f5es incrementais e iterativas. (Cap\u00edtulo 2, Beck, 2002) In projects where design exploration is needed, the TDD cycle helps guide incremental, iterative decisions. (Chapter 2, Beck, 2002)</p>"},{"location":"tpi_tpe/tpi4_tpe4/#por-que-as-outras-alternativas-estao-erradas_11","title":"Por que as outras alternativas est\u00e3o erradas","text":"<ul> <li>b. Quando se est\u00e1 em projetos \u00e1geis.</li> </ul> <p>TDD \u00e9 altamente recomendado em projetos \u00e1geis, pois favorece ciclos curtos de feedback e adapta\u00e7\u00e3o cont\u00ednua. (Cap\u00edtulo 1, Beck, 2002)</p> <ul> <li>c. Em sistemas embarcados.</li> </ul> <p>Nenhum dos livros consultados afirma que sistemas embarcados s\u00e3o incompat\u00edveis com TDD. A pr\u00e1tica pode ser mais dif\u00edcil, mas ainda aplic\u00e1vel com arquitetura apropriada. (N\u00e3o encontrado nos PDFs)</p> <ul> <li>d. Quando a pir\u00e2mide de testes n\u00e3o \u00e9 aplicada.</li> </ul> <p>A pir\u00e2mide de testes \u00e9 uma pr\u00e1tica auxiliar, n\u00e3o uma condi\u00e7\u00e3o para aplicar TDD. O TDD foca na escrita de testes automatizados de unidade, independentemente da estrutura completa de testes adotada. (N\u00e3o mencionado como limita\u00e7\u00e3o nos livros analisados)</p> <p>Refer\u00eancia: Beck, K. (2002). Test-Driven Development: By Example. Addison-Wesley.</p>"},{"location":"tpi_tpe/tpi4_tpe4/#q14-qual-a-eficacia-dos-testes-em-tdd","title":"Q14. Qual a efic\u00e1cia dos testes em TDD?","text":"<ul> <li>a. As su\u00edtes de TDD s\u00e3o superiores \u00e0s su\u00edtes sistem\u00e1ticas em v\u00e1rios aspectos.</li> <li>b. As su\u00edtes s\u00e3o equivalentes.</li> <li>c. S\u00e3o inferiores apenas em projetos pequenos.</li> <li>d. TDD foca em desenvolvimento e n\u00e3o gera testes eficazes.</li> </ul> <p>RESPOSTA: a. As su\u00edtes de TDD s\u00e3o superiores \u00e0s su\u00edtes sistem\u00e1ticas em v\u00e1rios aspectos.</p> <p>O TDD \u00e9 uma das pr\u00e1ticas centrais dos m\u00e9todos \u00e1geis, como o XP. Seu uso de testes automatizados se concentra mais na especifica\u00e7\u00e3o do comportamento do software ainda n\u00e3o escrito do que em testes de regress\u00e3o. (p. xxxiii, Meszaros, 2007) Test-driven development (TDD), which is one of the core practices of agile methods such as Extreme Programming. This use of automated testing is more about specification of the behavior of the software yet to be written than it is about regression testing. (p. xxxiii, Meszaros, 2007)</p> <p>A efic\u00e1cia do TDD vem da forma como ele nos permite separar o pensamento sobre o software em duas fases: o que ele deve fazer, e como ele deve fazer. (p. xxxiii, Meszaros, 2007) The effectiveness of TDD comes from the way it lets us separate our thinking about software into two separate phases: what it should do, and how it should do it. (p. xxxiii, Meszaros, 2007)</p> <p>Quando implementamos a funcionalidade de forma incremental, podemos ver cada teste passar, um por um, \u00e0 medida que escrevemos mais c\u00f3digo. \u00c9 aqui que reside o verdadeiro valor dos testes automatizados: na sua capacidade de \u201cfixar\u201d o comportamento esperado, garantindo que mudan\u00e7as posteriores n\u00e3o o modifiquem acidentalmente. (p. xxxiii, Meszaros, 2007) This is where the true value of automated unit testing lies: in its ability to \u201cpin down\u201d the functionality of the SUT so that the functionality is not changed accidentally. (p. xxxiii, Meszaros, 2007)</p> <p>O TDD permite a cria\u00e7\u00e3o de \u201cespecifica\u00e7\u00f5es execut\u00e1veis\u201d, que n\u00e3o apenas guiam o design como tamb\u00e9m servem de documenta\u00e7\u00e3o viva e confi\u00e1vel do sistema. (p. xxxiii, Meszaros, 2007) TDD enables the creation of \u201cexecutable specifications\u201d that not only guide design but also serve as reliable and living documentation of the system. (p. xxxiii, Meszaros, 2007)</p>"},{"location":"tpi_tpe/tpi4_tpe4/#por-que-as-outras-alternativas-estao-erradas_12","title":"Por que as outras alternativas est\u00e3o erradas","text":"<ul> <li>b. As su\u00edtes s\u00e3o equivalentes.</li> </ul> <p>O livro indica explicitamente que os testes em TDD t\u00eam papel mais amplo e profundo, tanto em design quanto em valida\u00e7\u00e3o \u2014 n\u00e3o sendo \"equivalentes\", mas sim mais eficazes em v\u00e1rios aspectos. (p. xxxiii, Meszaros, 2007)</p> <ul> <li>c. S\u00e3o inferiores apenas em projetos pequenos.</li> </ul> <p>Nenhum trecho sugere que as su\u00edtes TDD s\u00e3o inferiores em qualquer contexto; pelo contr\u00e1rio, s\u00e3o recomendadas mesmo para sistemas complexos. (p. xxxiii, Meszaros, 2007)</p> <ul> <li>d. TDD foca em desenvolvimento e n\u00e3o gera testes eficazes.</li> </ul> <p>TDD produz testes eficazes, que funcionam como especifica\u00e7\u00f5es automatizadas e garantem confiabilidade cont\u00ednua do sistema. (p. xxxiii, Meszaros, 2007)</p> <p>Refer\u00eancia: Meszaros, G. (2007). xUnit Test Patterns: Refactoring Test Code. Addison-Wesley.</p>"}]}