{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#testes-de-software-20251","title":"Testes de Software (2025.1)","text":"<p>Documenta\u00e7\u00e3o pessoal sobre Testes de Software, desenvolvida como apoio aos estudos da disciplina cursada na gradua\u00e7\u00e3o em Engenharia de Software.</p> <ul> <li>xUnit Test Patterns (Meszaros, 2007)</li> <li>Test-Driven Development: By Example (Kent Beck, 2002)</li> <li>The Art of Software Testing (Glenford J. Myers, 2011)</li> </ul>"},{"location":"aae3/aae3/","title":"1. Relat\u00f3rio de Cobertura MC/DC \u2014 Atividade AAE-3","text":""},{"location":"aae3/aae3/#11-objetivo","title":"1.1 Objetivo","text":"<p>Elaborar o menor conjunto de casos de teste que garanta 100% de cobertura segundo o crit\u00e9rio MC/DC para o m\u00e9todo <code>isNumber(String number)</code> abaixo:</p> <pre><code>public boolean isNumber(String number) {\n    if (number == null || number.isEmpty()) {\n        return false;\n    }\n\n    if (number.length() == 1 &amp;&amp; (number.charAt(0) == '-' || number.charAt(0) == '+')) {\n        return false;\n    }\n\n    for (int i = 0; i &lt; number.length(); i++) {\n        char c = number.charAt(i);\n\n        if (i == 0 &amp;&amp; (c == '-' || c == '+')) {\n            continue;\n        } else if (!Character.isDigit(c)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n</code></pre>"},{"location":"aae3/aae3/#12-recapitulando-mcdc","title":"1.2 Recapitulando MC/DC","text":"<p>MC/DC (Cobertura de Decis\u00e3o/Condi\u00e7\u00e3o Modificada) \u00e9 uma t\u00e9cnica de teste que exige:</p> <ol> <li>Que cada condi\u00e7\u00e3o booleana dentro de uma decis\u00e3o seja avaliada como verdadeira e falsa.</li> <li>Que, para cada condi\u00e7\u00e3o, seja demonstrado que ela, isoladamente, pode alterar o resultado da decis\u00e3o.</li> </ol>"},{"location":"aae3/aae3/#exemplo-if-a-b","title":"Exemplo: <code>if (A &amp;&amp; B)</code>","text":"Caso A B Resultado O que muda? D-Ex-T1 F V F Base para testar A D-Ex-T2 V V V (B = V; A muda F \u2192 V; resultado muda F \u2192 V) \u2713 D-Ex-T3 V F F Base para testar B D-Ex-T4 V V V (A = V; B muda F \u2192 V; resultado muda F \u2192 V) \u2713"},{"location":"aae3/aae3/#decisoes-validas-em-mcdc","title":"Decis\u00f5es v\u00e1lidas em MC/DC","text":"<p>Uma decis\u00e3o v\u00e1lida \u00e9 qualquer express\u00e3o booleana que:</p> <ul> <li>Controle o fluxo (<code>if</code>, <code>while</code>, <code>for</code>, <code>else if</code> etc.).</li> <li>Seja composta por duas ou mais condi\u00e7\u00f5es ligadas por <code>&amp;&amp;</code> ou <code>||</code>.</li> <li>Permita que cada condi\u00e7\u00e3o, isoladamente, altere o resultado.</li> </ul> <p>Nota:</p> <ul> <li>Condi\u00e7\u00f5es de la\u00e7o sem m\u00faltiplas vari\u00e1veis (ex.: <code>i &lt; n</code> em <code>for</code>) n\u00e3o precisam de MC/DC.</li> </ul>"},{"location":"aae3/aae3/#2-primeira-decisao-linha-2","title":"2. Primeira decis\u00e3o (linha 2)","text":"<pre><code>if (number == null || number.isEmpty()) {\n    return false;\n}\n</code></pre> <ul> <li>C1: <code>number == null</code></li> <li>C2: <code>number.isEmpty()</code></li> </ul>"},{"location":"aae3/aae3/#estrutura-logica","title":"Estrutura l\u00f3gica","text":"<pre><code>C1 || C2\n</code></pre> <p>Se a string for nula ou estiver vazia, retorna false</p>"},{"location":"aae3/aae3/#tabela-verdade-de-c1-c2","title":"Tabela-verdade de <code>C1 || C2</code>","text":"Caso C1 C2 Resultado D1-T1 F F F D1-T2 F V V D1-T3 V F V D1-T4 V V V"},{"location":"aae3/aae3/#pares-mcdc","title":"Pares MC/DC","text":"<ul> <li>C1: (C2 = F; C1 muda F \u2192 V; resultado muda F \u2192 V) \u2014 D1-T1 vs D1-T3</li> <li>C2: (C1 = F; C2 muda F \u2192 V; resultado muda F \u2192 V) \u2014 D1-T1 vs D1-T2</li> </ul>"},{"location":"aae3/aae3/#3-segunda-decisao-linha-5","title":"3. Segunda decis\u00e3o (linha 5)","text":"<pre><code>if (number.length() == 1 &amp;&amp; (number.charAt(0) == '-' || number.charAt(0) == '+')) {\n    return false;\n}\n</code></pre> <ul> <li>C3: <code>number.length() == 1</code></li> <li>C4: <code>number.charAt(0) == '-'</code></li> <li>C5: <code>number.charAt(0) == '+'</code></li> </ul>"},{"location":"aae3/aae3/#estrutura-logica_1","title":"Estrutura l\u00f3gica","text":"<pre><code>C3 &amp;&amp; (C4 || C5)\n</code></pre> <p>Se h\u00e1 um caractere e ele \u00e9 \u2018-\u2019 ou \u2018+\u2019, retorna false</p>"},{"location":"aae3/aae3/#tabela-verdade-de-c3-c4-c5","title":"Tabela-verdade de <code>C3 &amp;&amp; (C4 || C5)</code>","text":"Caso C3 C4 C5 Resultado D2-T1 V V F V D2-T2 V F V V D2-T3 V F F F D2-T4 F \u2013 \u2013 F"},{"location":"aae3/aae3/#pares-mcdc_1","title":"Pares MC/DC","text":"<ul> <li>C3: (C4 = V; C5 = F; C3 muda V \u2192 F; resultado muda V \u2192 F) \u2014 D2-T1 vs D2-T4</li> <li>C4: (C3 = V; C5 = F; C4 muda V \u2192 F; resultado muda V \u2192 F) \u2014 D2-T1 vs D2-T3</li> <li>C5: (C3 = V; C4 = F; C5 muda V \u2192 F; resultado muda V \u2192 F) \u2014 D2-T2 vs D2-T3</li> </ul>"},{"location":"aae3/aae3/#4-terceira-decisao-linha-10","title":"4. Terceira decis\u00e3o (linha 10)","text":"<pre><code>if (i == 0 &amp;&amp; (c == '-' || c == '+')) {\n    continue;\n}\n</code></pre> <ul> <li>C6: <code>i == 0</code></li> <li>C7: <code>c == '-'</code></li> <li>C8: <code>c == '+'</code></li> </ul>"},{"location":"aae3/aae3/#estrutura-logica_2","title":"Estrutura l\u00f3gica","text":"<pre><code>C6 &amp;&amp; (C7 || C8)\n</code></pre> <p>Se \u00e9 o primeiro caractere e ele \u00e9 \u2018-\u2019 ou \u2018+\u2019, ignora e segue</p>"},{"location":"aae3/aae3/#tabela-verdade-de-c6-c7-c8","title":"Tabela-verdade de <code>C6 &amp;&amp; (C7 || C8)</code>","text":"Caso C6 C7 C8 Resultado D3-T1 F \u2013 \u2013 F D3-T2 V V F V D3-T3 V F V V D3-T4 V F F F"},{"location":"aae3/aae3/#pares-mcdc_2","title":"Pares MC/DC","text":"<ul> <li>C6: (C7 = V; C8 = F; C6 muda F \u2192 V; resultado muda F \u2192 V) \u2014 D3-T1 vs D3-T2</li> <li>C7: (C6 = V; C8 = F; C7 muda V \u2192 F; resultado muda V \u2192 F) \u2014 D3-T2 vs D3-T4</li> <li>C8: (C6 = V; C7 = F; C8 muda V \u2192 F; resultado muda V \u2192 F) \u2014 D3-T3 vs D3-T4</li> </ul>"},{"location":"aae3/aae3/#5-resumo-dos-pares-mcdc","title":"5. Resumo dos pares MC/DC","text":"<ul> <li>Decis\u00e3o 1 (C1, C2): D1-T1 vs D1-T3; D1-T1 vs D1-T2</li> <li>Decis\u00e3o 2 (C3, C4, C5): D2-T1 vs D2-T4; D2-T1 vs D2-T3; D2-T2 vs D2-T3</li> <li>Decis\u00e3o 3 (C6, C7, C8): D3-T1 vs D3-T2; D3-T2 vs D3-T4; D3-T3 vs D3-T4</li> </ul>"},{"location":"aae3/aae3/#6-conclusao","title":"6. Conclus\u00e3o","text":"<p>Com o conjunto de 12 casos de teste (D1-T1 a D1-T4, D2-T1 a D2-T4 e D3-T1 a D3-T4), cada condi\u00e7\u00e3o C1\u2013C8 foi avaliada como verdadeira e falsa e demonstrou, isoladamente, sua capacidade de alterar o resultado da decis\u00e3o. Assim, alcan\u00e7amos 100% de cobertura segundo o crit\u00e9rio MC/DC para o m\u00e9todo <code>isNumber</code>.</p>"},{"location":"aae3/aae3/#7-referencias-bibliograficas","title":"7. Refer\u00eancias Bibliogr\u00e1ficas","text":"<ol> <li>Myers, G. J., Sandler, C., &amp; Badgett, T. (2011). The Art of Software Testing (3rd ed.). Wiley. pp. 46\u201348.</li> <li>RTCA/DO-178C. (2011). Software Considerations in Airborne Systems and Equipment Certification. RTCA.</li> <li>ISO/IEC/IEEE 29119. (2013). Software and Systems Engineering \u2014 Software Testing. ISO/IEC/IEEE.</li> </ol>"},{"location":"aae3/mc_dc/","title":"Modified Condition/Decision Coverage (MC/DC)","text":"<p>O Modified Condition/Decision Coverage (MC/DC) \u00e9 um dos crit\u00e9rios de cobertura estrutural mais exigentes para software de alta criticidade (por exemplo: avia\u00e7\u00e3o, automotivo, ferrovi\u00e1rio, etc.). O MC/DC est\u00e1 definido na norma DO-178B/C da FAA e \u00e9 referenciado em normas como ISO 26262 (automotiva) e IEC 61508 (industrial). Uma apresenta\u00e7\u00e3o detalhada pode ser encontrada em Hayhurst et al. (2001).</p> <p>Veja uma explica\u00e7\u00e3o pr\u00e1tica e visual no v\u00eddeo a seguir:</p>"},{"location":"aae3/mc_dc/#1-definicao-formal","title":"1. Defini\u00e7\u00e3o Formal","text":"<p>De acordo com o DO-178C </p> <p>O MC/DC requer que, para cada decis\u00e3o (uma express\u00e3o booleana composta) no c\u00f3digo, sejam atendidos simultaneamente:</p> <ol> <li>Cada ponto de entrada e sa\u00edda seja invocado ao menos uma vez.</li> <li>A decis\u00e3o tome cada um de seus poss\u00edveis resultados (verdadeiro/falso).</li> <li>Cada condi\u00e7\u00e3o atinja cada valor (verdadeiro/falso) ao menos uma vez.</li> <li>Cada condi\u00e7\u00e3o seja mostrada como tendo influ\u00eancia independente sobre o resultado da decis\u00e3o, mudando-a quando somente ela for invertida, mantendo-se fixas todas as demais.</li> </ol> <p>O item 4 \u00e9 o que diferencia o MC/DC: deve-se provar que apenas invertendo uma condi\u00e7\u00e3o \u2014 sem alterar as demais \u2014 o resultado da decis\u00e3o tamb\u00e9m inverte.</p>"},{"location":"aae3/mc_dc/#2-exemplo-pratico","title":"2. Exemplo Pr\u00e1tico","text":"<p>Considere a decis\u00e3o:</p> <pre><code>D = A &amp;&amp; B &amp;&amp; C\n</code></pre> Caso A B C D = A\u2227B\u2227C 1 True True True True 2 True True False False 3 True False True False 4 True False False False 5 False True True False 6 False True False False 7 False False True False 8 False False False False <p>Para atingir 100\u202f% de MC/DC, al\u00e9m de cobrir as condi\u00e7\u00f5es e decis\u00f5es, precisamos demonstrar a independ\u00eancia de cada condi\u00e7\u00e3o.</p>"},{"location":"aae3/mc_dc/#21-independencia-de-a","title":"2.1. Independ\u00eancia de A","text":"<p>Mant\u00e9m B = True e C = True, varia apenas A:</p> Caso A B C D = A\u2227B\u2227C 1 True True True True 5 False True True False"},{"location":"aae3/mc_dc/#22-independencia-de-b","title":"2.2. Independ\u00eancia de B","text":"<p>Mant\u00e9m A = True e C = True, varia apenas B:</p> Caso A B C D = A\u2227B\u2227C 1 True True True True 3 True False True False"},{"location":"aae3/mc_dc/#23-independencia-de-c","title":"2.3. Independ\u00eancia de C","text":"<p>Mant\u00e9m A = True e B = True, varia apenas C:</p> Caso A B C D = A\u2227B\u2227C 1 True True True True 2 True True False False"},{"location":"aae3/mc_dc/#3-vantagens-e-aplicacoes","title":"3. Vantagens e Aplica\u00e7\u00f5es","text":"<ul> <li>Redu\u00e7\u00e3o de riscos: garante que cada condi\u00e7\u00e3o individualmente impacta o resultado, revelando erros mascarados.</li> <li>Requisito normativo: n\u00edvel A em avia\u00e7\u00e3o exige 100\u202f% MC/DC (DO-178C, Tabela A-7); tamb\u00e9m recomendado para SIL\u202f4 (IEC\u00a061508) e ASIL\u202fD (ISO\u00a026262).</li> <li>Efici\u00eancia: exige menos testes que a cobertura de todas as combina\u00e7\u00f5es (Multiple Condition Coverage), mantendo rigor.</li> </ul>"},{"location":"aae3/mc_dc/#4-referencias-bibliograficas","title":"4. Refer\u00eancias Bibliogr\u00e1ficas","text":"<ol> <li>Kelly\u00a0J. Hayhurst, Dan\u00a0S. Veerhusen, John\u00a0D. Chilenski e Leanna\u00a0R. Rierson. A Practical Tutorial on Modified Condition/Decision Coverage, NASA TM-2001-210876, 2001.</li> <li>FAA. Guidelines for the Use of the Modified Condition/Decision Coverage (MC/DC) Criterion, CAST-10, 2020.</li> <li>RTCA/DO-178C. Software Considerations in Airborne Systems and Equipment Certification, 2011.</li> <li>ISO\u00a026262:2011. Road vehicles \u2013 Functional safety, Parte\u00a06.</li> <li>IEC\u00a061508-3:2010. Functional safety of electrical/electronic/programmable electronic safety-related systems, Anexo\u00a0B.</li> <li>Myers, G. J., Sandler, C., &amp; Badgett, T. (2011). The Art of Software Testing (3rd ed.). Wiley. pp. 46\u201348.</li> </ol>"},{"location":"aae3/unit_test/","title":"Unit test","text":""},{"location":"aae3/unit_test/#3-piramide-de-testes","title":"3. Pir\u00e2mide de Testes","text":"<p>A Pir\u00e2mide de Testes ilustra como equilibrar velocidade, custo e cobertura ao estruturar sua su\u00edte de testes (Meszaros, 2007):</p> <p></p> N\u00edvel Quantidade de Testes Custo por Teste Velocidade de Execu\u00e7\u00e3o Exemplos de Ferramentas Aceita\u00e7\u00e3o Baixa Alto Muito Lenta Cucumber, Robot Framework Sistema M\u00e9dia M\u00e9dio Lenta Selenium, TestComplete Integra\u00e7\u00e3o M\u00e9dia\u2013Alta Baixo\u2013M\u00e9dio Moderada Pytest + Docker Compose, Postman Unidade Alta Baixo Muito R\u00e1pida pytest, unittest, Jest <ul> <li>Unidade (base) </li> <li>O que: Testes de fun\u00e7\u00e3o/m\u00e9todo isolado.  </li> <li>Por que: R\u00e1pidos e baratos; detectam defeitos de l\u00f3gica interna antes de integrar depend\u00eancias.  </li> <li>Integra\u00e7\u00e3o (camada intermedi\u00e1ria) </li> <li>O que: Testes de m\u00faltiplos m\u00f3dulos funcionando juntos (por exemplo, servi\u00e7o + banco de dados).  </li> <li>Por que: Verifica contratos/interfaces, detecta erros de comunica\u00e7\u00e3o e configura\u00e7\u00e3o.  </li> <li>Sistema (\u00faltima camada antes da aceita\u00e7\u00e3o) </li> <li>O que: Testes fim-a-fim que exercitam todo o sistema em ambiente real ou simulado.  </li> <li>Por que: Confirma fluxo completo (UI \u2192 backend \u2192 DB), mas custa mais manter.  </li> <li>Aceita\u00e7\u00e3o (topo) </li> <li>O que: Valida\u00e7\u00e3o contra requisitos de neg\u00f3cio por meio de cen\u00e1rios escritos em linguagem natural.  </li> <li>Por que: Garante que o software atenda \u00e0s expectativas do usu\u00e1rio, mas demora para rodar.</li> </ul> <p>Eixos - Velocidade: decresce de unidades \u2192 aceita\u00e7\u00e3o. - Custo: cresce de unidades \u2192 aceita\u00e7\u00e3o. - Quantidade: cresce de aceita\u00e7\u00e3o \u2192 unidades.</p>"},{"location":"aae3/unit_test/#4-outros-formatos-de-estrategia","title":"4. Outros Formatos de Estrat\u00e9gia","text":""},{"location":"aae3/unit_test/#a-the-testing-trophy","title":"A. The Testing Trophy","text":"<p>Desenvolvida por Kent C. Dodds para aplica\u00e7\u00f5es web modernas:</p> <p></p> <ul> <li>Static: detec\u00e7\u00e3o de erros sem execu\u00e7\u00e3o (ESLint, mypy).  </li> <li>Unit: l\u00f3gica interna (Jest, pytest).  </li> <li>Integration: contratos entre m\u00f3dulos (Testing Library, pytest-docker).  </li> <li>End to End: simula\u00e7\u00e3o completa de usu\u00e1rio (Cypress, Playwright).   <p>Meta: Keep static and unit tests em larga quantidade, reduzindo gradualmente at\u00e9 E2E (Dodds, 2020).</p> </li> </ul>"},{"location":"aae3/unit_test/#b-microservices-test-strategy","title":"B. Microservices Test Strategy","text":"<p>Abordagem do Spotify Labs para arquiteturas de microsservi\u00e7os:</p> <ol> <li>Implementation Detail: validar l\u00f3gica isolada de cada servi\u00e7o (testes de unidade profundas).  </li> <li>Integration: testar comunica\u00e7\u00e3o entre pares de servi\u00e7os (contratos de API).  </li> <li>Integrated: executar conjunto completo de microsservi\u00e7os simulando produ\u00e7\u00e3o (fluxos end-to-end).   <p>Recomenda\u00e7\u00e3o: minimizar testes de detalhe interno, focar em Integration e Integrated (Spotify Labs, 2019).</p> </li> </ol>"},{"location":"aae3/unit_test/#5-niveis-de-teste-beneficios","title":"5. N\u00edveis de Teste \u2013 Benef\u00edcios","text":"<ol> <li>Evita redund\u00e2ncia </li> <li>Cada n\u00edvel foca em diferentes categorias de defeitos (Myers et al., 2012).  </li> <li>Custo x Risco </li> <li>Detectar cedo (unidade) corrige barato; detectar tarde (aceita\u00e7\u00e3o) corrige caro.  </li> <li>Escalabilidade </li> <li>Pequenos projetos podem parar em integra\u00e7\u00e3o; projetos cr\u00edticos devem chegar \u00e0 aceita\u00e7\u00e3o.  </li> </ol>"},{"location":"aae3/unit_test/#6-niveis-de-teste-consideracoes","title":"6. N\u00edveis de Teste \u2013 Considera\u00e7\u00f5es","text":"<ul> <li>N\u00e3o s\u00e3o sequenciais: escolha n\u00edveis conforme risco, or\u00e7amento e complexidade do projeto.  </li> <li>Fatores a influenciar a estrat\u00e9gia: </li> <li>Grau de acoplamento e coes\u00e3o do sistema.  </li> <li>Frequ\u00eancia de mudan\u00e7as nos componentes.  </li> <li>Recursos de infraestrutura (tempo de build, ambientes de teste).  </li> </ul>"},{"location":"aae3/unit_test/#7-diagrama-de-correspondencia-de-niveis","title":"7. Diagrama de Correspond\u00eancia de N\u00edveis","text":""},{"location":"aae3/unit_test/#8-lista-de-niveis-de-teste","title":"8. Lista de N\u00edveis de Teste","text":"<ol> <li>Unidade \u2013 testar o menor bloco de c\u00f3digo isoladamente.  </li> <li>Integra\u00e7\u00e3o \u2013 validar a intera\u00e7\u00e3o entre m\u00f3dulos.  </li> <li>Fun\u00e7\u00e3o \u2013 foco em funcionalidades discretas, similar a testes de sistema menores.  </li> <li>Sistema \u2013 testes de ponta a ponta num ambiente completo.  </li> <li>Aceita\u00e7\u00e3o \u2013 valida\u00e7\u00e3o contra crit\u00e9rios de aceite do cliente.</li> </ol>"},{"location":"aae3/unit_test/#9-testes-de-unidade","title":"9. Testes de Unidade","text":"<p>Defini\u00e7\u00e3o (Myers, 2012): Processo de testar fun\u00e7\u00f5es, m\u00e9todos, procedimentos, sub-rotinas ou subprogramas individualmente, garantindo que cada unidade isolada se comporte conforme a especifica\u00e7\u00e3o.</p> <ul> <li>Objetivo: verificar o menor elemento test\u00e1vel de um software.  </li> <li>Procedural: fun\u00e7\u00e3o ou procedimento.  </li> <li>Orientado a objeto: m\u00e9todo de classe.  </li> <li>Respons\u00e1vel: geralmente o desenvolvedor.  </li> <li>Enfoque: algoritmos e l\u00f3gica de programa\u00e7\u00e3o.  </li> <li>T\u00e9cnicas: tipicamente caixa-branca, complementada por caixa-preta.</li> </ul> <p>Motiva\u00e7\u00f5es: - Gerenciar incrementalmente os elementos do teste. - Facilitar a depura\u00e7\u00e3o (localiza\u00e7\u00e3o de defeitos). - Permitir paralelismo na execu\u00e7\u00e3o dos testes.</p>"},{"location":"aae3/unit_test/#91-ferramentas-em-python","title":"9.1. Ferramentas em Python","text":"Ferramenta Caracter\u00edsticas Refer\u00eancia <code>unittest</code> Framework padr\u00e3o, estilo xUnit. Python Software Foundation (2024). <code>pytest</code> Sintaxe concisa, fixtures, parametriza\u00e7\u00e3o e plugins. pytest Documentation (2024). <code>coverage.py</code> Medi\u00e7\u00e3o de cobertura de c\u00f3digo. Ned Batchelder (2024)."},{"location":"aae3/unit_test/#92-exemplo-simples-funcao-is_even","title":"9.2. Exemplo Simples: Fun\u00e7\u00e3o <code>is_even</code>","text":"<pre><code># utils.py\ndef is_even(n: int) -&gt; bool:\n    \"\"\"\n    Retorna True se n for par, False caso contr\u00e1rio.\n    \"\"\"\n    return n % 2 == 0\n</code></pre>"},{"location":"aae3/unit_test/#921-testes-com-pytest","title":"9.2.1. Testes com <code>pytest</code>","text":"<pre><code># tests/test_utils.py\nimport pytest\nfrom utils import is_even\n\n@pytest.mark.parametrize(\"input,expected\", [\n    (0, True),\n    (1, False),\n    (2, True),\n    (99, False),\n])\ndef test_is_even(input, expected):\n    assert is_even(input) == expected\n</code></pre> <ul> <li>Casos de teste:</li> <li><code>0</code> \u2192 <code>True</code></li> <li><code>1</code> \u2192 <code>False</code></li> <li><code>2</code> \u2192 <code>True</code></li> <li><code>99</code> \u2192 <code>False</code></li> </ul>"},{"location":"aae3/unit_test/#922-teste-caixa-branca-cobertura-de-decisao","title":"9.2.2. Teste Caixa-Branca (Cobertura de Decis\u00e3o)","text":"<pre><code>def test_is_even_branches():\n    # testa tanto o ramo True quanto o ramo False\n    assert is_even(4) is True\n    assert is_even(5) is False\n</code></pre> <ul> <li>Com isso garantimos que ambas as sa\u00eddas (<code>True</code> e <code>False</code>) ocorram ao menos uma vez.</li> </ul>"},{"location":"aae3/unit_test/#93-criterios-de-cobertura","title":"9.3. Crit\u00e9rios de Cobertura","text":"Crit\u00e9rio Descri\u00e7\u00e3o Cobertura de decis\u00f5es Garante que <code>n % 2 == 0</code> avalie <code>True</code> e <code>False</code> Cobertura de instru\u00e7\u00f5es Garante execu\u00e7\u00e3o da \u00fanica linha da fun\u00e7\u00e3o <pre><code># Gerando relat\u00f3rio de cobertura\ncoverage run -m pytest &amp;&amp; coverage report -m\n</code></pre> <pre><code>Name           Stmts   Miss  Cover\n----------------------------------\nutils.py           3      0   100%\n</code></pre>"},{"location":"aae3/unit_test/#12-referencias-bibliograficas","title":"12. Refer\u00eancias Bibliogr\u00e1ficas","text":"<ul> <li>Myers, G. J., Sandler, C., &amp; Badgett, T. (2012). The Art of Software Testing. John Wiley &amp; Sons.  </li> <li>pytest Development Team. (2024). pytest documentation. Retrieved from https://docs.pytest.org/  </li> <li>Ned Batchelder. (2024). coverage.py documentation. Retrieved from https://coverage.readthedocs.io/  </li> <li>Meszaros, G. (2007). xUnit Test Patterns: Refactoring Test Code. Addison-Wesley.  </li> <li>Dodds, K. C. (2020). The Testing Trophy.  </li> <li>Spotify Labs. (2019). Microservices Test Strategy</li> </ul>"},{"location":"aae3/white_box_test/","title":"Cap\u00edtulo 4 \u2013  Teste de Caixa Branca","text":"<p>Outra estrat\u00e9gia de teste, o teste de caixa branca (ou orientado por l\u00f3gica), permite que voc\u00ea examine a estrutura interna do programa. Essa estrat\u00e9gia deriva dados de teste de um exame da l\u00f3gica do programa (e muitas vezes, infelizmente, negligenciando a especifica\u00e7\u00e3o).</p> <p>O objetivo neste ponto \u00e9 estabelecer, para esta estrat\u00e9gia, o teste de entrada an\u00e1logo ao exaustivo na abordagem de caixa preta. Fazer com que todas as instru\u00e7\u00f5es do programa sejam executadas pelo menos uma vez pode parecer ser a resposta, mas n\u00e3o \u00e9 dif\u00edcil mostrar que isso \u00e9 altamente inadequado. Sem insistir no ponto aqui, uma vez que esse assunto \u00e9 discutido com mais profundidade no Cap\u00edtulo 4, o an\u00e1logo geralmente \u00e9 considerado um teste de caminho exaustivo. Ou seja, se voc\u00ea executar, via casos de teste, todos os caminhos poss\u00edveis de controle fluem pelo programa, ent\u00e3o, possivelmente, o programa foi completamente testado.</p> <p>Existem duas falhas nesta afirma\u00e7\u00e3o, no entanto. Uma \u00e9 que o n\u00famero de caminhos l\u00f3gicos \u00fanicos atrav\u00e9s de um programa pode ser astronomicamente grande. Para ver isso, considere o programa trivial representado na Figura 2.1. O diagrama \u00e9 um gr\u00e1fico de fluxo de controle. Cada n\u00f3 ou c\u00edrculo representa um segmento de instru\u00e7\u00f5es que s\u00e3o executadas sequencialmente, possivelmente terminando com uma branching statement. Cada aresta ou arco representa uma transfer\u00eancia de controle (ramifica\u00e7\u00e3o) entre segmentos. O diagrama, ent\u00e3o, descreve um programa de 10 a 20 instru\u00e7\u00f5es que consiste em um loop DO que itera at\u00e9 20 vezes. Dentro do corpo do loop DO, h\u00e1 um conjunto de instru\u00e7\u00f5es IF aninhadas. Determinar o n\u00famero de caminhos l\u00f3gicos \u00fanicos \u00e9 o mesmo que determinar o n\u00famero total de maneiras \u00fanicas de se mover do ponto A para o ponto B (assumindo que todas as decis\u00f5es no programa s\u00e3o independentes umas das outras). Este n\u00famero \u00e9 aproximadamente 10\u00b9\u2074.</p> <p>FIGURA 2.1: Gr\u00e1fico de fluxo de controle de um pequeno programa.</p> <p>100 trilh\u00f5es. \u00c9 calculado a partir de 5\u00b2\u2070 + 5\u00b9\u2079 + ... + 5\u00b9, onde 5 \u00e9 o n\u00famero de caminhos atrav\u00e9s do corpo do loop. A maioria das pessoas tem dificuldade em visualizar esse n\u00famero, ent\u00e3o considere desta forma: se voc\u00ea pudesse escrever, executar e verificar um caso de teste a cada cinco minutos, levaria aproximadamente 1 bilh\u00e3o de anos para tentar todos os caminhos. Se voc\u00ea fosse 300 vezes mais r\u00e1pido, completando um teste uma vez por segundo, voc\u00ea poderia completar o trabalho em 3,2 milh\u00f5es de anos, dar ou tirar alguns anos bissextos e s\u00e9culos.</p> <p>\u00c9 claro que, em programas reais, todas as decis\u00f5es n\u00e3o s\u00e3o independentes de todas as outras decis\u00f5es, o que significa que o n\u00famero de caminhos de execu\u00e7\u00e3o poss\u00edveis seria um pouco menor. Por outro lado, os programas reais s\u00e3o muito maiores do que o programa simples representado na Figura 2.1. Portanto, testes exaustivos de caminho, como testes exaustivos de entrada, parecem ser impratic\u00e1veis, se n\u00e3o imposs\u00edveis.</p> <p>A segunda falha na afirma\u00e7\u00e3o \"teste de caminho exaustivo significa um teste completo\" \u00e9 que todos os caminhos em um programa podem ser testados, mas o programa ainda pode estar carregado de erros. Existem tr\u00eas explica\u00e7\u00f5es para isso.</p> <p>A primeira \u00e9 que um teste exaustivo de trajet\u00f3ria n\u00e3o garante, de forma alguma, que um programa corresponda \u00e0 sua especifica\u00e7\u00e3o. Por exemplo, se voc\u00ea fosse solicitado a escrever uma rotina de classifica\u00e7\u00e3o em ordem crescente, mas produzisse por engano uma rotina de classifica\u00e7\u00e3o em ordem decrescente, o teste de caminho exaustivo seria de pouco valor; o programa ainda tem um bug: \u00e9 o programa errado, pois n\u00e3o atende \u00e0 especifica\u00e7\u00e3o.</p> <p>Em segundo lugar, um programa pode estar incorreto devido a caminhos ausentes. O teste exaustivo de caminho, \u00e9 claro, n\u00e3o detectaria a aus\u00eancia de caminhos necess\u00e1rios.</p> <p>Terceiro, um teste de caminho exaustivo pode n\u00e3o revelar erros de confidencialidade de dados. Existem muitos exemplos de tais erros, mas um simples deve ser suficiente. Suponha que, em um programa, voc\u00ea tenha que comparar dois n\u00fameros para converg\u00eancia, isto \u00e9, para ver se a diferen\u00e7a entre os dois n\u00fameros \u00e9 menor do que algum valor predeterminado. Por exemplo, voc\u00ea pode escrever uma instru\u00e7\u00e3o Java IF como:</p> <pre><code>if (a - b &lt; c)\n    System.out.println(\"a - b &lt; c\");\n</code></pre> <p>Claro, a declara\u00e7\u00e3o cont\u00e9m um erro porque deveria comparar <code>c</code> com o valor absoluto de <code>a - b</code>. A detec\u00e7\u00e3o desse erro, no entanto, depende dos valores usados para <code>a</code> e <code>b</code>, e n\u00e3o seria necessariamente detectada apenas executando todos os caminhos do programa.</p> <p>Em conclus\u00e3o, embora o teste exaustivo de entrada seja superior ao teste de caminho exaustivo, nenhum deles se mostra \u00fatil porque ambos s\u00e3o invi\u00e1veis. Talvez, ent\u00e3o, existam maneiras de combinar elementos de teste de caixa preta e caixa branca para derivar uma estrat\u00e9gia de teste razo\u00e1vel, mas n\u00e3o herm\u00e9tica. Este assunto \u00e9 aprofundado no Cap\u00edtulo 4.</p>"},{"location":"aae3/white_box_test/#principios-de-teste-de-software","title":"Princ\u00edpios de teste de software","text":""},{"location":"aae3/white_box_test/#tabela-21-diretrizes-de-teste-de-programas","title":"Tabela 2.1 \u2013 Diretrizes de teste de programas","text":"N\u00ba Princ\u00edpio 1 Uma parte necess\u00e1ria de um caso de teste \u00e9 uma defini\u00e7\u00e3o da sa\u00edda ou resultado esperado. 2 Um programador deve evitar tentar testar seu pr\u00f3prio programa. 3 Uma organiza\u00e7\u00e3o de programa\u00e7\u00e3o n\u00e3o deve testar seus pr\u00f3prios programas. 4 Qualquer processo de teste deve incluir uma inspe\u00e7\u00e3o completa dos resultados de cada teste. 5 Os casos de teste devem ser gravados para condi\u00e7\u00f5es de entrada inv\u00e1lidas e inesperadas, bem como para aquelas que s\u00e3o v\u00e1lidas e esperadas. 6 Examinar um programa para ver se ele n\u00e3o faz o que deveria fazer \u00e9 apenas metade da batalha; a outra metade \u00e9 ver se o programa faz o que n\u00e3o deveria fazer. 7 Evite casos de teste descart\u00e1veis, a menos que o programa seja realmente um programa descart\u00e1vel. 8 N\u00e3o planeje um esfor\u00e7o de teste sob a suposi\u00e7\u00e3o t\u00e1cita de que nenhum erro ser\u00e1 encontrado. 9 A probabilidade da exist\u00eancia de mais erros em uma se\u00e7\u00e3o de um programa \u00e9 proporcional ao n\u00famero de erros j\u00e1 encontrados nessa se\u00e7\u00e3o. 10 O teste \u00e9 uma tarefa extremamente criativa e intelectualmente desafiadora. <p>Continuando com a premissa principal deste cap\u00edtulo, de que as considera\u00e7\u00f5es mais importantes no teste de software s\u00e3o quest\u00f5es de psicologia, podemos identificar um conjunto de princ\u00edpios ou diretrizes vitais de teste. A maioria desses princ\u00edpios pode parecer \u00f3bvia, mas muitas vezes s\u00e3o negligenciados. A Tabela 2.1 resume esses princ\u00edpios importantes, e cada um \u00e9 discutido com mais detalhes nos par\u00e1grafos a seguir.</p>"},{"location":"aae3/white_box_test/#principio-1","title":"Princ\u00edpio 1","text":"<p>Uma parte necess\u00e1ria de um caso de teste \u00e9 uma defini\u00e7\u00e3o da sa\u00edda ou resultado esperado. Este princ\u00edpio, embora \u00f3bvio, quando negligenciado, \u00e9 a causa de um dos erros mais frequentes no teste de programas. Novamente, \u00e9 algo baseado na psicologia humana. Se o resultado esperado de um caso de teste n\u00e3o foi predefinido, \u00e9 prov\u00e1vel que um resultado plaus\u00edvel, mas err\u00f4neo, seja interpretado como um resultado correto por causa do fen\u00f4meno de \"o olho ver o que quer ver\". Em outras palavras, apesar da defini\u00e7\u00e3o destrutiva adequada de teste, ainda h\u00e1 um desejo subconsciente de ver o resultado correto.</p> <p>Uma maneira de lutar contra essa situa\u00e7\u00e3o consiste em incentivar uma an\u00e1lise pormenorizada de toda a produ\u00e7\u00e3o, especificando com precis\u00e3o, antecipadamente, a produ\u00e7\u00e3o esperada do programa. Portanto, um caso de teste deve consistir em dois componentes:</p> <ol> <li>Uma descri\u00e7\u00e3o dos dados de entrada para o programa.</li> <li>Uma descri\u00e7\u00e3o precisa da sa\u00edda correta do programa para esse conjunto de dados de entrada.</li> </ol> <p>Um problema pode ser caracterizado como um fato ou grupo de fatos para os quais n\u00e3o temos uma explica\u00e7\u00e3o aceit\u00e1vel, que parecem incomuns ou que n\u00e3o se encaixam em nossas expectativas ou preconceitos. Deve ser \u00f3bvio que algumas cren\u00e7as pr\u00e9vias s\u00e3o necess\u00e1rias para que algo pare\u00e7a problem\u00e1tico. Se n\u00e3o houver expectativas, n\u00e3o pode haver surpresas.</p>"},{"location":"aae3/white_box_test/#principio-2","title":"Princ\u00edpio 2","text":"<p>Um programador deve evitar tentar testar seu pr\u00f3prio programa. Qualquer escritor sabe \u2014 ou deveria saber \u2014 que \u00e9 uma m\u00e1 ideia tentar editar ou revisar seu pr\u00f3prio trabalho. Eles sabem o que a pe\u00e7a deve dizer, portanto, podem n\u00e3o reconhecer quando diz o contr\u00e1rio. E eles realmente n\u00e3o querem encontrar erros em seu pr\u00f3prio trabalho. O mesmo se aplica aos autores de software.</p> <p>Outro problema surge com uma mudan\u00e7a de foco em um projeto de software. Depois que um programador projetou e codificou construtivamente um programa, \u00e9 extremamente dif\u00edcil mudar repentinamente a perspectiva para olhar para o programa com um olhar destrutivo.</p> <p>Como muitos propriet\u00e1rios sabem, remover o papel de parede (um processo destrutivo) n\u00e3o \u00e9 f\u00e1cil, mas \u00e9 quase insuportavelmente deprimente se foram suas m\u00e3os que penduraram o papel em primeiro lugar. Da mesma forma, a maioria dos programadores n\u00e3o pode testar efetivamente seus pr\u00f3prios programas porque n\u00e3o consegue mudar as engrenagens mentais para tentar expor erros. Al\u00e9m disso, um programador pode inconscientemente evitar encontrar erros por medo de retalia\u00e7\u00e3o de colegas, de um supervisor, de um cliente ou do propriet\u00e1rio do programa ou sistema que est\u00e1 sendo desenvolvido.</p> <p>Al\u00e9m dessas quest\u00f5es psicol\u00f3gicas, h\u00e1 um segundo problema significativo: o programa pode conter erros devido ao mal-entendido do programador sobre a declara\u00e7\u00e3o ou especifica\u00e7\u00e3o do problema. Se for esse o caso, \u00e9 prov\u00e1vel que o programador leve o mesmo mal-entendido para os testes de seu pr\u00f3prio programa.</p> <p>Isso n\u00e3o significa que seja imposs\u00edvel para um programador testar seu pr\u00f3prio programa. Em vez disso, implica que o teste \u00e9 mais eficaz e bem-sucedido se outra pessoa o fizer. No entanto, como vamos discutir em mais detalhes no Cap\u00edtulo 3, os desenvolvedores podem ser membros valiosos da equipe de teste quando a especifica\u00e7\u00e3o do programa e o pr\u00f3prio c\u00f3digo do programa est\u00e3o sendo avaliados.</p> <p>Observe que esse argumento n\u00e3o se aplica \u00e0 depura\u00e7\u00e3o (corrigir erros conhecidos); a depura\u00e7\u00e3o \u00e9 executada com mais efici\u00eancia pelo programador original.</p>"},{"location":"aae3/white_box_test/#principio-3","title":"Princ\u00edpio 3","text":"<p>Uma organiza\u00e7\u00e3o de programa\u00e7\u00e3o n\u00e3o deve testar seus pr\u00f3prios programas. O argumento aqui \u00e9 semelhante ao feito no princ\u00edpio anterior. Uma organiza\u00e7\u00e3o de projeto ou programa\u00e7\u00e3o \u00e9, em muitos sentidos, uma organiza\u00e7\u00e3o viva com problemas psicol\u00f3gicos semelhantes aos de programadores individuais. Al\u00e9m disso, na maioria dos ambientes, uma organiza\u00e7\u00e3o de programas ou um gerente de projeto \u00e9 amplamente medido pela capacidade de produzir um programa em uma determinada data e por um determinado custo.</p> <p>Uma raz\u00e3o para isso \u00e9 que \u00e9 f\u00e1cil medir os objetivos de tempo e custo, enquanto \u00e9 extremamente dif\u00edcil quantificar a confiabilidade de um programa. Portanto, \u00e9 dif\u00edcil para uma organiza\u00e7\u00e3o de programa\u00e7\u00e3o ser objetiva ao testar seus pr\u00f3prios programas, porque o processo de teste, se abordado com a defini\u00e7\u00e3o adequada, pode ser visto como diminuindo a probabilidade de atingir o cronograma e os objetivos de custo.</p> <p>Novamente, isso n\u00e3o significa que seja imposs\u00edvel para uma organiza\u00e7\u00e3o de programa\u00e7\u00e3o encontrar alguns de seus erros, porque as organiza\u00e7\u00f5es realizam isso com algum grau de sucesso. Em vez disso, implica que \u00e9 mais econ\u00f4mico que os testes sejam realizados por uma parte objetiva e independente.</p>"},{"location":"aae3/white_box_test/#principio-4","title":"Princ\u00edpio 4","text":"<p>Qualquer processo de teste deve incluir uma inspe\u00e7\u00e3o completa dos resultados de cada teste. Este \u00e9 provavelmente o princ\u00edpio mais \u00f3bvio, mas, novamente, \u00e9 algo que muitas vezes \u00e9 esquecido. Vimos v\u00e1rios experimentos que mostram que muitos sujeitos falharam em detectar certos erros, mesmo quando os sintomas desses erros eram claramente observ\u00e1veis nas listas de sa\u00edda. Dito de outra forma, os erros encontrados em testes posteriores foram frequentemente perdidos nos resultados de testes anteriores.</p>"},{"location":"aae3/white_box_test/#principio-5","title":"Princ\u00edpio 5","text":"<p>Os casos de teste devem ser escritos para condi\u00e7\u00f5es de entrada inv\u00e1lidas e inesperadas, bem como para aquelas que s\u00e3o v\u00e1lidas e esperadas. H\u00e1 uma tend\u00eancia natural, ao testar um programa, de se concentrar nas condi\u00e7\u00f5es de entrada v\u00e1lidas e esperadas, negligenciando as condi\u00e7\u00f5es inv\u00e1lidas e inesperadas.</p> <p>Por exemplo, essa tend\u00eancia aparece frequentemente no teste do programa do tri\u00e2ngulo no Cap\u00edtulo 1. Poucas pessoas, por exemplo, alimentam o programa com os n\u00fameros 1, 2, 5 para garantir que o programa n\u00e3o interprete erroneamente isso como um tri\u00e2ngulo equil\u00e1tero em vez de um tri\u00e2ngulo escaleno.</p> <p>Al\u00e9m disso, muitos erros que s\u00e3o descobertos repentinamente no software de produ\u00e7\u00e3o aparecem quando ele \u00e9 usado de alguma maneira nova ou inesperada. \u00c9 dif\u00edcil, se n\u00e3o imposs\u00edvel, definir todos os casos de uso para teste de software. Portanto, os casos de teste que representam condi\u00e7\u00f5es de entrada inesperadas e inv\u00e1lidas parecem ter um rendimento de detec\u00e7\u00e3o de erro maior do que os casos de teste para condi\u00e7\u00f5es de entrada v\u00e1lidas.</p>"},{"location":"aae3/white_box_test/#principio-6","title":"Princ\u00edpio 6","text":"<p>Examinar um programa para ver se ele n\u00e3o faz o que deveria fazer \u00e9 apenas metade da batalha; a outra metade \u00e9 ver se o programa faz o que n\u00e3o deveria fazer. Este \u00e9 um corol\u00e1rio do princ\u00edpio anterior. Os programas devem ser examinados quanto a efeitos colaterais indesejados.</p> <p>Por exemplo, um programa de c\u00e1lculo das folhas de pagamento que produz os contracheques corretos ainda \u00e9 um programa err\u00f4neo se tamb\u00e9m produzir cheques extras para empregados inexistentes ou se sobregravar o primeiro registro do arquivo pessoal.</p>"},{"location":"aae3/white_box_test/#principio-7","title":"Princ\u00edpio 7","text":"<p>Evite casos de teste descart\u00e1veis, a menos que o programa seja realmente um programa descart\u00e1vel. Este problema \u00e9 visto com mais frequ\u00eancia com sistemas interativos para testar programas. Uma pr\u00e1tica comum \u00e9 sentar-se em um terminal e inventar casos de teste em tempo real e, em seguida, enviar esses casos de teste pelo programa.</p> <p>A principal quest\u00e3o \u00e9 que os casos de teste representam um investimento valioso que, neste ambiente, desaparece ap\u00f3s a conclus\u00e3o do teste. Sempre que o programa tiver que ser testado novamente (por exemplo, ap\u00f3s corrigir um erro ou fazer uma melhoria), os casos de teste devem ser reinventados.</p> <p>Na maioria das vezes, uma vez que essa reinven\u00e7\u00e3o requer uma quantidade consider\u00e1vel de trabalho, as pessoas tendem a evit\u00e1-la. Portanto, o teste do programa raramente \u00e9 t\u00e3o rigoroso quanto o teste original, o que significa que, se a modifica\u00e7\u00e3o fizer com que uma parte anteriormente funcional do programa falhe, esse erro geralmente n\u00e3o \u00e9 detectado.</p> <p>Salvar casos de teste e execut\u00e1-los novamente ap\u00f3s altera\u00e7\u00f5es em outros componentes do programa \u00e9 conhecido como teste de regress\u00e3o.</p>"},{"location":"aae3/white_box_test/#principio-8","title":"Princ\u00edpio 8","text":"<p>N\u00e3o planeje um esfor\u00e7o de teste sob a suposi\u00e7\u00e3o t\u00e1cita de que nenhum erro ser\u00e1 encontrado. Este \u00e9 um erro que os gerentes de projeto costumam cometer e \u00e9 um sinal do uso da defini\u00e7\u00e3o incorreta de teste \u2014 ou seja, a suposi\u00e7\u00e3o de que o teste \u00e9 o processo de mostrar que o programa funciona corretamente.</p> <p>Mais uma vez, a defini\u00e7\u00e3o de teste \u00e9 o processo de execu\u00e7\u00e3o de um programa com a inten\u00e7\u00e3o de encontrar erros. E deve ser \u00f3bvio a partir de nossas discuss\u00f5es anteriores que \u00e9 imposs\u00edvel desenvolver um programa que seja completamente livre de erros.</p> <p>Mesmo ap\u00f3s extensos testes e corre\u00e7\u00e3o de erros, \u00e9 seguro assumir que os erros ainda existem; eles simplesmente ainda n\u00e3o foram encontrados.</p>"},{"location":"aae3/white_box_test/#principio-9","title":"Princ\u00edpio 9","text":"<p>A probabilidade da exist\u00eancia de mais erros em uma se\u00e7\u00e3o de um programa \u00e9 proporcional ao n\u00famero de erros j\u00e1 encontrados nessa se\u00e7\u00e3o. Este fen\u00f4meno \u00e9 ilustrado na Figura 2.2. \u00c0 primeira vista, esse conceito pode parecer sem sentido, mas \u00e9 um fen\u00f4meno presente em muitos programas.</p> <p>Por exemplo, se um programa consiste em dois m\u00f3dulos, classes ou sub-rotinas, A e B, e cinco erros foram encontrados no m\u00f3dulo A, e apenas um erro foi encontrado no m\u00f3dulo B, e se o m\u00f3dulo A n\u00e3o foi propositalmente submetido a um teste mais rigoroso, ent\u00e3o este princ\u00edpio nos diz que a probabilidade de mais erros no m\u00f3dulo A \u00e9 maior do que a probabilidade de mais erros no m\u00f3dulo B.</p> <p>Outra maneira de afirmar esse princ\u00edpio \u00e9 dizer que os erros tendem a ocorrer em grupos e que, no programa t\u00edpico, algumas se\u00e7\u00f5es parecem ser muito mais propensas a erros do que outras se\u00e7\u00f5es, embora ningu\u00e9m tenha fornecido uma boa explica\u00e7\u00e3o de por que isso ocorre.</p> <p>FIGURA 2.2: A surpreendente rela\u00e7\u00e3o entre erros remanescentes e erros encontrados.</p> <p>O fen\u00f4meno \u00e9 \u00fatil porque nos d\u00e1 uma vis\u00e3o ou feedback no processo de teste. Se uma se\u00e7\u00e3o espec\u00edfica de um programa parece ser muito mais propensa a erros do que outras se\u00e7\u00f5es, esse fen\u00f4meno nos diz que, em termos de rendimento em nosso investimento em testes, os esfor\u00e7os adicionais de teste s\u00e3o mais bem focados nesta se\u00e7\u00e3o propensa a erros.</p>"},{"location":"aae3/white_box_test/#principio-10","title":"Princ\u00edpio 10","text":"<p>O teste \u00e9 uma tarefa extremamente criativa e intelectualmente desafiadora. Provavelmente \u00e9 verdade que a criatividade necess\u00e1ria para testar um programa grande excede a criatividade necess\u00e1ria para projetar esse programa.</p> <p>J\u00e1 vimos que \u00e9 imposs\u00edvel testar um programa o suficiente para garantir a aus\u00eancia de todos os erros. As metodologias discutidas posteriormente neste livro ajudam voc\u00ea a desenvolver um conjunto razo\u00e1vel de casos de teste para um programa, mas essas metodologias ainda exigem uma quantidade significativa de criatividade.</p>"},{"location":"aae3/white_box_test/#resumo","title":"Resumo","text":"<p>\u00c0 medida que voc\u00ea avan\u00e7a neste livro, tenha em mente estes importantes princ\u00edpios de teste:</p> <ul> <li>Teste \u00e9 o processo de execu\u00e7\u00e3o de um programa com a inten\u00e7\u00e3o de encontrar erros.</li> <li>O teste \u00e9 mais bem-sucedido quando n\u00e3o \u00e9 realizado pelo(s) desenvolvedor(es).</li> <li>Um bom caso de teste \u00e9 aquele que tem uma alta probabilidade de detectar um erro n\u00e3o descoberto.</li> <li>Um caso de teste bem-sucedido \u00e9 aquele que detecta um erro n\u00e3o descoberto.</li> <li>O teste bem-sucedido inclui tamb\u00e9m a defini\u00e7\u00e3o cuidadosa da sa\u00edda esperada como entrada.</li> <li>O teste bem-sucedido inclui o estudo cuidadoso dos resultados do teste.</li> </ul>"},{"location":"aae3/white_box_test/#bibliografia","title":"Bibliografia","text":"<p>MYERS, G. J.; SANDLER, C.; BADGETT, T. The Art of Software Testing. 3rd ed. Cap\u00edtulo 4, Se\u00e7\u00e3o White-Box Testing.</p>"},{"location":"tpi_tpe/tpi1_tpe1/","title":"Question\u00e1rio - TPI/TPE-1","text":""},{"location":"tpi_tpe/tpi1_tpe1/#questao-1","title":"Quest\u00e3o 1","text":"<p>Enunciado: O que acontece com equipes que n\u00e3o adotam uma pr\u00e1tica rigorosa de testes?</p> <p>Alternativas: a) Elas entram em um ciclo repetitivo de cria\u00e7\u00e3o e corre\u00e7\u00e3o de bugs. b) Elas conseguem lan\u00e7ar software mais rapidamente, com menor esfor\u00e7o. c) Elas precisam de mais ferramentas automatizadas para compensar a aus\u00eancia de testes. d) Elas produzem software menos complexo, o que facilita a manuten\u00e7\u00e3o.</p> <p>Resposta correta: a</p> <p>Equipes que produzem muitos bugs tendem a desperdi\u00e7ar tempo em um ciclo eterno no qual desenvolvedores criam bugs, clientes (ou QAs dedicados) encontram os bugs, desenvolvedores corrigem os bugs, clientes encontram um novo conjunto de bugs, e assim por diante.</p> <p>\u201cTeams that produce many bugs tend to waste time in an eternal loop where developers write bugs, customers (or dedicated QAs) find the bugs, developers fix the bugs, customers find a different set of bugs, and so on.\u201d</p> <p>\u2014 Aniche, Effective Software Testing, Cap\u00edtulo 1, p\u00e1gina 15 do PDF</p>"},{"location":"tpi_tpe/tpi1_tpe1/#questao-2","title":"Quest\u00e3o 2","text":"<p>Enunciado: O que significa testar de forma eficaz, segundo o texto?</p> <p>Alternativas: a) Criar o maior n\u00famero poss\u00edvel de testes, de forma a cobrir o c\u00f3digo de forma abrangente e redundante. b) Escrever os testes certos, focando em encontrar mais bugs com o menor esfor\u00e7o poss\u00edvel. c) Combinar testes manuais com testes automatizados para ganhar efici\u00eancia. d) Focar no uso de ferramentas automatizadas para acelerar o processo de testes.</p> <p>Resposta correta: b</p> <p>Ser eficaz significa focar em escrever os testes certos. Testar software \u00e9 sempre uma quest\u00e3o de compensa\u00e7\u00f5es. Os testadores querem maximizar o n\u00famero de bugs encontrados minimizando o esfor\u00e7o necess\u00e1rio para encontr\u00e1-los.</p> <p>\u201cBeing effective means we focus on writing the right tests. Software testing is all about trade-offs. Testers want to maximize the number of bugs they find while minimizing the effort required to find the bugs.\u201d</p> <p>\u2014 Aniche, Effective Software Testing, Cap\u00edtulo 1, p\u00e1gina 16 do PDF</p>"},{"location":"tpi_tpe/tpi1_tpe1/#questao-3","title":"Quest\u00e3o 3","text":"<p>Enunciado: O que \u00e9 necess\u00e1rio para que diferentes desenvolvedores cheguem \u00e0 mesma su\u00edte de testes para um c\u00f3digo?</p> <p>Alternativas: a) Que todos usem a mesma linguagem de programa\u00e7\u00e3o. b) Que o processo de teste seja sistem\u00e1tico e padronizado. c) Que compartilhem a mesma ferramenta de automa\u00e7\u00e3o. d) Que tenham o mesmo n\u00edvel de experi\u00eancia profissional.</p> <p>Resposta correta: b</p> <p>Ser sistem\u00e1tico significa que, para um determinado trecho de c\u00f3digo, qualquer desenvolvedor deveria chegar \u00e0 mesma su\u00edte de testes. Os testes muitas vezes acontecem de forma ad hoc. Devemos ser capazes de sistematizar nossos processos para reduzir a depend\u00eancia do desenvolvedor que est\u00e1 realizando o trabalho.</p> <p>\u201cBeing systematic means that for a given piece of code, any developer should come up with the same test suite. Testing often happens in an ad hoc manner. [...] We should be able to systematize our processes to reduce the dependency on the developer who is doing the job.\u201d</p> <p>\u2014 Aniche, Effective Software Testing, Cap\u00edtulo 1, p\u00e1gina 16 do PDF</p>"},{"location":"tpi_tpe/tpi1_tpe1/#questao-4","title":"Quest\u00e3o 4","text":"<p>Enunciado: Qual \u00e9 um dos principais argumentos a favor do investimento em testes rigorosos?</p> <p>Alternativas: a) Reduzir o tempo de desenvolvimento inicial. b) Garantir que o sistema ser\u00e1 100% livre de erros. c) Evitar a necessidade de QA. d) O custo de bugs em produ\u00e7\u00e3o pode ser maior que o custo de preven\u00e7\u00e3o.</p> <p>Resposta correta: d</p> <p>O custo dos bugs que acontecem em produ\u00e7\u00e3o muitas vezes supera o custo de preveni-los (como mostrado por Boehm e Papaccio, 1988).</p> <p>\u201cThe cost of bugs that happen in production often outweighs the cost of prevention (as shown by Boehm and Papaccio, 1988).\u201d</p> <p>\u2014 Aniche, Effective Software Testing, Cap\u00edtulo 1, p\u00e1gina 15 do PDF</p>"},{"location":"tpi_tpe/tpi1_tpe1/#questao-5","title":"Quest\u00e3o 5","text":"<p>Enunciado: Qual \u00e9 a principal recomenda\u00e7\u00e3o ao considerar o paradoxo do pesticida?</p> <p>Alternativas: a) Priorizar testes automatizados para validar todas as entradas. b) Focar apenas em testes de integra\u00e7\u00e3o, ap\u00f3s obter cobertura completa de testes unit\u00e1rios. c) Combinar diferentes estrat\u00e9gias de teste para encontrar uma gama mais ampla de bugs. d) Evitar mudan\u00e7as frequentes nas t\u00e9cnicas de teste.</p> <p>Resposta correta: c</p> <p>Testadores devem usar diferentes estrat\u00e9gias de teste para minimizar o n\u00famero de bugs deixados no software.</p> <p>\u201cTesters must use different testing strategies to minimize the number of bugs left in the software.\u201d</p> <p>\u2014 Aniche, Effective Software Testing, Cap\u00edtulo 1, p\u00e1gina 17 do PDF</p>"},{"location":"tpi_tpe/tpi1_tpe1/#questao-6","title":"Quest\u00e3o 6","text":"<p>Enunciado: O que a observa\u00e7\u00e3o emp\u00edrica da comunidade de testes de software mostra sobre a distribui\u00e7\u00e3o de bugs?</p> <p>Alternativas: a) Os bugs ocorrem de forma homog\u00eanea em todos os componentes do sistema. b) Os bugs ocorrem com maior frequ\u00eancia em interfaces gr\u00e1ficas. c) A distribui\u00e7\u00e3o de bugs depende apenas da linguagem de programa\u00e7\u00e3o utilizada. d) Alguns componentes s\u00e3o mais propensos a conter bugs do que outros.</p> <p>Resposta correta: d</p> <p>Empiricamente, nossa comunidade observou que alguns componentes apresentam mais bugs do que outros.</p> <p>\u201cEmpirically, our community has observed that some components present more bugs than others.\u201d</p> <p>\u2014 Aniche, Effective Software Testing, Cap\u00edtulo 1, p\u00e1gina 17 do PDF</p>"},{"location":"tpi_tpe/tpi1_tpe1/#questao-7","title":"Quest\u00e3o 7","text":"<p>Enunciado: Por que os testes unit\u00e1rios s\u00e3o considerados f\u00e1ceis de controlar?</p> <p>Alternativas: a) Porque os valores de entrada e sa\u00edda s\u00e3o f\u00e1ceis de adaptar e modificar. b) Porque exigem muitas ferramentas externas para executar. c) Porque precisam ser reescritos a cada altera\u00e7\u00e3o de c\u00f3digo. d) Porque cobrem apenas requisitos de neg\u00f3cio complexos.</p> <p>Resposta correta: a</p> <p>Testes unit\u00e1rios s\u00e3o f\u00e1ceis de controlar. Um teste unit\u00e1rio testa o software fornecendo determinados par\u00e2metros para um m\u00e9todo e depois comparando o valor de retorno com o resultado esperado. Esses valores de entrada e o resultado esperado s\u00e3o f\u00e1ceis de adaptar ou modificar no teste.</p> <p>\u201cUnit tests are easy to control. A unit test tests the software by giving certain parameters to a method and then comparing the return value of this method to the expected result. These input values and the expected result value are easy to adapt or modify in the test.\u201d</p> <p>\u2014 Aniche, Effective Software Testing, Cap\u00edtulo 1, p\u00e1gina 20 do PDF</p>"},{"location":"tpi_tpe/tpi1_tpe1/#questao-8","title":"Quest\u00e3o 8","text":"<p>Enunciado: Qual \u00e9 uma das limita\u00e7\u00f5es dos testes unit\u00e1rios?</p> <p>Alternativas: a) Permitem identificar todos os defeitos presentes em sistemas multithread. b) Exigem a execu\u00e7\u00e3o completa da aplica\u00e7\u00e3o. c) N\u00e3o representam fielmente a execu\u00e7\u00e3o real do sistema, pois testam unidades isoladas. d) Dependem fortemente da intera\u00e7\u00e3o com bancos de dados reais.</p> <p>Resposta correta: c</p> <p>Testes unit\u00e1rios n\u00e3o representam a realidade. Um sistema de software raramente \u00e9 composto por uma \u00fanica classe. O grande n\u00famero de classes e a intera\u00e7\u00e3o entre elas podem fazer o sistema se comportar de forma diferente na aplica\u00e7\u00e3o real do que nos testes unit\u00e1rios.</p> <p>\u201cUnit tests lack reality. A software system is rarely composed of a single class. The large number of classes in a system and their interaction can cause the system to behave differently in its real application than in the unit tests.\u201d</p> <p>\u2014 Aniche, Effective Software Testing, Cap\u00edtulo 1, p\u00e1gina 20 do PDF</p>"},{"location":"tpi_tpe/tpi1_tpe1/#questao-9","title":"Quest\u00e3o 9","text":"<p>Enunciado: Qual \u00e9 o foco principal dos testes de integra\u00e7\u00e3o?</p> <p>Alternativas: a) Integrar testes de unidade com testes de sistema. b) Verificar a comunica\u00e7\u00e3o correta entre componentes do sistema e componentes externos. c) Garantir que todos os requisitos do cliente foram implementados. d) Verificar se todos os componentes funcionam corretamente.</p> <p>Resposta correta: b</p> <p>O teste de integra\u00e7\u00e3o tem como objetivo testar m\u00faltiplos componentes de um sistema juntos, focando nas intera\u00e7\u00f5es entre eles em vez de testar o sistema como um todo.</p> <p>\u201cIntegration testing aims to test multiple components of a system together, focusing on the interactions between them instead of testing the system as a whole.\u201d</p> <p>\u2014 Aniche, Effective Software Testing, Cap\u00edtulo 1, p\u00e1gina 21 do PDF</p>"},{"location":"tpi_tpe/tpi1_tpe1/#questao-10","title":"Quest\u00e3o 10","text":"<p>Enunciado: Qual dos itens abaixo \u00e9 uma desvantagem t\u00edpica dos testes de sistema?</p> <p>Alternativas: a) Maior tempo de execu\u00e7\u00e3o e maior complexidade na configura\u00e7\u00e3o dos ambientes de teste. b) Baixa chance de detectar falhas reais de produ\u00e7\u00e3o. c) Dificuldade de automa\u00e7\u00e3o devido \u00e0 falta de ferramentas. d) Inabilidade de simular cen\u00e1rios reais de usu\u00e1rio.</p> <p>Resposta correta: a</p> <p>Testes de sistema costumam ser lentos em compara\u00e7\u00e3o com testes unit\u00e1rios. Alguns componentes (como bancos de dados) podem exigir uma configura\u00e7\u00e3o complexa antes de serem usados em um cen\u00e1rio de teste.</p> <p>\u201cSystem tests are often slow compared to unit tests. [...] Some of the components (such as databases) may require a complex setup before they can be used in a testing scenario.\u201d</p> <p>\u2014 Aniche, Effective Software Testing, Cap\u00edtulo 1, p\u00e1gina 22 do PDF</p>"},{"location":"tpi_tpe/tpi1_tpe1/#questao-11","title":"Quest\u00e3o 11","text":"<p>Enunciado: Por que alguns desenvolvedores preferem testes unit\u00e1rios em compara\u00e7\u00e3o a outros n\u00edveis de teste?</p> <p>Alternativas: a) Porque s\u00e3o mais f\u00e1ceis de escrever, mais r\u00e1pidos e podem ser escritos junto com o c\u00f3digo de produ\u00e7\u00e3o. b) Porque testes unit\u00e1rios dispensam manuten\u00e7\u00e3o e s\u00e3o 100% confi\u00e1veis. c) Porque testes unit\u00e1rios substituem a necessidade de testes de integra\u00e7\u00e3o e sistema. d) Porque s\u00e3o mais realistas que os outros n\u00edveis de testes.</p> <p>Resposta correta: a</p> <p>Eu costumo preferir testes unit\u00e1rios. Eu valorizo as vantagens que os testes unit\u00e1rios me oferecem. Eles s\u00e3o f\u00e1ceis de escrever, s\u00e3o r\u00e1pidos, posso escrev\u00ea-los junto com o c\u00f3digo de produ\u00e7\u00e3o, e assim por diante.</p> <p>\u201cI tend to favor unit testing. I appreciate the advantages that unit tests give me. They are easy to write, they are fast, I can write them intertwined with production code, and so on.\u201d</p> <p>\u2014 Aniche, Effective Software Testing, Cap\u00edtulo 1, p\u00e1gina 24 do PDF</p>"},{"location":"tpi_tpe/tpi1_tpe1/#questao-12","title":"Quest\u00e3o 12","text":"<p>Enunciado: Em qual situa\u00e7\u00e3o \u00e9 mais adequado utilizar testes de integra\u00e7\u00e3o, segundo Aniche?</p> <p>Alternativas: a) Quando h\u00e1 l\u00f3gica de neg\u00f3cio complexa desacoplada de outros componentes. b) Quando o c\u00f3digo est\u00e1 relacionado \u00e0 interface com o usu\u00e1rio. c) Quando o componente interage com servi\u00e7os externos, como bancos de dados ou APIs. d) Quando o tempo de execu\u00e7\u00e3o do teste precisa ser o mais curto poss\u00edvel.</p> <p>Resposta correta: c</p> <p>Eu uso testes de integra\u00e7\u00e3o sempre que o componente testado interage com um componente externo (como um banco de dados ou servi\u00e7o web).</p> <p>\u201cI use integration tests whenever the component under test interacts with an external component (such as a database or web service).\u201d</p> <p>\u2014 Aniche, Effective Software Testing, Cap\u00edtulo 1, p\u00e1gina 25 do PDF</p>"},{"location":"tpi_tpe/tpi1_tpe1/#questao-13","title":"Quest\u00e3o 13","text":"<p>Enunciado: O que representa a diferen\u00e7a entre a pir\u00e2mide de testes e o trof\u00e9u de testes?</p> <p>Alternativas: a) O trof\u00e9u de testes representa um maior uso de testes manuais. b) A pir\u00e2mide favorece mais testes unit\u00e1rios, enquanto o trof\u00e9u favorece mais testes de integra\u00e7\u00e3o. c) O trof\u00e9u exclui os testes de sistema. d) A pir\u00e2mide inclui testes de desempenho, enquanto o trof\u00e9u n\u00e3o.</p> <p>Resposta correta: b</p> <p>Muitas pessoas discordam da ideia da pir\u00e2mide de testes e de favorecer testes unit\u00e1rios. Esses desenvolvedores argumentam a favor do trof\u00e9u de testes: uma base mais fina com testes unit\u00e1rios, uma camada do meio maior com testes de integra\u00e7\u00e3o, e uma camada superior mais fina com testes de sistema.</p> <p>\u201cMany people disagree about the idea of a testing pyramid and whether we should favor unit testing. These developers argue for the testing trophy: a thinner bottom level with unit tests, a bigger middle slice with integration tests, and a thinner top with system tests.\u201d</p> <p>\u2014 Aniche, Effective Software Testing, Cap\u00edtulo 1, p\u00e1gina 26 do PDF</p>"},{"location":"tpi_tpe/tpi1_tpe1/#questao-14","title":"Quest\u00e3o 14","text":"<p>Enunciado: De acordo com o Myers, qual \u00e9 a atitude ideal de um testador de software?</p> <p>Alternativas: a) Desconfiar da capacidade da equipe em realizar testes sistematizados. b) Come\u00e7ar assumindo que o programa cont\u00e9m erros. c) Desenvolver novas funcionalidades para melhorar o sistema. d) Automatizar todos os testes antes de execut\u00e1-los.</p> <p>Resposta correta: b</p> <p>N\u00e3o teste um programa para mostrar que ele funciona; ao contr\u00e1rio, comece assumindo que o programa cont\u00e9m erros (uma suposi\u00e7\u00e3o v\u00e1lida para quase qualquer programa) e depois teste o programa para encontrar o m\u00e1ximo poss\u00edvel de erros.</p> <p>\u201cdon\u2019t test a program to show that it works; rather, start with the assumption that the program contains errors (a valid assumption for almost any program) and then test the program to find as many of the errors as possible.\u201d</p> <p>\u2014 Myers, The Art of Software Testing, 3\u00aa edi\u00e7\u00e3o, Cap\u00edtulo 2, p\u00e1gina 6 do PDF</p>"},{"location":"tpi_tpe/tpi1_tpe1/#questao-15","title":"Quest\u00e3o 15","text":"<p>Enunciado: Por que Myers compara o teste de software com exames m\u00e9dicos?</p> <p>Alternativas: a) Para destacar que ambos tiram o sangue das pessoas. b) Porque ambos evitam que o paciente/software piore com o tempo. c) Porque m\u00e9dicos tamb\u00e9m usam softwares para seus diagn\u00f3sticos. d) Porque um teste s\u00f3 \u00e9 bem-sucedido se encontrar o problema.</p> <p>Resposta correta: d</p> <p>Considere a analogia de uma pessoa visitando um m\u00e9dico por causa de uma sensa\u00e7\u00e3o geral de mal-estar. Se o m\u00e9dico faz alguns exames laboratoriais que n\u00e3o localizam o problema, n\u00e3o chamamos esses exames de \u201cbem-sucedidos\u201d; eles foram exames malsucedidos [...] Por\u00e9m, se um exame determina que o paciente tem uma \u00falcera, ele \u00e9 bem-sucedido pois orienta o tratamento adequado.</p> <p>\u201cConsider the analogy of a person visiting a doctor because of an overall feeling of malaise. If the doctor runs some laboratory tests that do not locate the problem, we do not call the laboratory tests \u2018successful\u2019; they were unsuccessful tests [...] However, if a laboratory test determines that the patient has a peptic ulcer, the test is successful because the doctor can now begin the appropriate treatment.\u201d</p> <p>\u2014 Myers, The Art of Software Testing, 3\u00aa edi\u00e7\u00e3o, Cap\u00edtulo 2, p\u00e1gina 7 do PDF</p>"},{"location":"tpi_tpe/tpi1_tpe1/#questao-16","title":"Quest\u00e3o 16","text":"<p>Enunciado: O que Myers sugere como solu\u00e7\u00e3o para as limita\u00e7\u00f5es dos testes caixa-preta exaustivos?</p> <p>Alternativas: a) Executar apenas os testes definidos pelo cliente. b) Automatizar todos os testes para garantir cobertura total. c) Criar uma ferramenta que gere todos os casos automaticamente. d) Maximizar o n\u00famero de erros encontrados com um n\u00famero finito de casos de teste.</p> <p>Resposta correta: d</p> <p>Assim, como o teste exaustivo est\u00e1 fora de quest\u00e3o, o objetivo deve ser maximizar o retorno do investimento em testes, maximizando o n\u00famero de erros encontrados por um n\u00famero finito de casos de teste.</p> <p>\u201cThus, since exhaustive testing is out of the question, the objective should be to maximize the yield on the testing investment by maximizing the number of errors found by a finite number of test cases.\u201d</p> <p>\u2014 Myers, The Art of Software Testing, 3\u00aa edi\u00e7\u00e3o, Cap\u00edtulo 2, p\u00e1gina 10 do PDF</p>"},{"location":"tpi_tpe/tpi1_tpe1/#questao-17","title":"Quest\u00e3o 17","text":"<p>Enunciado: Qual \u00e9 o principal objetivo do teste de caixa-branca (white-box testing)?</p> <p>Alternativas: a) Verificar se o programa atende aos requisitos funcionais descritos na especifica\u00e7\u00e3o. b) Avaliar o desempenho do sistema em diferentes plataformas. c) Examinar a estrutura l\u00f3gica interna do programa para definir dados de teste. d) Executar testes baseados exclusivamente na interface do usu\u00e1rio.</p> <p>Resposta correta: c</p> <p>Outra estrat\u00e9gia de teste, o teste de caixa-branca (ou orientado pela l\u00f3gica), permite que voc\u00ea examine a estrutura interna do programa. Essa estrat\u00e9gia deriva dados de teste a partir da an\u00e1lise da l\u00f3gica do programa.</p> <p>\u201cAnother testing strategy, white-box (or logic-driven) testing, permits you to examine the internal structure of the program. This strategy derives test data from an examination of the program\u2019s logic.\u201d</p> <p>\u2014 Myers, The Art of Software Testing, 3\u00aa edi\u00e7\u00e3o, Cap\u00edtulo 2, p\u00e1gina 10 do PDF</p>"},{"location":"tpi_tpe/tpi1_tpe1/#questao-18","title":"Quest\u00e3o 18","text":"<p>Enunciado: Qual \u00e9 um elemento essencial de um caso de teste, segundo Myers?</p> <p>Alternativas: a) A defini\u00e7\u00e3o precisa da sa\u00edda esperada. b) A descri\u00e7\u00e3o do c\u00f3digo-fonte analisado. c) O nome do programador respons\u00e1vel. d) A linguagem de programa\u00e7\u00e3o utilizada.</p> <p>Resposta correta: a</p> <p>Uma parte essencial de um caso de teste \u00e9 a defini\u00e7\u00e3o da sa\u00edda ou resultado esperado.</p> <p>\u201cA necessary part of a test case is a definition of the expected output or result.\u201d</p> <p>\u2014 Myers, The Art of Software Testing, 3\u00aa edi\u00e7\u00e3o, Cap\u00edtulo 2, p\u00e1gina 13 do PDF</p> <p>Refer\u00eancias:</p> <ul> <li> <p>Myers, Glenford J.; Sandler, Corey; Badgett, Tom. The Art of Software Testing. 3\u00aa edi\u00e7\u00e3o, Cap\u00edtulo 2 \u2014 The Psychology and Economics of Software Testing. John Wiley &amp; Sons, 2011.</p> </li> <li> <p>Aniche, Maur\u00edcio. Effective Software Testing: A Developer\u2019s Guide. Cap\u00edtulo 1 \u2014 Why Should I Test Software? Manning Publications, 2022.</p> </li> </ul>"},{"location":"tpi_tpe/tpi2_tpe2/","title":"Question\u00e1rio - TPI/TPE-2","text":""},{"location":"tpi_tpe/tpi2_tpe2/#questao-1","title":"Quest\u00e3o 1","text":"<p>Enunciado: O teste de caixa preta \u00e9 caracterizado por:</p> <p>Alternativas: a) Utilizar as especifica\u00e7\u00f5es dos requisitos como base para cria\u00e7\u00e3o dos testes. b) Focar na estrutura interna do c\u00f3digo para definir os testes. c) Analisar o fluxo de controle do programa como crit\u00e9rio para os casos de teste. d) Utilizar t\u00e9cnicas heur\u00edsticas para derivar casos de teste.</p> <p>Resposta correta: a</p> <p>O teste de caixa-preta \u00e9 baseado nas especifica\u00e7\u00f5es do programa. O objetivo \u00e9 encontrar situa\u00e7\u00f5es nas quais o programa n\u00e3o se comporta de acordo com suas especifica\u00e7\u00f5es. Neste m\u00e9todo, os dados de teste s\u00e3o derivados exclusivamente das especifica\u00e7\u00f5es (ou seja, sem utilizar qualquer conhecimento da estrutura interna do programa).</p> <p>\u201cOne important testing strategy is black-box testing (also known as data-driven or input/output-driven testing). To use this method, view the program as a black box. Your goal is to be completely unconcerned about the internal behavior and structure of the program. Instead, concentrate on finding circumstances in which the program does not behave according to its specifications. In this approach, test data are derived solely from the specifications (i.e., without taking advantage of knowledge of the internal structure of the program).\u201d</p> <p>(The Art of Software Testing, 3rd Edition, p. 9)</p>"},{"location":"tpi_tpe/tpi2_tpe2/#questao-2","title":"Quest\u00e3o 2","text":"<p>Enunciado: Qual pr\u00e1tica \u00e9 utilizada para identificar as condi\u00e7\u00f5es de entrada no particionamento de equival\u00eancia?</p> <p>Alternativas: a) Definir entradas com base na cobertura de c\u00f3digo. b) Escolher dados aleat\u00f3rios para maximizar o n\u00famero de testes. c) Analisar cada senten\u00e7a da especifica\u00e7\u00e3o de requisitos. d) Reutilizar dados de testes de unidade.</p> <p>Resposta correta: c</p> <p>As classes de equival\u00eancia s\u00e3o identificadas a partir de cada condi\u00e7\u00e3o de entrada (normalmente uma senten\u00e7a ou frase na especifica\u00e7\u00e3o) e particionadas em dois ou mais grupos.</p> <p>\"Identifying the Equivalence Classes The equivalence classes are identified by taking each input condition (usually a sentence or phrase in the specification) and partitioning it into two or more groups.\"</p> <p>(The Art of Software Testing, 3rd Edition, p. 51)</p>"},{"location":"tpi_tpe/tpi2_tpe2/#questao-3","title":"Quest\u00e3o 3","text":"<p>Enunciado: O que define uma classe de equival\u00eancia?</p> <p>Alternativas: a) Um conjunto de entradas que o sistema trata de forma similar. b) Um grupo de testes que cobrem todos os caminhos do programa. c) Um subconjunto de entradas com maior chance de gerar falhas. d) Um grupo de sa\u00eddas esperadas com o mesmo valor.</p> <p>Resposta correta: a</p> <p>O dom\u00ednio de entrada de um programa deve ser particionado em um n\u00famero finito de classes de equival\u00eancia, de forma que se possa assumir razoavelmente que testar um valor representativo de cada classe \u00e9 equivalente a testar qualquer outro valor desta classe. Ou seja, se um caso de teste dentro de uma classe detecta um erro, espera-se que todos os outros casos daquela classe tamb\u00e9m detectem o mesmo erro.</p> <p>\"you should try to partition the input domain of a program into a finite number of equivalence classes such that you can reasonably assume (but, of course, not be absolutely sure) that a test of a representative value of each class is equivalent to a test of any other value. That is, if one test case in an equivalence class detects an error, all other test cases in the equivalence class would be expected to find the same error.\"</p> <p>(The Art of Software Testing, 3rd Edition, p. 50)</p>"},{"location":"tpi_tpe/tpi2_tpe2/#questao-4","title":"Quest\u00e3o 4","text":"<p>Enunciado: Se uma entrada \u00e9 definida por um intervalo cont\u00ednuo, como se deve proceder para identificar as classes de equival\u00eancia?</p> <p>Alternativas: a) Criar tr\u00eas classes divididas pelos valores do intervalo. b) Criar uma classe v\u00e1lida e uma inv\u00e1lida. c) Criar uma classe v\u00e1lida com os valores dentro do intervalo e inv\u00e1lidas com os valores fora dele. d) Criar classes delimitadas por valores equidistantes.</p> <p>Resposta correta: c</p> <p>Se uma condi\u00e7\u00e3o de entrada especifica um intervalo de valores, deve-se identificar uma classe de equival\u00eancia v\u00e1lida com os valores dentro do intervalo e duas classes de equival\u00eancia inv\u00e1lidas com valores fora do intervalo.</p> <p>\"If an input condition specifies a range of values (e.g., 'the item count can be from 1 to 999'), identify one valid equivalence class (1 &lt; item count &lt; 999) and two invalid equivalence classes (item count &lt; 1 and item count &gt; 999).\"</p> <p>(The Art of Software Testing, 3rd Edition, p. 51)</p>"},{"location":"tpi_tpe/tpi2_tpe2/#questao-5","title":"Quest\u00e3o 5","text":"<p>Enunciado: Para um campo que aceita os valores \u201c\u00d4nibus\u201d, \u201cCaminh\u00e3o\u201d e \u201cTaxi\u201d, como devem ser definidas as classes de equival\u00eancia?</p> <p>Alternativas: a) Uma \u00fanica classe v\u00e1lida com todos os valores poss\u00edveis. b) Uma classe v\u00e1lida e uma inv\u00e1lida. c) Uma classe inv\u00e1lida e duas inv\u00e1lidas. d) Uma classe v\u00e1lida para cada valor e uma classe inv\u00e1lida para qualquer outro.</p> <p>Resposta correta: d</p> <p>Se uma condi\u00e7\u00e3o de entrada especifica um conjunto de valores de entrada, e h\u00e1 motivo para acreditar que o programa trata cada valor de forma diferente, deve-se identificar uma classe de equival\u00eancia v\u00e1lida para cada valor permitido e uma classe de equival\u00eancia inv\u00e1lida para qualquer outro valor.</p> <p>\"If an input condition specifies a set of input values, and there is reason to believe that the program handles each differently (e.g., 'type of vehicle must be BUS, TRUCK, TAXICAB, PASSENGER, or MOTORCYCLE'), identify a valid equivalence class for each and one invalid equivalence class (e.g., 'TRAILER').\"</p> <p>(The Art of Software Testing, 3rd Edition, p. 52)</p>"},{"location":"tpi_tpe/tpi2_tpe2/#questao-6","title":"Quest\u00e3o 6","text":"<p>Enunciado: Em uma especifica\u00e7\u00e3o que diz \u201co primeiro caractere deve ser uma letra\u201d, quais classes de equival\u00eancia devem ser consideradas?</p> <p>Alternativas: a) Duas v\u00e1lidas (vogais e consoantes) e uma inv\u00e1lida (n\u00e3o letra). b) Apenas uma classe v\u00e1lida (letra). c) Uma classe v\u00e1lida (letra) e uma inv\u00e1lida (n\u00e3o letra). d) Uma classe inv\u00e1lida para cada caractere n\u00e3o alfab\u00e9tico.</p> <p>Resposta correta: c</p> <p>Se uma condi\u00e7\u00e3o de entrada especifica uma situa\u00e7\u00e3o de \u201cdeve ser\u201d, como \u201co primeiro caractere deve ser uma letra\u201d, deve-se identificar uma classe de equival\u00eancia v\u00e1lida (\u00e9 uma letra) e uma inv\u00e1lida (n\u00e3o \u00e9 uma letra).</p> <p>\"If an input condition specifies a 'must-be' situation, such as 'first character of the identifier must be a letter,' identify one valid equivalence class (it is a letter) and one invalid equivalence class (it is not a letter).\"</p> <p>(The Art of Software Testing, 3rd Edition, p. 52)</p>"},{"location":"tpi_tpe/tpi2_tpe2/#questao-7","title":"Quest\u00e3o 7","text":"<p>Enunciado: Por que se considera eficiente testar apenas um valor por classe de equival\u00eancia?</p> <p>Alternativas: a) Espera-se que todos os valores da classe produzam resultados semelhantes. b) Isso garante 100% de cobertura de c\u00f3digo. c) \u00c9 mais r\u00e1pido e evita a valida\u00e7\u00e3o dos dados de sa\u00edda. d) O sistema geralmente ignora entradas repetidas.</p> <p>Resposta correta: a</p> <p>Voc\u00ea deve particionar o dom\u00ednio de entrada do programa em um n\u00famero finito de classes de equival\u00eancia de modo que se possa assumir razoavelmente que testar um valor representativo de cada classe \u00e9 equivalente a testar qualquer outro valor dessa classe. Ou seja, se um caso de teste dentro de uma classe detecta um erro, espera-se que todos os outros casos da mesma classe tamb\u00e9m detectem o mesmo erro.</p> <p>\"you should try to partition the input domain of a program into a finite number of equivalence classes such that you can reasonably assume (but, of course, not be absolutely sure) that a test of a representative value of each class is equivalent to a test of any other value. That is, if one test case in an equivalence class detects an error, all other test cases in the equivalence class would be expected to find the same error.\"</p> <p>(The Art of Software Testing, 3rd Edition, p. 50)</p>"},{"location":"tpi_tpe/tpi2_tpe2/#questao-8","title":"Quest\u00e3o 8","text":"<p>Enunciado: Por que a an\u00e1lise de valor limite \u00e9 eficaz na detec\u00e7\u00e3o de erros?</p> <p>Alternativas: a) Ela garante 100% de cobertura de c\u00f3digo. b) Os limites representam a m\u00e9dia estat\u00edstica dos dados de entrada. c) Muitos erros ocorrem nas extremidades de intervalos v\u00e1lidos. d) Os limites n\u00e3o impactam o comportamento do programa.</p> <p>Resposta correta: c</p> <p>A experi\u00eancia mostra que casos de teste que exploram condi\u00e7\u00f5es de fronteira t\u00eam um retorno maior do que casos de teste que n\u00e3o exploram. Condi\u00e7\u00f5es de fronteira s\u00e3o aquelas situa\u00e7\u00f5es diretamente nos limites, acima e abaixo das bordas das classes de equival\u00eancia de entrada e sa\u00edda.</p> <p>\"Experience shows that test cases that explore boundary conditions have a higher payoff than test cases that do not. Boundary conditions are those situations directly on, above, and beneath the edges of input equivalence classes and output equivalence classes.\"</p> <p>(The Art of Software Testing, 3rd Edition, p. 55)</p>"},{"location":"tpi_tpe/tpi2_tpe2/#questao-9","title":"Quest\u00e3o 9","text":"<p>Enunciado: Por que \u00e9 importante considerar os limites das sa\u00eddas esperadas na an\u00e1lise de valor limite?</p> <p>Alternativas: a) Porque os testes de sa\u00edda s\u00e3o mais f\u00e1ceis de validar manualmente. b) Porque as sa\u00eddas s\u00e3o mais suscet\u00edveis a falhas. c) Porque o sistema pode falhar ao gerar sa\u00eddas pr\u00f3ximas aos seus limites esperados. d) Porque os limites de sa\u00edda n\u00e3o s\u00e3o influenciados pelas entradas.</p> <p>Resposta correta: c</p> <p>\u00c9 importante examinar os limites do espa\u00e7o de resultados porque nem sempre os limites dos dom\u00ednios de entrada representam as mesmas condi\u00e7\u00f5es que os limites das faixas de sa\u00edda. Mesmo que nem sempre seja poss\u00edvel gerar um resultado fora do intervalo de sa\u00edda, ainda assim vale a pena considerar essa possibilidade.</p> <p>\"Note that it is important to examine the boundaries of the result space because it is not always the case that the boundaries of the input domains represent the same set of circumstances as the boundaries of the output ranges... Also, it is not always possible to generate a result outside of the output range; nonetheless, it is worth considering the possibility.\"</p> <p>(The Art of Software Testing, 3rd Edition, p. 56)</p>"},{"location":"tpi_tpe/tpi2_tpe2/#questao-10","title":"Quest\u00e3o 10","text":"<p>Enunciado: Uma boa pr\u00e1tica ao aplicar an\u00e1lise de valor limite \u00e9:</p> <p>Alternativas: a) Utilizar o valor central do intervalo, al\u00e9m dos valores nos limites. b) Testar somente os valores inv\u00e1lidos. c) Testar os valores imediatamente abaixo, nos pr\u00f3prios limites e imediatamente acima dos limites v\u00e1lidos. d) Executar testes aleat\u00f3rios fora do intervalo.</p> <p>Resposta correta: c</p> <p>Se uma condi\u00e7\u00e3o de entrada especifica um intervalo de valores, escreva casos de teste para os valores nos extremos do intervalo, al\u00e9m de casos de teste de entradas inv\u00e1lidas imediatamente fora desses extremos. Por exemplo, se o dom\u00ednio v\u00e1lido de um valor de entrada for \u20131.0 a 1.0, escreva casos de teste para \u20131.0, 1.0, \u20131.001 e 1.001.</p> <p>\"If an input condition specifies a range of values, write test cases for the ends of the range, and invalid-input test cases for situations just beyond the ends. For instance, if the valid domain of an input value is \u20131.0 to 1.0, write test cases for the situations \u20131.0, 1.0, \u20131.001, and 1.001.\"</p> <p>(The Art of Software Testing, 3rd Edition, p. 56)</p>"},{"location":"tpi_tpe/tpi2_tpe2/#questao-11","title":"Quest\u00e3o 11","text":"<p>Enunciado: A t\u00e9cnica de grafo de causa-efeito \u00e9 mais apropriada quando:</p> <p>Alternativas: a) Os testes precisam ser derivados diretamente do c\u00f3digo-fonte. b) Todas as entradas s\u00e3o independentes entre si. c) H\u00e1 apenas uma entrada e uma sa\u00edda no sistema. d) Existem m\u00faltiplas condi\u00e7\u00f5es de entrada e regras de combina\u00e7\u00e3o complexas.</p> <p>Resposta correta: d</p> <p>O grafo de causa-efeito auxilia na sele\u00e7\u00e3o, de forma sistem\u00e1tica, de um conjunto de casos de teste de alto rendimento quando existem m\u00faltiplas condi\u00e7\u00f5es de entrada e combina\u00e7\u00f5es complexas. Al\u00e9m disso, ajuda a identificar ambiguidades e incompletudes na especifica\u00e7\u00e3o.</p> <p>\"Cause-effect graphing aids in selecting, in a systematic way, a high-yield set of test cases. It has a beneficial side effect in pointing out incompleteness and ambiguities in the specification.\"</p> <p>(The Art of Software Testing, 3rd Edition, p. 61)</p>"},{"location":"tpi_tpe/tpi2_tpe2/#questao-12","title":"Quest\u00e3o 12","text":"<p>Enunciado: Qual das seguintes atividades representa um exemplo de uso da t\u00e9cnica de error-guessing?</p> <p>Alternativas: a) Testar com campos vazios mesmo quando n\u00e3o explicitamente proibido nas regras. b) Usar apenas valores de entrada listados como v\u00e1lidos na documenta\u00e7\u00e3o. c) Executar todos os testes com base em classes de equival\u00eancia. d) Escolher entradas com base em \u00e1lgebra relacional.</p> <p>Resposta correta: a</p> <p>A t\u00e9cnica de error-guessing consiste em, a partir de intui\u00e7\u00e3o e experi\u00eancia, elaborar uma lista de poss\u00edveis situa\u00e7\u00f5es propensas a erro, e criar casos de teste para exp\u00f4-los \u2014 como, por exemplo, testar entradas em branco, entradas nulas ou outros casos n\u00e3o previstos explicitamente na especifica\u00e7\u00e3o.</p> <p>\"The basic idea is to enumerate a list of possible errors or error-prone situations and then write test cases based on the list. For instance, the presence of the value 0 in a program\u2019s input is an error-prone situation. Therefore, you might write test cases for which particular input values have a 0 value and for which particular output values are forced to 0. Also, where a variable number of inputs or outputs can be present (e.g., the number of entries in a list to be searched), the cases of 'none' and 'one' (e.g., empty list, list containing just one entry) are error-prone situations.\"</p> <p>(The Art of Software Testing, 3rd Edition, p. 81)</p>"},{"location":"tpi_tpe/tpi2_tpe2/#questao-13","title":"Quest\u00e3o 13","text":"<p>Enunciado: Quais t\u00e9cnicas s\u00e3o comumente utilizadas para derivar casos de teste no n\u00edvel funcional (sistema)?</p> <p>Alternativas: a) Caminho l\u00f3gico, MC/DC e tabelas de decis\u00e3o. b) Particionamento de equival\u00eancia, an\u00e1lise de valor limite e grafo de causa-efeito. c) An\u00e1lise l\u00e9xica e interpreta\u00e7\u00e3o sint\u00e1tica. d) An\u00e1lise de muta\u00e7\u00e3o e an\u00e1lise de fluxo de dados.</p> <p>Resposta correta: b</p> <p>O teste funcional normalmente emprega t\u00e9cnicas como particionamento de equival\u00eancia, an\u00e1lise de valor limite, grafo de causa-efeito e error-guessing, pois essas t\u00e9cnicas derivam casos de teste a partir das especifica\u00e7\u00f5es externas do sistema.</p> <p>\"The equivalence partitioning, boundary value analysis, cause-effect graphing, and error-guessing methods described in Chapter 4 are especially pertinent to function testing.\"</p> <p>(The Art of Software Testing, 3rd Edition, p. 119)</p>"},{"location":"tpi_tpe/tpi2_tpe2/#questao-14","title":"Quest\u00e3o 14","text":"<p>Enunciado: Os testes n\u00e3o-funcionais no n\u00edvel de sistema geralmente focam em:</p> <p>Alternativas: a) Caracter\u00edsticas como desempenho, usabilidade, confiabilidade e seguran\u00e7a. b) Corre\u00e7\u00e3o de bugs encontrados na fase de desenvolvimento. c) Execu\u00e7\u00e3o de testes de unidade em m\u00f3dulos isolados. d) Valida\u00e7\u00e3o de requisitos funcionais do usu\u00e1rio.</p> <p>Resposta correta: a</p> <p>O teste de sistema inclui categorias de teste para verificar desempenho, usabilidade, confiabilidade, seguran\u00e7a e outras qualidades n\u00e3o-funcionais, conforme objetivos estabelecidos. Esses testes procuram demonstrar que o programa n\u00e3o satisfaz seus objetivos em caracter\u00edsticas como tempo de resposta, throughput, capacidade de recupera\u00e7\u00e3o, servi\u00e7o, manuten\u00e7\u00e3o, entre outras.</p> <p>\"System testing includes categories such as performance, usability, reliability, security, recovery, serviceability/maintenance, documentation testing, and others. These categories verify that the system meets its objectives in non-functional qualities.\"</p> <p>(The Art of Software Testing, 3rd Edition, p. 127)</p>"},{"location":"tpi_tpe/tpi2_tpe2/#questao-15","title":"Quest\u00e3o 15","text":"<p>Enunciado: Um cen\u00e1rio comum de teste de desempenho inclui:</p> <p>Alternativas: a) Executar an\u00e1lises com altos volumes de dados de entrada. b) Gerar entradas aleat\u00f3rias para verificar falhas de formata\u00e7\u00e3o. c) Simular m\u00faltiplos usu\u00e1rios acessando o sistema simultaneamente. d) Verificar a ordena\u00e7\u00e3o correta de registros em um relat\u00f3rio.</p> <p>Resposta correta: c</p> <p>Uma abordagem comum ao avaliar o desempenho \u00e9 o teste de estresse. Ele envolve submeter a aplica\u00e7\u00e3o a m\u00faltiplos logins e simular transa\u00e7\u00f5es at\u00e9 o ponto de falha para determinar se o aplicativo atende a seus objetivos de desempenho. Isso normalmente significa simular m\u00faltiplos usu\u00e1rios acessando o sistema ao mesmo tempo.</p> <p>\"A common approach you may use when evaluating performance is stress testing. Often, performance degrades to the point of being unusable when the system becomes overloaded with requests... stress testing involves blasting the application with multiple logins, and simulating transactions to the point of failure so you can determine whether your application meets its performance objectives.\"</p> <p>(The Art of Software Testing, 3rd Edition, p. 206)</p>"},{"location":"tpi_tpe/tpi2_tpe2/#questao-16","title":"Quest\u00e3o 16","text":"<p>Enunciado: Um exemplo de teste de volume \u00e9:</p> <p>Alternativas: a) Aumentar a quantidade de usu\u00e1rios ativos simultaneamente. b) Avaliar a taxa de throughput. c) Importar um milh\u00e3o de registros em um sistema de cadastro. d) Validar se campos obrigat\u00f3rios est\u00e3o sendo preenchidos corretamente.</p> <p>Resposta correta: c</p> <p>O teste de volume consiste em submeter o programa a volumes anormalmente grandes de dados. Por exemplo, um compilador poderia receber um programa-fonte absurdamente grande, ou um sistema de cadastro poderia importar milh\u00f5es de registros. O objetivo \u00e9 demonstrar que o programa n\u00e3o consegue lidar com o volume de dados especificado em seus objetivos.</p> <p>\"Volume Testing A second type of system testing is to subject the program to heavy volumes of data. For instance, a compiler could be fed an absurdly large source program to compile... An electronic circuit simulator could be given a circuit containing millions of components... In other words, the purpose of volume testing is to show that the program cannot handle the volume of data specified in its objectives.\"</p> <p>(The Art of Software Testing, 3rd Edition, p. 123)</p>"},{"location":"tpi_tpe/tpi2_tpe2/#questao-17","title":"Quest\u00e3o 17","text":"<p>Enunciado: O teste de confiabilidade busca:</p> <p>Alternativas: a) Verificar se os dados est\u00e3o criptografados em repouso. b) Garantir que os m\u00f3dulos estejam integrados corretamente. c) Medir a capacidade do sistema de funcionar corretamente durante um per\u00edodo prolongado. d) Testar a responsividade da interface com o usu\u00e1rio.</p> <p>Resposta correta: c</p> <p>O objetivo do teste de confiabilidade est\u00e1 ligado a avaliar se o sistema mant\u00e9m seu funcionamento adequado e sem falhas ao longo de um per\u00edodo de opera\u00e7\u00e3o, visando garantir n\u00edveis aceit\u00e1veis de disponibilidade e tempo m\u00e9dio entre falhas (MTBF), por exemplo.</p> <p>\"Of course, the goal of all types of testing is the improvement of the program reliability, but if the program\u2019s objectives contain specific statements about reliability, specific reliability tests might be devised.\"</p> <p>(The Art of Software Testing, 3rd Edition, p. 127)</p>"},{"location":"tpi_tpe/tpi2_tpe2/#questao-18","title":"Quest\u00e3o 18","text":"<p>Enunciado: Qual \u00e9 um crit\u00e9rio razo\u00e1vel para encerrar os testes?</p> <p>Alternativas: a) Quando todos os casos de teste falharem pelo menos uma vez. b) Quando a curva de tend\u00eancia da taxa de defeitos por unidade estabilizar. c) Quando uma quantidade predefinida de falhas for identificada. d) Quando os usu\u00e1rios derem o aceite do sistema.</p> <p>Resposta correta: c</p> <p>O melhor crit\u00e9rio de encerramento provavelmente \u00e9 uma combina\u00e7\u00e3o de crit\u00e9rios. Uma abordagem recomendada \u00e9 observar a curva de tend\u00eancia do n\u00famero de erros encontrados ao longo do tempo durante a fase de testes. Se a efici\u00eancia na detec\u00e7\u00e3o de erros cair de forma significativa (ou seja, a curva se estabilizar), isso pode indicar que vale a pena encerrar os testes e partir para a pr\u00f3xima fase.</p> <p>\"The third type of completion criterion is an easy one on the surface, but it involves a lot of judgment and intuition. It requires you to plot the number of errors found per unit time during the test phase. By examining the shape of the curve, you can often determine whether to continue the test phase or end it and begin the next test phase.\"</p> <p>(The Art of Software Testing, 3rd Edition, p. 139)</p>"},{"location":"tpi_tpe/tpi3_tpe3/","title":"Question\u00e1rio - TPI/TPE-3","text":""},{"location":"tpi_tpe/tpi3_tpe3/#questao-1","title":"Quest\u00e3o 1","text":"<p>Enunciado: Por que a cobertura de linha n\u00e3o \u00e9 considerada suficiente como crit\u00e9rio de teste?</p> <p>Alternativas: a) Porque ela exige muitos testes para atingir alta cobertura b) Porque ela verifica apenas se todas as instru\u00e7\u00f5es foram executadas, sem garantir cobertura das decis\u00f5es c) Porque ela garante a cobertura de todas as condi\u00e7\u00f5es compostas d) Porque ela avalia somente entradas v\u00e1lidas</p> <p>Resposta correta: b</p>"},{"location":"tpi_tpe/tpi3_tpe3/#questao-2","title":"Quest\u00e3o 2","text":"<p>Enunciado: A cobertura de decis\u00e3o \u00e9 satisfeita quando:</p> <p>Alternativas: a) Todas as vari\u00e1veis foram testadas com valores extremos b) Todos os operadores l\u00f3gicos foram testados isoladamente c) Cada resultado poss\u00edvel de cada decis\u00e3o (true e false) ocorre em pelo menos um caso de teste d) Todos os caminhos poss\u00edveis do programa foram testados</p> <p>Resposta correta: c</p>"},{"location":"tpi_tpe/tpi3_tpe3/#questao-3","title":"Quest\u00e3o 3","text":"<p>Enunciado: A cobertura de condi\u00e7\u00e3o nem sempre \u00e9 mais forte que a de decis\u00e3o porque:</p> <p>Alternativas: a) Pode n\u00e3o garantir que ambos os resultados de uma decis\u00e3o ocorram b) Ela ignora a avalia\u00e7\u00e3o de vari\u00e1veis booleanas c) Avalia decis\u00f5es compostas sem condi\u00e7\u00f5es isoladas d) \u00c9 baseada apenas em testes de exce\u00e7\u00e3o</p> <p>Resposta correta: a</p>"},{"location":"tpi_tpe/tpi3_tpe3/#questao-4","title":"Quest\u00e3o 4","text":"<p>Enunciado: A cobertura de condi\u00e7\u00f5es exige que:</p> <p>Alternativas: a) Cada condi\u00e7\u00e3o em uma express\u00e3o seja avaliada como verdadeira e falsa em algum teste b) Todas as decis\u00f5es tenham a mesma quantidade de condi\u00e7\u00f5es c) Cada condi\u00e7\u00e3o seja executada pelo menos uma vez d) Todas as combina\u00e7\u00f5es de condi\u00e7\u00f5es resultem em verdade e falso</p> <p>Resposta correta: a</p>"},{"location":"tpi_tpe/tpi3_tpe3/#questao-5","title":"Quest\u00e3o 5","text":"<p>Enunciado: A cobertura de decis\u00e3o/condi\u00e7\u00e3o n\u00e3o garante:</p> <p>Alternativas: a) A execu\u00e7\u00e3o de todos os loops envolvendo decis\u00f5es b) Que todas as decis\u00f5es sejam falsas ao menos uma vez c) Que todas as instru\u00e7\u00f5es de decis\u00f5es sejam executadas d) Que cada condi\u00e7\u00e3o isoladamente determine o resultado da decis\u00e3o</p> <p>Resposta correta: d</p>"},{"location":"tpi_tpe/tpi3_tpe3/#questao-6","title":"Quest\u00e3o 6","text":"<p>Enunciado: A cobertura de m\u00faltiplas condi\u00e7\u00f5es exige que:</p> <p>Alternativas: a) Cada condi\u00e7\u00e3o seja testada isoladamente b) Todas as decis\u00f5es tenham apenas duas condi\u00e7\u00f5es c) Todas as combina\u00e7\u00f5es poss\u00edveis de valores das condi\u00e7\u00f5es em uma decis\u00e3o sejam testadas d) Todas as m\u00faltiplas decis\u00f5es e condi\u00e7\u00f5es sejam executadas</p> <p>Resposta correta: c</p>"},{"location":"tpi_tpe/tpi3_tpe3/#questao-7","title":"Quest\u00e3o 7","text":"<p>Enunciado: Em compara\u00e7\u00e3o com outros crit\u00e9rios, o MC/DC:</p> <p>Alternativas: a) \u00c9 mais forte que a cobertura de m\u00faltiplas condi\u00e7\u00f5es b) Garante que cada condi\u00e7\u00e3o influencie o resultado da decis\u00e3o, mas com menos casos de teste do que a cobertura de m\u00faltiplas condi\u00e7\u00f5es c) \u00c9 inferior ao teste de condi\u00e7\u00f5es/decis\u00f5es por gerar menos casos de testes d) Testa todas as combina\u00e7\u00f5es das m\u00faltiplas condi\u00e7\u00f5es em cada decis\u00e3o</p> <p>Resposta correta: b</p>"},{"location":"tpi_tpe/tpi3_tpe3/#questao-8","title":"Quest\u00e3o 8","text":"<p>Enunciado: Para aplicar MC/DC corretamente, deve-se:</p> <p>Alternativas: a) Testar todos os caminhos independentes do programa b) Garantir que cada linha de c\u00f3digo seja executada c) Usar apenas condi\u00e7\u00f5es independentes para cada uma das decis\u00f5es d) Criar pares de casos de teste que diferem em uma \u00fanica condi\u00e7\u00e3o e causam mudan\u00e7a na decis\u00e3o</p> <p>Resposta correta: d</p>"},{"location":"tpi_tpe/tpi3_tpe3/#questao-9","title":"Quest\u00e3o 9","text":"<p>Enunciado: Considere a seguinte decis\u00e3o: (A &amp;&amp; B) || C. Quais dos pares de valores abaixo demonstram independ\u00eancia da condi\u00e7\u00e3o C?</p> <p>Alternativas: a) A = false, B = false, C = false e A = false, B = false, C = true b) A = true, B = true, C = false e A = false, B = true, C = true c) A = true, B = true, C = true e A = false, B = false, C = false d) A = true, B = false, C = true e A = true, B = true, C = false</p> <p>Resposta correta: a</p>"},{"location":"tpi_tpe/tpi3_tpe3/#questao-10","title":"Quest\u00e3o 10","text":"<p>Enunciado: Dada a express\u00e3o A || (B &amp;&amp; C), quais dos pares abaixo demonstram que B afeta o resultado da decis\u00e3o independentemente das demais?</p> <p>Alternativas: a) A = true, B = false, C = false e A = false, B = false, C = true b) A = true, B = true, C = false e A = true, B = false, C = true c) A = false, B = false, C = true e A = false, B = true, C = true d) A = false, B = false, C = false e A = false, B = true, C = false</p> <p>Resposta correta: c</p>"},{"location":"tpi_tpe/tpi3_tpe3/#questao-11","title":"Quest\u00e3o 11","text":"<p>Enunciado: O primeiro passo na elabora\u00e7\u00e3o de testes caixa-branca \u00e9:</p> <p>Alternativas: a) Analisar o fluxo de controle e identificar decis\u00f5es e condi\u00e7\u00f5es b) Definir crit\u00e9rios de desempenho da aplica\u00e7\u00e3o c) Construir um grafo de fluxo de controle d) Analisar os requisitos funcionais e n\u00e3o funcionais</p> <p>Resposta correta: a</p>"},{"location":"tpi_tpe/tpi3_tpe3/#questao-12","title":"Quest\u00e3o 12","text":"<p>Enunciado: Para elaborar testes caixa-branca, deve-se elencar os resultados das sa\u00eddas das decis\u00f5es para:</p> <p>Alternativas: a) Garantir que todos os caminhos poss\u00edveis do c\u00f3digo sejam exercitados b) Aumentar o n\u00famero de testes executados c) Testar as condi\u00e7\u00f5es de forma isolada d) For\u00e7ar a execu\u00e7\u00e3o de todas as condi\u00e7\u00f5es verdadeiras</p> <p>Resposta correta: a</p>"},{"location":"tpi_tpe/tpi3_tpe3/#questao-13","title":"Quest\u00e3o 13","text":"<p>Enunciado: No contexto do teste unit\u00e1rio, drivers s\u00e3o:</p> <p>Alternativas: a) Programas que automatizam a gera\u00e7\u00e3o de c\u00f3digo b) Scripts que testam apenas interfaces gr\u00e1ficas c) Unidades auxiliares para testes de desempenho d) M\u00f3dulos que simulam chamadas de m\u00f3dulos superiores a um m\u00f3dulo em teste</p> <p>Resposta correta: d</p>"},{"location":"tpi_tpe/tpi3_tpe3/#questao-14","title":"Quest\u00e3o 14","text":"<p>Enunciado: Por que o teste incremental \u00e9 preferido ao teste n\u00e3o incremental?</p> <p>Alternativas: a) Porque testa os m\u00f3dulos \u00e0 medida que s\u00e3o integrados, facilitando a detec\u00e7\u00e3o de falhas b) Porque n\u00e3o requer testes de regress\u00e3o, aumentando a efici\u00eancia do teste c) Porque ignora falhas em m\u00f3dulos j\u00e1 testados, reduzindo a quantidade de casos de teste d) Porque \u00e9 mais r\u00e1pido e mais eficiente que o teste unit\u00e1rio</p> <p>Resposta correta: a</p>"},{"location":"tpi_tpe/tpi3_tpe3/#questao-15","title":"Quest\u00e3o 15","text":"<p>Enunciado: Qual a principal vantagem do top-down testing?</p> <p>Alternativas: a) Permite validar a l\u00f3gica de controle do sistema a partir dos n\u00edveis superiores b) Reduz a necessidade de integra\u00e7\u00e3o ao testar apenas o m\u00f3dulo principal do sistema c) Testa todos os m\u00f3dulos simultaneamente utilizando drivers e stubs d) Testa os m\u00f3dulos de mais alto n\u00edvel primeiro, substituindo os inferiores por drivers</p> <p>Resposta correta: a</p>"},{"location":"tpi_tpe/tpi4_tpe4/","title":"Question\u00e1rio - TPI/TPE-4","text":""},{"location":"tpi_tpe/tpi4_tpe4/#questao-1","title":"Quest\u00e3o 1","text":"<p>Enunciado: O que s\u00e3o objetos dummy?</p> <p>Alternativas: a) Objetos que possuem implementa\u00e7\u00f5es reais, mas simplificadas b) Objetos passados para a classe em teste, mas nunca utilizados c) Objetos que fornecem respostas codificadas para chamadas realizadas durante o teste d) Objetos que gravam todas as intera\u00e7\u00f5es e permitem fazer asser\u00e7\u00f5es posteriormente</p> <p>Resposta correta: b</p>"},{"location":"tpi_tpe/tpi4_tpe4/#questao-2","title":"Quest\u00e3o 2","text":"<p>Enunciado: Qual a principal caracter\u00edstica de objetos fake?</p> <p>Alternativas: a) Eles t\u00eam implementa\u00e7\u00f5es reais, mas geralmente fazem a tarefa de forma mais simples b) Eles fornecem respostas codificadas para chamadas realizadas durante o teste c) Eles gravam todas as intera\u00e7\u00f5es e permitem fazer asser\u00e7\u00f5es posteriormente d) Eles envolvem o objeto real e observam seu comportamento</p> <p>Resposta correta: a</p>"},{"location":"tpi_tpe/tpi4_tpe4/#questao-3","title":"Quest\u00e3o 3","text":"<p>Enunciado: Como os stubs diferem dos objetos fake?</p> <p>Alternativas: a) Stubs t\u00eam implementa\u00e7\u00f5es reais, mas simplificadas b) Stubs s\u00e3o usados apenas para observar o comportamento de uma depend\u00eancia real c) Stubs fornecem respostas codificadas e n\u00e3o t\u00eam uma implementa\u00e7\u00e3o funcional d) Stubs permitem fazer asser\u00e7\u00f5es sobre as intera\u00e7\u00f5es ap\u00f3s o teste</p> <p>Resposta correta: c</p>"},{"location":"tpi_tpe/tpi4_tpe4/#questao-4","title":"Quest\u00e3o 4","text":"<p>Enunciado: Qual a vantagem principal dos objetos mocks em compara\u00e7\u00e3o com os stubs?</p> <p>Alternativas: a) Mocks t\u00eam implementa\u00e7\u00f5es reais b) Mocks s\u00e3o mais f\u00e1ceis de controlar do que stubs c) Mocks podem gravar intera\u00e7\u00f5es e permitir asser\u00e7\u00f5es sobre elas d) Mocks fornecem respostas codificadas para chamadas realizadas durante o teste</p> <p>Resposta correta: c</p>"},{"location":"tpi_tpe/tpi4_tpe4/#questao-5","title":"Quest\u00e3o 5","text":"<p>Enunciado: Uma classe que simula uma base de dados usando um array list em vez de uma base de dados real pode ser classificada como que tipo de dubl\u00ea de teste?</p> <p>Alternativas: a) Fake object b) Dummy object c) Mock d) Stub</p> <p>Resposta correta: a</p>"},{"location":"tpi_tpe/tpi4_tpe4/#questao-6","title":"Quest\u00e3o 6","text":"<p>Enunciado: O que pode ser necess\u00e1rio para injetar dubl\u00eas de teste nas classes sendo testadas?</p> <p>Alternativas: a) Pode ser necess\u00e1rio criar um tipo especial de dubl\u00ea de teste que seja capaz de interceptar as chamadas da classe sendo testada a partir da classe de depend\u00eancia b) Pode ser necess\u00e1rio refatorar o construtor da classe de teste para instanciar a classe que ser\u00e1 mockada no c\u00f3digo da classe sendo testada c) Pode ser necess\u00e1rio utilizar um framework de mocking para que o dubl\u00ea de teste seja injetado na classe de depend\u00eancia d) Pode ser necess\u00e1rio alterar o c\u00f3digo da classe sendo testada para passar a classe de depend\u00eancia que ser\u00e1 mockada em seu construtor</p> <p>Resposta correta: d</p>"},{"location":"tpi_tpe/tpi4_tpe4/#questao-7","title":"Quest\u00e3o 7","text":"<p>Enunciado: Qual \u00e9 a principal vantagem de configurar dubl\u00eas para lan\u00e7ar exce\u00e7\u00f5es em testes de software?</p> <p>Alternativas: a) Permite testar como os sistemas se comportariam em cen\u00e1rios inesperados, simulando a indisponibilidade de sistemas externos b) Garante que todos os m\u00e9todos da aplica\u00e7\u00e3o sejam chamados pelo menos uma vez durante o teste, cobrindo diversos cen\u00e1rios c) Facilita a implementa\u00e7\u00e3o de respostas codificadas para chamadas realizadas durante o teste, simplificando o processo d) Substitui a necessidade de testes de integra\u00e7\u00e3o com sistemas externos reais, economizando tempo e recursos</p> <p>Resposta correta: a</p>"},{"location":"tpi_tpe/tpi4_tpe4/#questao-8","title":"Quest\u00e3o 8","text":"<p>Enunciado: Qual \u00e9 uma das principais desvantagens de usar dubl\u00eas de teste?</p> <p>Alternativas: a) O acoplamento entre os dubl\u00eas e o c\u00f3digo de produ\u00e7\u00e3o, que pode causar a falha dos testes quando a intera\u00e7\u00e3o entre as classes muda b) A dificuldade em configurar e manter os dubl\u00eas durante o ciclo de vida do projeto, resultando em testes menos eficientes c) A incapacidade de dubl\u00eas em simular comportamentos complexos de sistemas externos, limitando a efic\u00e1cia dos testes d) A necessidade de modificar o c\u00f3digo de produ\u00e7\u00e3o para acomodar o uso de dubl\u00eas, introduzindo complexidade desnecess\u00e1ria</p> <p>Resposta correta: a</p>"},{"location":"tpi_tpe/tpi4_tpe4/#questao-9","title":"Quest\u00e3o 9","text":"<p>Enunciado: Qual \u00e9 o ciclo repetido no processo de TDD (Test-Driven Development)?</p> <p>Alternativas: a) Escrever um teste que passe, implementar a funcionalidade, refatorar o c\u00f3digo de produ\u00e7\u00e3o e de teste b) Escrever um teste que falhe, implementar a funcionalidade para que o teste passe, refatorar o c\u00f3digo de produ\u00e7\u00e3o e de teste c) Implementar a funcionalidade, escrever um teste que passe, refatorar o c\u00f3digo de produ\u00e7\u00e3o e de teste d) Refatorar o c\u00f3digo de produ\u00e7\u00e3o, escrever um teste que falhe, implementar a funcionalidade para que o teste passe</p> <p>Resposta correta: b</p>"},{"location":"tpi_tpe/tpi4_tpe4/#questao-10","title":"Quest\u00e3o 10","text":"<p>Enunciado: Por que o TDD facilita a identifica\u00e7\u00e3o de novos problemas \u00e0 medida que surgem?</p> <p>Alternativas: a) Porque os desenvolvedores escrevem grandes peda\u00e7os de c\u00f3digo de produ\u00e7\u00e3o antes de obter qualquer feedback b) Porque os desenvolvedores podem focar especificamente no c\u00f3digo, concentrando-se no produto final c) Porque os desenvolvedores escrevem todos os testes de uma vez e depois implementam a funcionalidade d) Porque os desenvolvedores s\u00e3o for\u00e7ados a dar um passo de cada vez, escrevendo um teste, fazendo-o passar e refletindo, facilitando a identifica\u00e7\u00e3o de problemas depois de pequenas altera\u00e7\u00f5es</p> <p>Resposta correta: d</p>"},{"location":"tpi_tpe/tpi4_tpe4/#questao-11","title":"Quest\u00e3o 11","text":"<p>Enunciado: Como o TDD afeta o design das classes ou componentes?</p> <p>Alternativas: a) O c\u00f3digo de teste raramente influencia o design das classes ou componentes b) O c\u00f3digo de teste \u00e9 frequentemente o primeiro cliente da classe ou componente, moldando seu design se ele estiver dif\u00edcil de testar c) O TDD encoraja designs mais complexos, pois cada teste cobre m\u00faltiplos casos d) O TDD desencoraja a refatora\u00e7\u00e3o, pois prioriza apenas passar nos testes</p> <p>Resposta correta: b</p>"},{"location":"tpi_tpe/tpi4_tpe4/#questao-12","title":"Quest\u00e3o 12","text":"<p>Enunciado: Quando o uso do TDD pode ser mais vantajoso?</p> <p>Alternativas: a) Em problemas simples, onde a abordagem TDD pode ser aplicada rapidamente b) Em qualquer tipo de problema, independentemente da complexidade c) Em projetos de manuten\u00e7\u00e3o, onde o c\u00f3digo j\u00e1 est\u00e1 bem estabelecido d) Em problemas mais complicados, onde o TDD ajuda a estruturar melhor o desenvolvimento e detectar problemas de design mais cedo</p> <p>Resposta correta: d</p>"},{"location":"tpi_tpe/tpi4_tpe4/#questao-13","title":"Quest\u00e3o 13","text":"<p>Enunciado: Em quais situa\u00e7\u00f5es o uso do TDD n\u00e3o \u00e9 recomendado?</p> <p>Alternativas: a) Quando o problema \u00e9 bem conhecido e n\u00e3o h\u00e1 necessidade de experimenta\u00e7\u00e3o b) Quando se est\u00e1 trabalhando em projetos \u00e1geis, onde a velocidade de entrega \u00e9 crucial c) Quando se est\u00e1 desenvolvendo software para sistemas embarcados, devido \u00e0s suas limita\u00e7\u00f5es naturais d) Quando a pir\u00e2mide de testes n\u00e3o estiver sendo aplicada como estrat\u00e9gia de testes</p> <p>Resposta correta: a</p>"},{"location":"tpi_tpe/tpi4_tpe4/#questao-14","title":"Quest\u00e3o 14","text":"<p>Enunciado: Qual \u00e9 a efic\u00e1cia dos testes gerados durante as sess\u00f5es de TDD em compara\u00e7\u00e3o com testes sistem\u00e1ticos?</p> <p>Alternativas: a) As su\u00edtes de teste geradas durante as sess\u00f5es de TDD s\u00e3o superiores \u00e0s su\u00edtes de teste sistem\u00e1ticos em v\u00e1rios aspectos b) As su\u00edtes de teste geradas durante as sess\u00f5es de TDD s\u00e3o equivalentes \u00e0s su\u00edtes de teste sistem\u00e1ticos c) As su\u00edtes de teste geradas durante as sess\u00f5es de TDD s\u00e3o inferiores \u00e0s su\u00edtes de teste sistem\u00e1ticos apenas em projetos pequenos d) As su\u00edtes de teste geradas durante as sess\u00f5es de TDD n\u00e3o s\u00e3o t\u00e3o boas quanto as su\u00edtes de teste sistem\u00e1ticos, pois TDD foca no desenvolvimento e n\u00e3o no teste</p> <p>Resposta correta: d</p>"},{"location":"tpi_tpe/tpi5_tpe5/","title":"Question\u00e1rio - TPI/TPE-5","text":""},{"location":"tpi_tpe/tpi5_tpe5/#questao-1","title":"Quest\u00e3o 1","text":"<p>Enunciado: Por que \u00e9 importante desenvolver a mentalidade correta ao testar a seguran\u00e7a de aplica\u00e7\u00f5es web?</p> <p>Alternativas: a) Porque os testes de seguran\u00e7a devem seguir os mesmos cen\u00e1rios dos testes funcionais. b) Porque a maioria das ferramentas automatizadas cobre todos os cen\u00e1rios poss\u00edveis de ataque. c) Porque \u00e9 necess\u00e1rio pensar como um atacante e explorar comportamentos inesperados que n\u00e3o foram considerados pelos desenvolvedores. d) Porque os testes de seguran\u00e7a devem priorizar a valida\u00e7\u00e3o dos fluxos de uso previstos pelo neg\u00f3cio.</p> <p>Resposta correta: c</p>"},{"location":"tpi_tpe/tpi5_tpe5/#questao-2","title":"Quest\u00e3o 2","text":"<p>Enunciado: Qual das alternativas melhor descreve uma vantagem das inspe\u00e7\u00f5es manuais no processo de teste de seguran\u00e7a?</p> <p>Alternativas: a) Podem ser executadas em curto espa\u00e7o de tempo, principalmente se houver material de apoio dispon\u00edvel. b) Permitem que a verifica\u00e7\u00e3o seja realizada em est\u00e1gios finais do SDLC. c) Podem avaliar pol\u00edticas, habilidades e decis\u00f5es de arquitetura por meio de an\u00e1lise de documenta\u00e7\u00e3o e entrevistas. d) S\u00e3o recomendadas quando n\u00e3o h\u00e1 especialista em seguran\u00e7a dispon\u00edvel para a equipe.</p> <p>Resposta correta: c</p>"},{"location":"tpi_tpe/tpi5_tpe5/#questao-3","title":"Quest\u00e3o 3","text":"<p>Enunciado: Qual \u00e9 o objetivo principal da modelagem de amea\u00e7as (threat modeling) no contexto de seguran\u00e7a de aplica\u00e7\u00f5es?</p> <p>Alternativas: a) Avaliar riscos e antecipar amea\u00e7as para desenvolver estrat\u00e9gias de mitiga\u00e7\u00e3o desde as primeiras fases do SDLC. b) Medir o desempenho da aplica\u00e7\u00e3o em cen\u00e1rios de ataque de DDOS. c) Substituir a an\u00e1lise de c\u00f3digo-fonte na identifica\u00e7\u00e3o de falhas de seguran\u00e7a. d) Testar a efic\u00e1cia das ferramentas automatizadas de seguran\u00e7a, a partir da modelagem da aplica\u00e7\u00e3o.</p> <p>Resposta correta: a</p>"},{"location":"tpi_tpe/tpi5_tpe5/#questao-4","title":"Quest\u00e3o 4","text":"<p>Enunciado: Qual \u00e9 uma limita\u00e7\u00e3o importante da revis\u00e3o de c\u00f3digo-fonte?</p> <p>Alternativas: a) O c\u00f3digo analisado pode n\u00e3o ser o mesmo que ser\u00e1 implantado em produ\u00e7\u00e3o. b) \u00c9 um processo lento, mesmo para desenvolvedores bastante experientes. c) Identifica tipos de vulnerabilidades que poderiam ser detectadas por outros m\u00e9todos. d) \u00c9 realizada apenas nos est\u00e1gios finais do SDLC, reduzindo sua efic\u00e1cia.</p> <p>Resposta correta: a</p>"},{"location":"tpi_tpe/tpi5_tpe5/#questao-5","title":"Quest\u00e3o 5","text":"<p>Enunciado: Qual \u00e9 uma vantagem do teste de penetra\u00e7\u00e3o em aplica\u00e7\u00f5es web?</p> <p>Alternativas: a) Permite modificar o comportamento da aplica\u00e7\u00e3o sem acesso ao ambiente de produ\u00e7\u00e3o. b) Pode ser realizado nos est\u00e1gios iniciais do SDLC, ampliando a capacidade de detec\u00e7\u00e3o de vulnerabilidades. c) Substitui a necessidade de entrevistas e an\u00e1lise documental para detectar vulnerabilidades. d) Avalia o comportamento do c\u00f3digo realmente implantado, mesmo sem conhecer sua implementa\u00e7\u00e3o interna.</p> <p>Resposta correta: d</p>"},{"location":"tpi_tpe/tpi5_tpe5/#questao-6","title":"Quest\u00e3o 6","text":"<p>Enunciado: Qual \u00e9 uma vantagem principal da revis\u00e3o manual do c\u00f3digo-fonte para identificar problemas de seguran\u00e7a em aplica\u00e7\u00f5es web?</p> <p>Alternativas: a) Permite detectar problemas de seguran\u00e7a que outras formas de an\u00e1lise, como testes de penetra\u00e7\u00e3o, podem n\u00e3o identificar. b) Facilita a execu\u00e7\u00e3o sistem\u00e1tica de testes de seguran\u00e7a, por ser um m\u00e9todo caixa-preta. c) Elimina a necessidade de verificar a l\u00f3gica de neg\u00f3cios e o controle de acesso. d) Reduz a necessidade de habilidades t\u00e9cnicas para identificar vulnerabilidades.</p> <p>Resposta correta: a</p>"},{"location":"tpi_tpe/tpi5_tpe5/#questao-7","title":"Quest\u00e3o 7","text":"<p>Enunciado: No processo de deriva\u00e7\u00e3o de requisitos de seguran\u00e7a usando casos de uso e abuso, qual \u00e9 a import\u00e2ncia de descrever cen\u00e1rios negativos, como ataques de for\u00e7a bruta?</p> <p>Alternativas: a) Para garantir que a aplica\u00e7\u00e3o seja capaz de fornecer respostas espec\u00edficas para cada tipo de ataque identificado. b) Para identificar e documentar vulnerabilidades potenciais e as contramedidas necess\u00e1rias para mitigar os riscos associados a ataques. c) Para avaliar a conformidade da aplica\u00e7\u00e3o com regulamentos e padr\u00f5es de seguran\u00e7a aplic\u00e1veis. d) Para implementar controles de seguran\u00e7a que bloqueiem o acesso n\u00e3o autorizado antes do in\u00edcio do desenvolvimento.</p> <p>Resposta correta: b</p>"},{"location":"tpi_tpe/tpi5_tpe5/#questao-8","title":"Quest\u00e3o 8","text":"<p>Enunciado: A prote\u00e7\u00e3o de dados sens\u00edveis, como informa\u00e7\u00f5es pessoalmente identific\u00e1veis (PII), deve envolver a valida\u00e7\u00e3o de qual requisito de seguran\u00e7a?</p> <p>Alternativas: a) A an\u00e1lise de risco baseada no n\u00edvel de sensibilidade do dado. b) A verifica\u00e7\u00e3o do uso de criptografia. c) A verifica\u00e7\u00e3o da conformidade com as pol\u00edticas de seguran\u00e7a da informa\u00e7\u00e3o da empresa. d) A elimina\u00e7\u00e3o do armazenamento de dados sens\u00edveis.</p> <p>Resposta correta: c</p>"},{"location":"tpi_tpe/tpi5_tpe5/#questao-9","title":"Quest\u00e3o 9","text":"<p>Enunciado: Por que os requisitos de seguran\u00e7a baseados em risco (negativos) s\u00e3o mais dif\u00edceis de testar do que os requisitos funcionais (positivos)?</p> <p>Alternativas: a) Porque eles sempre exigem o uso de ferramentas de fuzzing automatizado. b) Porque n\u00e3o podem ser descritos por meio de casos de uso nem validados com testes de penetra\u00e7\u00e3o. c) Porque dependem exclusivamente de verifica\u00e7\u00f5es manuais feitas ap\u00f3s a implanta\u00e7\u00e3o do sistema. d) Porque n\u00e3o descrevem um comportamento esperado, exigindo an\u00e1lise de amea\u00e7as e cen\u00e1rios imprevistos.</p> <p>Resposta correta: d</p>"},{"location":"tpi_tpe/tpi5_tpe5/#questao-10","title":"Quest\u00e3o 10","text":"<p>Enunciado: O que s\u00e3o \"misuse cases\" ou \"abuse cases\" no contexto da engenharia de requisitos de seguran\u00e7a?</p> <p>Alternativas: a) Cen\u00e1rios que descrevem como um sistema pode ser maliciosamente explorado. b) Casos de teste automatizados para validar funcionalidades n\u00e3o documentadas. c) Casos de uso voltados para testes de desempenho em ambientes inseguros. d) Casos que descrevem a experi\u00eancia do usu\u00e1rio em situa\u00e7\u00f5es de erro.</p> <p>Resposta correta: a</p>"},{"location":"tpi_tpe/tpi5_tpe5/#questao-11","title":"Quest\u00e3o 11","text":"<p>Enunciado: Como os testes unit\u00e1rios de seguran\u00e7a contribuem para a valida\u00e7\u00e3o de mudan\u00e7as no c\u00f3digo ap\u00f3s a corre\u00e7\u00e3o de vulnerabilidades?</p> <p>Alternativas: a) Garantem que a nova funcionalidade foi implementada conforme as especifica\u00e7\u00f5es do cliente. b) Verificam se as altera\u00e7\u00f5es no c\u00f3digo mitigam a vulnerabilidade identificada e seguem os padr\u00f5es de codifica\u00e7\u00e3o segura. c) Permitem que o c\u00f3digo com problemas de seguran\u00e7a seja inclu\u00eddo no build desde que esteja documentado. d) Avaliam o impacto das mudan\u00e7as no desempenho do sistema em tempo de execu\u00e7\u00e3o.</p> <p>Resposta correta: b</p>"},{"location":"tpi_tpe/tpi5_tpe5/#questao-12","title":"Quest\u00e3o 12","text":"<p>Enunciado: O que ocorre com um pacote no pipeline DevSecOps quando o resultado das atividades de seguran\u00e7a n\u00e3o atender aos requisitos de um checkpoint?</p> <p>Alternativas: a) O pacote \u00e9 automaticamente modificado para atender aos requisitos de seguran\u00e7a necess\u00e1rios. b) O pacote \u00e9 encaminhado para uma revis\u00e3o externa para verificar a conformidade com os requisitos de seguran\u00e7a. c) O pacote avan\u00e7a para o pr\u00f3ximo est\u00e1gio, mas com uma nota de alerta sobre os requisitos de seguran\u00e7a n\u00e3o atendidos. d) O pacote permanece na fase atual e n\u00e3o \u00e9 permitido avan\u00e7ar para o pr\u00f3ximo checkpoint ou est\u00e1gio.</p> <p>Resposta correta: d</p>"},{"location":"tpi_tpe/tpi5_tpe5/#questao-13","title":"Quest\u00e3o 13","text":"<p>Enunciado: Qual \u00e9 a abordagem recomendada para introduzir recursos de testes de seguran\u00e7a no pipeline de entrega para suportar DevSecOps?</p> <p>Alternativas: a) Introduzir todos os recursos de testes de seguran\u00e7a de forma integral para garantir uma abordagem completa desde o in\u00edcio. b) Investir em ferramentas atualizadas e avan\u00e7adas substituindo as ferramentas existentes para garantir uma integra\u00e7\u00e3o eficiente. c) Realizar a automa\u00e7\u00e3o de controles e atividades de seguran\u00e7a antes de implementar qualquer ferramenta de seguran\u00e7a existente. d) Come\u00e7ar com recursos de testes de seguran\u00e7a de alto valor e baixo impacto, como ferramentas de qualidade de c\u00f3digo, e adicionar novos recursos gradualmente.</p> <p>Resposta correta: d</p>"},{"location":"tpi_tpe/tpi5_tpe5/#questao-14","title":"Quest\u00e3o 14","text":"<p>Enunciado: Qual \u00e9 um benef\u00edcio de utilizar uma su\u00edte de testes de seguran\u00e7a gen\u00e9rica integrada ao framework de testes unit\u00e1rios dos desenvolvedores?</p> <p>Alternativas: a) Permitir a verifica\u00e7\u00e3o das funcionalidades de seguran\u00e7a tanto para requisitos positivos quanto negativos em componentes de software. b) Facilitar a cria\u00e7\u00e3o de novos m\u00f3dulos de software sem a necessidade de an\u00e1lise de c\u00f3digo. c) Identificar problemas de desempenho em tempo real durante a execu\u00e7\u00e3o do c\u00f3digo, em fun\u00e7\u00e3o dos requisitos de seguran\u00e7a adicionais. d) Automatizar os testes, substituindo a necessidade de testes de seguran\u00e7a realizados por engenheiros de seguran\u00e7a especializados.</p> <p>Resposta correta: a</p>"}]}