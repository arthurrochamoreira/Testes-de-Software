{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Testes de Software \u2014 Documenta\u00e7\u00e3o Pessoal","text":"<p>Bem-vindo \u00e0 minha documenta\u00e7\u00e3o pessoal sobre Testes de Software, desenvolvida como apoio aos estudos da disciplina cursada na gradua\u00e7\u00e3o em Engenharia de Software.</p> <p>Este reposit\u00f3rio serve como um guia pr\u00e1tico e te\u00f3rico, reunindo conceitos essenciais, estrat\u00e9gias de teste, padr\u00f5es e boas pr\u00e1ticas, com base em materiais cl\u00e1ssicos da \u00e1rea como:</p> <ul> <li>xUnit Test Patterns (Meszaros, 2007)</li> <li>Test-Driven Development: By Example (Kent Beck, 2002)</li> <li>The Art of Software Testing (Glenford J. Myers, 2011)</li> </ul>"},{"location":"aae3/aae3/","title":"1. Relat\u00f3rio de Cobertura MC/DC \u2014 Atividade AAE-3","text":""},{"location":"aae3/aae3/#11-objetivo","title":"1.1 Objetivo","text":"<p>Elaborar o menor conjunto de casos de teste que garanta 100% de cobertura segundo o crit\u00e9rio MC/DC para o m\u00e9todo <code>isNumber(String number)</code> abaixo:</p> <pre><code>public boolean isNumber(String number) {\n    if (number == null || number.isEmpty()) {\n        return false;\n    }\n\n    if (number.length() == 1 &amp;&amp; (number.charAt(0) == '-' || number.charAt(0) == '+')) {\n        return false;\n    }\n\n    for (int i = 0; i &lt; number.length(); i++) {\n        char c = number.charAt(i);\n\n        if (i == 0 &amp;&amp; (c == '-' || c == '+')) {\n            continue;\n        } else if (!Character.isDigit(c)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n</code></pre>"},{"location":"aae3/aae3/#12-recapitulando-mcdc","title":"1.2 Recapitulando MC/DC","text":"<p>MC/DC (Cobertura de Decis\u00e3o/Condi\u00e7\u00e3o Modificada) \u00e9 uma t\u00e9cnica de teste que exige:</p> <ol> <li>Que cada condi\u00e7\u00e3o booleana dentro de uma decis\u00e3o seja avaliada como verdadeira e falsa.</li> <li>Que, para cada condi\u00e7\u00e3o, seja demonstrado que ela, isoladamente, pode alterar o resultado da decis\u00e3o.</li> </ol>"},{"location":"aae3/aae3/#exemplo-if-a-b","title":"Exemplo: <code>if (A &amp;&amp; B)</code>","text":"Caso A B Resultado O que muda? D-Ex-T1 F V F Base para testar A D-Ex-T2 V V V (B = V; A muda F \u2192 V; resultado muda F \u2192 V) \u2713 D-Ex-T3 V F F Base para testar B D-Ex-T4 V V V (A = V; B muda F \u2192 V; resultado muda F \u2192 V) \u2713"},{"location":"aae3/aae3/#decisoes-validas-em-mcdc","title":"Decis\u00f5es v\u00e1lidas em MC/DC","text":"<p>Uma decis\u00e3o v\u00e1lida \u00e9 qualquer express\u00e3o booleana que:</p> <ul> <li>Controle o fluxo (<code>if</code>, <code>while</code>, <code>for</code>, <code>else if</code> etc.).</li> <li>Seja composta por duas ou mais condi\u00e7\u00f5es ligadas por <code>&amp;&amp;</code> ou <code>||</code>.</li> <li>Permita que cada condi\u00e7\u00e3o, isoladamente, altere o resultado.</li> </ul> <p>Nota:</p> <ul> <li>Condi\u00e7\u00f5es de la\u00e7o sem m\u00faltiplas vari\u00e1veis (ex.: <code>i &lt; n</code> em <code>for</code>) n\u00e3o precisam de MC/DC.</li> </ul>"},{"location":"aae3/aae3/#2-primeira-decisao-linha-2","title":"2. Primeira decis\u00e3o (linha 2)","text":"<pre><code>if (number == null || number.isEmpty()) {\n    return false;\n}\n</code></pre> <ul> <li>C1: <code>number == null</code></li> <li>C2: <code>number.isEmpty()</code></li> </ul>"},{"location":"aae3/aae3/#estrutura-logica","title":"Estrutura l\u00f3gica","text":"<pre><code>C1 || C2\n</code></pre> <p>Se a string for nula ou estiver vazia, retorna false</p>"},{"location":"aae3/aae3/#tabela-verdade-de-c1-c2","title":"Tabela-verdade de <code>C1 || C2</code>","text":"Caso C1 C2 Resultado D1-T1 F F F D1-T2 F V V D1-T3 V F V D1-T4 V V V"},{"location":"aae3/aae3/#pares-mcdc","title":"Pares MC/DC","text":"<ul> <li>C1: (C2 = F; C1 muda F \u2192 V; resultado muda F \u2192 V) \u2014 D1-T1 vs D1-T3</li> <li>C2: (C1 = F; C2 muda F \u2192 V; resultado muda F \u2192 V) \u2014 D1-T1 vs D1-T2</li> </ul>"},{"location":"aae3/aae3/#3-segunda-decisao-linha-5","title":"3. Segunda decis\u00e3o (linha 5)","text":"<pre><code>if (number.length() == 1 &amp;&amp; (number.charAt(0) == '-' || number.charAt(0) == '+')) {\n    return false;\n}\n</code></pre> <ul> <li>C3: <code>number.length() == 1</code></li> <li>C4: <code>number.charAt(0) == '-'</code></li> <li>C5: <code>number.charAt(0) == '+'</code></li> </ul>"},{"location":"aae3/aae3/#estrutura-logica_1","title":"Estrutura l\u00f3gica","text":"<pre><code>C3 &amp;&amp; (C4 || C5)\n</code></pre> <p>Se h\u00e1 um caractere e ele \u00e9 \u2018-\u2019 ou \u2018+\u2019, retorna false</p>"},{"location":"aae3/aae3/#tabela-verdade-de-c3-c4-c5","title":"Tabela-verdade de <code>C3 &amp;&amp; (C4 || C5)</code>","text":"Caso C3 C4 C5 Resultado D2-T1 V V F V D2-T2 V F V V D2-T3 V F F F D2-T4 F \u2013 \u2013 F"},{"location":"aae3/aae3/#pares-mcdc_1","title":"Pares MC/DC","text":"<ul> <li>C3: (C4 = V; C5 = F; C3 muda V \u2192 F; resultado muda V \u2192 F) \u2014 D2-T1 vs D2-T4</li> <li>C4: (C3 = V; C5 = F; C4 muda V \u2192 F; resultado muda V \u2192 F) \u2014 D2-T1 vs D2-T3</li> <li>C5: (C3 = V; C4 = F; C5 muda V \u2192 F; resultado muda V \u2192 F) \u2014 D2-T2 vs D2-T3</li> </ul>"},{"location":"aae3/aae3/#4-terceira-decisao-linha-10","title":"4. Terceira decis\u00e3o (linha 10)","text":"<pre><code>if (i == 0 &amp;&amp; (c == '-' || c == '+')) {\n    continue;\n}\n</code></pre> <ul> <li>C6: <code>i == 0</code></li> <li>C7: <code>c == '-'</code></li> <li>C8: <code>c == '+'</code></li> </ul>"},{"location":"aae3/aae3/#estrutura-logica_2","title":"Estrutura l\u00f3gica","text":"<pre><code>C6 &amp;&amp; (C7 || C8)\n</code></pre> <p>Se \u00e9 o primeiro caractere e ele \u00e9 \u2018-\u2019 ou \u2018+\u2019, ignora e segue</p>"},{"location":"aae3/aae3/#tabela-verdade-de-c6-c7-c8","title":"Tabela-verdade de <code>C6 &amp;&amp; (C7 || C8)</code>","text":"Caso C6 C7 C8 Resultado D3-T1 F \u2013 \u2013 F D3-T2 V V F V D3-T3 V F V V D3-T4 V F F F"},{"location":"aae3/aae3/#pares-mcdc_2","title":"Pares MC/DC","text":"<ul> <li>C6: (C7 = V; C8 = F; C6 muda F \u2192 V; resultado muda F \u2192 V) \u2014 D3-T1 vs D3-T2</li> <li>C7: (C6 = V; C8 = F; C7 muda V \u2192 F; resultado muda V \u2192 F) \u2014 D3-T2 vs D3-T4</li> <li>C8: (C6 = V; C7 = F; C8 muda V \u2192 F; resultado muda V \u2192 F) \u2014 D3-T3 vs D3-T4</li> </ul>"},{"location":"aae3/aae3/#5-resumo-dos-pares-mcdc","title":"5. Resumo dos pares MC/DC","text":"<ul> <li>Decis\u00e3o 1 (C1, C2): D1-T1 vs D1-T3; D1-T1 vs D1-T2</li> <li>Decis\u00e3o 2 (C3, C4, C5): D2-T1 vs D2-T4; D2-T1 vs D2-T3; D2-T2 vs D2-T3</li> <li>Decis\u00e3o 3 (C6, C7, C8): D3-T1 vs D3-T2; D3-T2 vs D3-T4; D3-T3 vs D3-T4</li> </ul>"},{"location":"aae3/aae3/#6-conclusao","title":"6. Conclus\u00e3o","text":"<p>Com o conjunto de 12 casos de teste (D1-T1 a D1-T4, D2-T1 a D2-T4 e D3-T1 a D3-T4), cada condi\u00e7\u00e3o C1\u2013C8 foi avaliada como verdadeira e falsa e demonstrou, isoladamente, sua capacidade de alterar o resultado da decis\u00e3o. Assim, alcan\u00e7amos 100% de cobertura segundo o crit\u00e9rio MC/DC para o m\u00e9todo <code>isNumber</code>.</p>"},{"location":"aae3/aae3/#7-referencias-bibliograficas","title":"7. Refer\u00eancias Bibliogr\u00e1ficas","text":"<ol> <li>Myers, G. J., Sandler, C., &amp; Badgett, T. (2011). The Art of Software Testing (3rd ed.). Wiley. pp. 46\u201348.</li> <li>RTCA/DO-178C. (2011). Software Considerations in Airborne Systems and Equipment Certification. RTCA.</li> <li>ISO/IEC/IEEE 29119. (2013). Software and Systems Engineering \u2014 Software Testing. ISO/IEC/IEEE.</li> </ol>"},{"location":"aae3/mc_dc/","title":"Modified Condition/Decision Coverage (MC/DC)","text":"<p>O Modified Condition/Decision Coverage (MC/DC) \u00e9 um dos crit\u00e9rios de cobertura estrutural mais exigentes para software de alta criticidade (por exemplo: avia\u00e7\u00e3o, automotivo, ferrovi\u00e1rio, etc.). O MC/DC est\u00e1 definido na norma DO-178B/C da FAA e \u00e9 referenciado em normas como ISO 26262 (automotiva) e IEC 61508 (industrial). Uma apresenta\u00e7\u00e3o detalhada pode ser encontrada em Hayhurst et al. (2001).</p> <p>Veja uma explica\u00e7\u00e3o pr\u00e1tica e visual no v\u00eddeo a seguir:</p>"},{"location":"aae3/mc_dc/#1-definicao-formal","title":"1. Defini\u00e7\u00e3o Formal","text":"<p>De acordo com o DO-178C </p> <p>O MC/DC requer que, para cada decis\u00e3o (uma express\u00e3o booleana composta) no c\u00f3digo, sejam atendidos simultaneamente:</p> <ol> <li>Cada ponto de entrada e sa\u00edda seja invocado ao menos uma vez.</li> <li>A decis\u00e3o tome cada um de seus poss\u00edveis resultados (verdadeiro/falso).</li> <li>Cada condi\u00e7\u00e3o atinja cada valor (verdadeiro/falso) ao menos uma vez.</li> <li>Cada condi\u00e7\u00e3o seja mostrada como tendo influ\u00eancia independente sobre o resultado da decis\u00e3o, mudando-a quando somente ela for invertida, mantendo-se fixas todas as demais.</li> </ol> <p>O item 4 \u00e9 o que diferencia o MC/DC: deve-se provar que apenas invertendo uma condi\u00e7\u00e3o \u2014 sem alterar as demais \u2014 o resultado da decis\u00e3o tamb\u00e9m inverte.</p>"},{"location":"aae3/mc_dc/#2-exemplo-pratico","title":"2. Exemplo Pr\u00e1tico","text":"<p>Considere a decis\u00e3o:</p> <pre><code>D = A &amp;&amp; B &amp;&amp; C\n</code></pre> Caso A B C D = A\u2227B\u2227C 1 True True True True 2 True True False False 3 True False True False 4 True False False False 5 False True True False 6 False True False False 7 False False True False 8 False False False False <p>Para atingir 100\u202f% de MC/DC, al\u00e9m de cobrir as condi\u00e7\u00f5es e decis\u00f5es, precisamos demonstrar a independ\u00eancia de cada condi\u00e7\u00e3o.</p>"},{"location":"aae3/mc_dc/#21-independencia-de-a","title":"2.1. Independ\u00eancia de A","text":"<p>Mant\u00e9m B = True e C = True, varia apenas A:</p> Caso A B C D = A\u2227B\u2227C 1 True True True True 5 False True True False"},{"location":"aae3/mc_dc/#22-independencia-de-b","title":"2.2. Independ\u00eancia de B","text":"<p>Mant\u00e9m A = True e C = True, varia apenas B:</p> Caso A B C D = A\u2227B\u2227C 1 True True True True 3 True False True False"},{"location":"aae3/mc_dc/#23-independencia-de-c","title":"2.3. Independ\u00eancia de C","text":"<p>Mant\u00e9m A = True e B = True, varia apenas C:</p> Caso A B C D = A\u2227B\u2227C 1 True True True True 2 True True False False"},{"location":"aae3/mc_dc/#3-vantagens-e-aplicacoes","title":"3. Vantagens e Aplica\u00e7\u00f5es","text":"<ul> <li>Redu\u00e7\u00e3o de riscos: garante que cada condi\u00e7\u00e3o individualmente impacta o resultado, revelando erros mascarados.</li> <li>Requisito normativo: n\u00edvel A em avia\u00e7\u00e3o exige 100\u202f% MC/DC (DO-178C, Tabela A-7); tamb\u00e9m recomendado para SIL\u202f4 (IEC\u00a061508) e ASIL\u202fD (ISO\u00a026262).</li> <li>Efici\u00eancia: exige menos testes que a cobertura de todas as combina\u00e7\u00f5es (Multiple Condition Coverage), mantendo rigor.</li> </ul>"},{"location":"aae3/mc_dc/#4-referencias-bibliograficas","title":"4. Refer\u00eancias Bibliogr\u00e1ficas","text":"<ol> <li>Kelly\u00a0J. Hayhurst, Dan\u00a0S. Veerhusen, John\u00a0D. Chilenski e Leanna\u00a0R. Rierson. A Practical Tutorial on Modified Condition/Decision Coverage, NASA TM-2001-210876, 2001.</li> <li>FAA. Guidelines for the Use of the Modified Condition/Decision Coverage (MC/DC) Criterion, CAST-10, 2020.</li> <li>RTCA/DO-178C. Software Considerations in Airborne Systems and Equipment Certification, 2011.</li> <li>ISO\u00a026262:2011. Road vehicles \u2013 Functional safety, Parte\u00a06.</li> <li>IEC\u00a061508-3:2010. Functional safety of electrical/electronic/programmable electronic safety-related systems, Anexo\u00a0B.</li> <li>Myers, G. J., Sandler, C., &amp; Badgett, T. (2011). The Art of Software Testing (3rd ed.). Wiley. pp. 46\u201348.</li> </ol>"},{"location":"aae3/unit_test/","title":"Teste de Unidade","text":""},{"location":"aae3/unit_test/#3-piramide-de-testes","title":"3. Pir\u00e2mide de Testes","text":"<p>A Pir\u00e2mide de Testes ilustra como equilibrar velocidade, custo e cobertura ao estruturar sua su\u00edte de testes (Meszaros, 2007):</p> <p></p> N\u00edvel Quantidade de Testes Custo por Teste Velocidade de Execu\u00e7\u00e3o Exemplos de Ferramentas Aceita\u00e7\u00e3o Baixa Alto Muito Lenta Cucumber, Robot Framework Sistema M\u00e9dia M\u00e9dio Lenta Selenium, TestComplete Integra\u00e7\u00e3o M\u00e9dia\u2013Alta Baixo\u2013M\u00e9dio Moderada Pytest + Docker Compose, Postman Unidade Alta Baixo Muito R\u00e1pida pytest, unittest, Jest <ul> <li>Unidade (base) </li> <li>O que: Testes de fun\u00e7\u00e3o/m\u00e9todo isolado.  </li> <li>Por que: R\u00e1pidos e baratos; detectam defeitos de l\u00f3gica interna antes de integrar depend\u00eancias.  </li> <li>Integra\u00e7\u00e3o (camada intermedi\u00e1ria) </li> <li>O que: Testes de m\u00faltiplos m\u00f3dulos funcionando juntos (por exemplo, servi\u00e7o + banco de dados).  </li> <li>Por que: Verifica contratos/interfaces, detecta erros de comunica\u00e7\u00e3o e configura\u00e7\u00e3o.  </li> <li>Sistema (\u00faltima camada antes da aceita\u00e7\u00e3o) </li> <li>O que: Testes fim-a-fim que exercitam todo o sistema em ambiente real ou simulado.  </li> <li>Por que: Confirma fluxo completo (UI \u2192 backend \u2192 DB), mas custa mais manter.  </li> <li>Aceita\u00e7\u00e3o (topo) </li> <li>O que: Valida\u00e7\u00e3o contra requisitos de neg\u00f3cio por meio de cen\u00e1rios escritos em linguagem natural.  </li> <li>Por que: Garante que o software atenda \u00e0s expectativas do usu\u00e1rio, mas demora para rodar.</li> </ul> <p>Eixos - Velocidade: decresce de unidades \u2192 aceita\u00e7\u00e3o. - Custo: cresce de unidades \u2192 aceita\u00e7\u00e3o. - Quantidade: cresce de aceita\u00e7\u00e3o \u2192 unidades.</p>"},{"location":"aae3/unit_test/#4-outros-formatos-de-estrategia","title":"4. Outros Formatos de Estrat\u00e9gia","text":""},{"location":"aae3/unit_test/#a-the-testing-trophy","title":"A. The Testing Trophy","text":"<p>Desenvolvida por Kent C. Dodds para aplica\u00e7\u00f5es web modernas:</p> <p></p> <ul> <li>Static: detec\u00e7\u00e3o de erros sem execu\u00e7\u00e3o (ESLint, mypy).  </li> <li>Unit: l\u00f3gica interna (Jest, pytest).  </li> <li>Integration: contratos entre m\u00f3dulos (Testing Library, pytest-docker).  </li> <li>End to End: simula\u00e7\u00e3o completa de usu\u00e1rio (Cypress, Playwright).   <p>Meta: Keep static and unit tests em larga quantidade, reduzindo gradualmente at\u00e9 E2E (Dodds, 2020).</p> </li> </ul>"},{"location":"aae3/unit_test/#b-microservices-test-strategy","title":"B. Microservices Test Strategy","text":"<p>Abordagem do Spotify Labs para arquiteturas de microsservi\u00e7os:</p> <ol> <li>Implementation Detail: validar l\u00f3gica isolada de cada servi\u00e7o (testes de unidade profundas).  </li> <li>Integration: testar comunica\u00e7\u00e3o entre pares de servi\u00e7os (contratos de API).  </li> <li>Integrated: executar conjunto completo de microsservi\u00e7os simulando produ\u00e7\u00e3o (fluxos end-to-end).   <p>Recomenda\u00e7\u00e3o: minimizar testes de detalhe interno, focar em Integration e Integrated (Spotify Labs, 2019).</p> </li> </ol>"},{"location":"aae3/unit_test/#5-niveis-de-teste-beneficios","title":"5. N\u00edveis de Teste \u2013 Benef\u00edcios","text":"<ol> <li>Evita redund\u00e2ncia </li> <li>Cada n\u00edvel foca em diferentes categorias de defeitos (Myers et al., 2012).  </li> <li>Custo x Risco </li> <li>Detectar cedo (unidade) corrige barato; detectar tarde (aceita\u00e7\u00e3o) corrige caro.  </li> <li>Escalabilidade </li> <li>Pequenos projetos podem parar em integra\u00e7\u00e3o; projetos cr\u00edticos devem chegar \u00e0 aceita\u00e7\u00e3o.  </li> </ol>"},{"location":"aae3/unit_test/#6-niveis-de-teste-consideracoes","title":"6. N\u00edveis de Teste \u2013 Considera\u00e7\u00f5es","text":"<ul> <li>N\u00e3o s\u00e3o sequenciais: escolha n\u00edveis conforme risco, or\u00e7amento e complexidade do projeto.  </li> <li>Fatores a influenciar a estrat\u00e9gia: </li> <li>Grau de acoplamento e coes\u00e3o do sistema.  </li> <li>Frequ\u00eancia de mudan\u00e7as nos componentes.  </li> <li>Recursos de infraestrutura (tempo de build, ambientes de teste).  </li> </ul>"},{"location":"aae3/unit_test/#7-diagrama-de-correspondencia-de-niveis","title":"7. Diagrama de Correspond\u00eancia de N\u00edveis","text":""},{"location":"aae3/unit_test/#8-lista-de-niveis-de-teste","title":"8. Lista de N\u00edveis de Teste","text":"<ol> <li>Unidade \u2013 testar o menor bloco de c\u00f3digo isoladamente.  </li> <li>Integra\u00e7\u00e3o \u2013 validar a intera\u00e7\u00e3o entre m\u00f3dulos.  </li> <li>Fun\u00e7\u00e3o \u2013 foco em funcionalidades discretas, similar a testes de sistema menores.  </li> <li>Sistema \u2013 testes de ponta a ponta num ambiente completo.  </li> <li>Aceita\u00e7\u00e3o \u2013 valida\u00e7\u00e3o contra crit\u00e9rios de aceite do cliente.</li> </ol>"},{"location":"aae3/unit_test/#9-testes-de-unidade","title":"9. Testes de Unidade","text":"<p>Defini\u00e7\u00e3o (Myers, 2012): Processo de testar fun\u00e7\u00f5es, m\u00e9todos, procedimentos, sub-rotinas ou subprogramas individualmente, garantindo que cada unidade isolada se comporte conforme a especifica\u00e7\u00e3o.</p> <ul> <li>Objetivo: verificar o menor elemento test\u00e1vel de um software.  </li> <li>Procedural: fun\u00e7\u00e3o ou procedimento.  </li> <li>Orientado a objeto: m\u00e9todo de classe.  </li> <li>Respons\u00e1vel: geralmente o desenvolvedor.  </li> <li>Enfoque: algoritmos e l\u00f3gica de programa\u00e7\u00e3o.  </li> <li>T\u00e9cnicas: tipicamente caixa-branca, complementada por caixa-preta.</li> </ul> <p>Motiva\u00e7\u00f5es: - Gerenciar incrementalmente os elementos do teste. - Facilitar a depura\u00e7\u00e3o (localiza\u00e7\u00e3o de defeitos). - Permitir paralelismo na execu\u00e7\u00e3o dos testes.</p>"},{"location":"aae3/unit_test/#91-ferramentas-em-python","title":"9.1. Ferramentas em Python","text":"Ferramenta Caracter\u00edsticas Refer\u00eancia <code>unittest</code> Framework padr\u00e3o, estilo xUnit. Python Software Foundation (2024). <code>pytest</code> Sintaxe concisa, fixtures, parametriza\u00e7\u00e3o e plugins. pytest Documentation (2024). <code>coverage.py</code> Medi\u00e7\u00e3o de cobertura de c\u00f3digo. Ned Batchelder (2024)."},{"location":"aae3/unit_test/#92-exemplo-simples-funcao-is_even","title":"9.2. Exemplo Simples: Fun\u00e7\u00e3o <code>is_even</code>","text":"<pre><code># utils.py\ndef is_even(n: int) -&gt; bool:\n    \"\"\"\n    Retorna True se n for par, False caso contr\u00e1rio.\n    \"\"\"\n    return n % 2 == 0\n</code></pre>"},{"location":"aae3/unit_test/#921-testes-com-pytest","title":"9.2.1. Testes com <code>pytest</code>","text":"<pre><code># tests/test_utils.py\nimport pytest\nfrom utils import is_even\n\n@pytest.mark.parametrize(\"input,expected\", [\n    (0, True),\n    (1, False),\n    (2, True),\n    (99, False),\n])\ndef test_is_even(input, expected):\n    assert is_even(input) == expected\n</code></pre> <ul> <li>Casos de teste:</li> <li><code>0</code> \u2192 <code>True</code></li> <li><code>1</code> \u2192 <code>False</code></li> <li><code>2</code> \u2192 <code>True</code></li> <li><code>99</code> \u2192 <code>False</code></li> </ul>"},{"location":"aae3/unit_test/#922-teste-caixa-branca-cobertura-de-decisao","title":"9.2.2. Teste Caixa-Branca (Cobertura de Decis\u00e3o)","text":"<pre><code>def test_is_even_branches():\n    # testa tanto o ramo True quanto o ramo False\n    assert is_even(4) is True\n    assert is_even(5) is False\n</code></pre> <ul> <li>Com isso garantimos que ambas as sa\u00eddas (<code>True</code> e <code>False</code>) ocorram ao menos uma vez.</li> </ul>"},{"location":"aae3/unit_test/#93-criterios-de-cobertura","title":"9.3. Crit\u00e9rios de Cobertura","text":"Crit\u00e9rio Descri\u00e7\u00e3o Cobertura de decis\u00f5es Garante que <code>n % 2 == 0</code> avalie <code>True</code> e <code>False</code> Cobertura de instru\u00e7\u00f5es Garante execu\u00e7\u00e3o da \u00fanica linha da fun\u00e7\u00e3o <pre><code># Gerando relat\u00f3rio de cobertura\ncoverage run -m pytest &amp;&amp; coverage report -m\n</code></pre> <pre><code>Name           Stmts   Miss  Cover\n----------------------------------\nutils.py           3      0   100%\n</code></pre>"},{"location":"aae3/unit_test/#12-referencias-bibliograficas","title":"12. Refer\u00eancias Bibliogr\u00e1ficas","text":"<ul> <li>Myers, G. J., Sandler, C., &amp; Badgett, T. (2012). The Art of Software Testing. John Wiley &amp; Sons.  </li> <li>pytest Development Team. (2024). pytest documentation. Retrieved from https://docs.pytest.org/  </li> <li>Ned Batchelder. (2024). coverage.py documentation. Retrieved from https://coverage.readthedocs.io/  </li> <li>Meszaros, G. (2007). xUnit Test Patterns: Refactoring Test Code. Addison-Wesley.  </li> <li>Dodds, K. C. (2020). The Testing Trophy.  </li> <li>Spotify Labs. (2019). Microservices Test Strategy</li> </ul>"},{"location":"aae3/white_box_test/","title":"Cap\u00edtulo 4 \u2013  Teste de Caixa Branca","text":"<p>Outra estrat\u00e9gia de teste, o teste de caixa branca (ou orientado por l\u00f3gica), permite que voc\u00ea examine a estrutura interna do programa. Essa estrat\u00e9gia deriva dados de teste de um exame da l\u00f3gica do programa (e muitas vezes, infelizmente, negligenciando a especifica\u00e7\u00e3o).</p> <p>O objetivo neste ponto \u00e9 estabelecer, para esta estrat\u00e9gia, o teste de entrada an\u00e1logo ao exaustivo na abordagem de caixa preta. Fazer com que todas as instru\u00e7\u00f5es do programa sejam executadas pelo menos uma vez pode parecer ser a resposta, mas n\u00e3o \u00e9 dif\u00edcil mostrar que isso \u00e9 altamente inadequado. Sem insistir no ponto aqui, uma vez que esse assunto \u00e9 discutido com mais profundidade no Cap\u00edtulo 4, o an\u00e1logo geralmente \u00e9 considerado um teste de caminho exaustivo. Ou seja, se voc\u00ea executar, via casos de teste, todos os caminhos poss\u00edveis de controle fluem pelo programa, ent\u00e3o, possivelmente, o programa foi completamente testado.</p> <p>Existem duas falhas nesta afirma\u00e7\u00e3o, no entanto. Uma \u00e9 que o n\u00famero de caminhos l\u00f3gicos \u00fanicos atrav\u00e9s de um programa pode ser astronomicamente grande. Para ver isso, considere o programa trivial representado na Figura 2.1. O diagrama \u00e9 um gr\u00e1fico de fluxo de controle. Cada n\u00f3 ou c\u00edrculo representa um segmento de instru\u00e7\u00f5es que s\u00e3o executadas sequencialmente, possivelmente terminando com uma branching statement. Cada aresta ou arco representa uma transfer\u00eancia de controle (ramifica\u00e7\u00e3o) entre segmentos. O diagrama, ent\u00e3o, descreve um programa de 10 a 20 instru\u00e7\u00f5es que consiste em um loop DO que itera at\u00e9 20 vezes. Dentro do corpo do loop DO, h\u00e1 um conjunto de instru\u00e7\u00f5es IF aninhadas. Determinar o n\u00famero de caminhos l\u00f3gicos \u00fanicos \u00e9 o mesmo que determinar o n\u00famero total de maneiras \u00fanicas de se mover do ponto A para o ponto B (assumindo que todas as decis\u00f5es no programa s\u00e3o independentes umas das outras). Este n\u00famero \u00e9 aproximadamente 10\u00b9\u2074.</p> <p>FIGURA 2.1: Gr\u00e1fico de fluxo de controle de um pequeno programa.</p> <p>100 trilh\u00f5es. \u00c9 calculado a partir de 5\u00b2\u2070 + 5\u00b9\u2079 + ... + 5\u00b9, onde 5 \u00e9 o n\u00famero de caminhos atrav\u00e9s do corpo do loop. A maioria das pessoas tem dificuldade em visualizar esse n\u00famero, ent\u00e3o considere desta forma: se voc\u00ea pudesse escrever, executar e verificar um caso de teste a cada cinco minutos, levaria aproximadamente 1 bilh\u00e3o de anos para tentar todos os caminhos. Se voc\u00ea fosse 300 vezes mais r\u00e1pido, completando um teste uma vez por segundo, voc\u00ea poderia completar o trabalho em 3,2 milh\u00f5es de anos, dar ou tirar alguns anos bissextos e s\u00e9culos.</p> <p>\u00c9 claro que, em programas reais, todas as decis\u00f5es n\u00e3o s\u00e3o independentes de todas as outras decis\u00f5es, o que significa que o n\u00famero de caminhos de execu\u00e7\u00e3o poss\u00edveis seria um pouco menor. Por outro lado, os programas reais s\u00e3o muito maiores do que o programa simples representado na Figura 2.1. Portanto, testes exaustivos de caminho, como testes exaustivos de entrada, parecem ser impratic\u00e1veis, se n\u00e3o imposs\u00edveis.</p> <p>A segunda falha na afirma\u00e7\u00e3o \"teste de caminho exaustivo significa um teste completo\" \u00e9 que todos os caminhos em um programa podem ser testados, mas o programa ainda pode estar carregado de erros. Existem tr\u00eas explica\u00e7\u00f5es para isso.</p> <p>A primeira \u00e9 que um teste exaustivo de trajet\u00f3ria n\u00e3o garante, de forma alguma, que um programa corresponda \u00e0 sua especifica\u00e7\u00e3o. Por exemplo, se voc\u00ea fosse solicitado a escrever uma rotina de classifica\u00e7\u00e3o em ordem crescente, mas produzisse por engano uma rotina de classifica\u00e7\u00e3o em ordem decrescente, o teste de caminho exaustivo seria de pouco valor; o programa ainda tem um bug: \u00e9 o programa errado, pois n\u00e3o atende \u00e0 especifica\u00e7\u00e3o.</p> <p>Em segundo lugar, um programa pode estar incorreto devido a caminhos ausentes. O teste exaustivo de caminho, \u00e9 claro, n\u00e3o detectaria a aus\u00eancia de caminhos necess\u00e1rios.</p> <p>Terceiro, um teste de caminho exaustivo pode n\u00e3o revelar erros de confidencialidade de dados. Existem muitos exemplos de tais erros, mas um simples deve ser suficiente. Suponha que, em um programa, voc\u00ea tenha que comparar dois n\u00fameros para converg\u00eancia, isto \u00e9, para ver se a diferen\u00e7a entre os dois n\u00fameros \u00e9 menor do que algum valor predeterminado. Por exemplo, voc\u00ea pode escrever uma instru\u00e7\u00e3o Java IF como:</p> <pre><code>if (a - b &lt; c)\n    System.out.println(\"a - b &lt; c\");\n</code></pre> <p>Claro, a declara\u00e7\u00e3o cont\u00e9m um erro porque deveria comparar <code>c</code> com o valor absoluto de <code>a - b</code>. A detec\u00e7\u00e3o desse erro, no entanto, depende dos valores usados para <code>a</code> e <code>b</code>, e n\u00e3o seria necessariamente detectada apenas executando todos os caminhos do programa.</p> <p>Em conclus\u00e3o, embora o teste exaustivo de entrada seja superior ao teste de caminho exaustivo, nenhum deles se mostra \u00fatil porque ambos s\u00e3o invi\u00e1veis. Talvez, ent\u00e3o, existam maneiras de combinar elementos de teste de caixa preta e caixa branca para derivar uma estrat\u00e9gia de teste razo\u00e1vel, mas n\u00e3o herm\u00e9tica. Este assunto \u00e9 aprofundado no Cap\u00edtulo 4.</p>"},{"location":"aae3/white_box_test/#principios-de-teste-de-software","title":"Princ\u00edpios de teste de software","text":""},{"location":"aae3/white_box_test/#tabela-21-diretrizes-de-teste-de-programas","title":"Tabela 2.1 \u2013 Diretrizes de teste de programas","text":"N\u00ba Princ\u00edpio 1 Uma parte necess\u00e1ria de um caso de teste \u00e9 uma defini\u00e7\u00e3o da sa\u00edda ou resultado esperado. 2 Um programador deve evitar tentar testar seu pr\u00f3prio programa. 3 Uma organiza\u00e7\u00e3o de programa\u00e7\u00e3o n\u00e3o deve testar seus pr\u00f3prios programas. 4 Qualquer processo de teste deve incluir uma inspe\u00e7\u00e3o completa dos resultados de cada teste. 5 Os casos de teste devem ser gravados para condi\u00e7\u00f5es de entrada inv\u00e1lidas e inesperadas, bem como para aquelas que s\u00e3o v\u00e1lidas e esperadas. 6 Examinar um programa para ver se ele n\u00e3o faz o que deveria fazer \u00e9 apenas metade da batalha; a outra metade \u00e9 ver se o programa faz o que n\u00e3o deveria fazer. 7 Evite casos de teste descart\u00e1veis, a menos que o programa seja realmente um programa descart\u00e1vel. 8 N\u00e3o planeje um esfor\u00e7o de teste sob a suposi\u00e7\u00e3o t\u00e1cita de que nenhum erro ser\u00e1 encontrado. 9 A probabilidade da exist\u00eancia de mais erros em uma se\u00e7\u00e3o de um programa \u00e9 proporcional ao n\u00famero de erros j\u00e1 encontrados nessa se\u00e7\u00e3o. 10 O teste \u00e9 uma tarefa extremamente criativa e intelectualmente desafiadora. <p>Continuando com a premissa principal deste cap\u00edtulo, de que as considera\u00e7\u00f5es mais importantes no teste de software s\u00e3o quest\u00f5es de psicologia, podemos identificar um conjunto de princ\u00edpios ou diretrizes vitais de teste. A maioria desses princ\u00edpios pode parecer \u00f3bvia, mas muitas vezes s\u00e3o negligenciados. A Tabela 2.1 resume esses princ\u00edpios importantes, e cada um \u00e9 discutido com mais detalhes nos par\u00e1grafos a seguir.</p>"},{"location":"aae3/white_box_test/#principio-1","title":"Princ\u00edpio 1","text":"<p>Uma parte necess\u00e1ria de um caso de teste \u00e9 uma defini\u00e7\u00e3o da sa\u00edda ou resultado esperado. Este princ\u00edpio, embora \u00f3bvio, quando negligenciado, \u00e9 a causa de um dos erros mais frequentes no teste de programas. Novamente, \u00e9 algo baseado na psicologia humana. Se o resultado esperado de um caso de teste n\u00e3o foi predefinido, \u00e9 prov\u00e1vel que um resultado plaus\u00edvel, mas err\u00f4neo, seja interpretado como um resultado correto por causa do fen\u00f4meno de \"o olho ver o que quer ver\". Em outras palavras, apesar da defini\u00e7\u00e3o destrutiva adequada de teste, ainda h\u00e1 um desejo subconsciente de ver o resultado correto.</p> <p>Uma maneira de lutar contra essa situa\u00e7\u00e3o consiste em incentivar uma an\u00e1lise pormenorizada de toda a produ\u00e7\u00e3o, especificando com precis\u00e3o, antecipadamente, a produ\u00e7\u00e3o esperada do programa. Portanto, um caso de teste deve consistir em dois componentes:</p> <ol> <li>Uma descri\u00e7\u00e3o dos dados de entrada para o programa.</li> <li>Uma descri\u00e7\u00e3o precisa da sa\u00edda correta do programa para esse conjunto de dados de entrada.</li> </ol> <p>Um problema pode ser caracterizado como um fato ou grupo de fatos para os quais n\u00e3o temos uma explica\u00e7\u00e3o aceit\u00e1vel, que parecem incomuns ou que n\u00e3o se encaixam em nossas expectativas ou preconceitos. Deve ser \u00f3bvio que algumas cren\u00e7as pr\u00e9vias s\u00e3o necess\u00e1rias para que algo pare\u00e7a problem\u00e1tico. Se n\u00e3o houver expectativas, n\u00e3o pode haver surpresas.</p>"},{"location":"aae3/white_box_test/#principio-2","title":"Princ\u00edpio 2","text":"<p>Um programador deve evitar tentar testar seu pr\u00f3prio programa. Qualquer escritor sabe \u2014 ou deveria saber \u2014 que \u00e9 uma m\u00e1 ideia tentar editar ou revisar seu pr\u00f3prio trabalho. Eles sabem o que a pe\u00e7a deve dizer, portanto, podem n\u00e3o reconhecer quando diz o contr\u00e1rio. E eles realmente n\u00e3o querem encontrar erros em seu pr\u00f3prio trabalho. O mesmo se aplica aos autores de software.</p> <p>Outro problema surge com uma mudan\u00e7a de foco em um projeto de software. Depois que um programador projetou e codificou construtivamente um programa, \u00e9 extremamente dif\u00edcil mudar repentinamente a perspectiva para olhar para o programa com um olhar destrutivo.</p> <p>Como muitos propriet\u00e1rios sabem, remover o papel de parede (um processo destrutivo) n\u00e3o \u00e9 f\u00e1cil, mas \u00e9 quase insuportavelmente deprimente se foram suas m\u00e3os que penduraram o papel em primeiro lugar. Da mesma forma, a maioria dos programadores n\u00e3o pode testar efetivamente seus pr\u00f3prios programas porque n\u00e3o consegue mudar as engrenagens mentais para tentar expor erros. Al\u00e9m disso, um programador pode inconscientemente evitar encontrar erros por medo de retalia\u00e7\u00e3o de colegas, de um supervisor, de um cliente ou do propriet\u00e1rio do programa ou sistema que est\u00e1 sendo desenvolvido.</p> <p>Al\u00e9m dessas quest\u00f5es psicol\u00f3gicas, h\u00e1 um segundo problema significativo: o programa pode conter erros devido ao mal-entendido do programador sobre a declara\u00e7\u00e3o ou especifica\u00e7\u00e3o do problema. Se for esse o caso, \u00e9 prov\u00e1vel que o programador leve o mesmo mal-entendido para os testes de seu pr\u00f3prio programa.</p> <p>Isso n\u00e3o significa que seja imposs\u00edvel para um programador testar seu pr\u00f3prio programa. Em vez disso, implica que o teste \u00e9 mais eficaz e bem-sucedido se outra pessoa o fizer. No entanto, como vamos discutir em mais detalhes no Cap\u00edtulo 3, os desenvolvedores podem ser membros valiosos da equipe de teste quando a especifica\u00e7\u00e3o do programa e o pr\u00f3prio c\u00f3digo do programa est\u00e3o sendo avaliados.</p> <p>Observe que esse argumento n\u00e3o se aplica \u00e0 depura\u00e7\u00e3o (corrigir erros conhecidos); a depura\u00e7\u00e3o \u00e9 executada com mais efici\u00eancia pelo programador original.</p>"},{"location":"aae3/white_box_test/#principio-3","title":"Princ\u00edpio 3","text":"<p>Uma organiza\u00e7\u00e3o de programa\u00e7\u00e3o n\u00e3o deve testar seus pr\u00f3prios programas. O argumento aqui \u00e9 semelhante ao feito no princ\u00edpio anterior. Uma organiza\u00e7\u00e3o de projeto ou programa\u00e7\u00e3o \u00e9, em muitos sentidos, uma organiza\u00e7\u00e3o viva com problemas psicol\u00f3gicos semelhantes aos de programadores individuais. Al\u00e9m disso, na maioria dos ambientes, uma organiza\u00e7\u00e3o de programas ou um gerente de projeto \u00e9 amplamente medido pela capacidade de produzir um programa em uma determinada data e por um determinado custo.</p> <p>Uma raz\u00e3o para isso \u00e9 que \u00e9 f\u00e1cil medir os objetivos de tempo e custo, enquanto \u00e9 extremamente dif\u00edcil quantificar a confiabilidade de um programa. Portanto, \u00e9 dif\u00edcil para uma organiza\u00e7\u00e3o de programa\u00e7\u00e3o ser objetiva ao testar seus pr\u00f3prios programas, porque o processo de teste, se abordado com a defini\u00e7\u00e3o adequada, pode ser visto como diminuindo a probabilidade de atingir o cronograma e os objetivos de custo.</p> <p>Novamente, isso n\u00e3o significa que seja imposs\u00edvel para uma organiza\u00e7\u00e3o de programa\u00e7\u00e3o encontrar alguns de seus erros, porque as organiza\u00e7\u00f5es realizam isso com algum grau de sucesso. Em vez disso, implica que \u00e9 mais econ\u00f4mico que os testes sejam realizados por uma parte objetiva e independente.</p>"},{"location":"aae3/white_box_test/#principio-4","title":"Princ\u00edpio 4","text":"<p>Qualquer processo de teste deve incluir uma inspe\u00e7\u00e3o completa dos resultados de cada teste. Este \u00e9 provavelmente o princ\u00edpio mais \u00f3bvio, mas, novamente, \u00e9 algo que muitas vezes \u00e9 esquecido. Vimos v\u00e1rios experimentos que mostram que muitos sujeitos falharam em detectar certos erros, mesmo quando os sintomas desses erros eram claramente observ\u00e1veis nas listas de sa\u00edda. Dito de outra forma, os erros encontrados em testes posteriores foram frequentemente perdidos nos resultados de testes anteriores.</p>"},{"location":"aae3/white_box_test/#principio-5","title":"Princ\u00edpio 5","text":"<p>Os casos de teste devem ser escritos para condi\u00e7\u00f5es de entrada inv\u00e1lidas e inesperadas, bem como para aquelas que s\u00e3o v\u00e1lidas e esperadas. H\u00e1 uma tend\u00eancia natural, ao testar um programa, de se concentrar nas condi\u00e7\u00f5es de entrada v\u00e1lidas e esperadas, negligenciando as condi\u00e7\u00f5es inv\u00e1lidas e inesperadas.</p> <p>Por exemplo, essa tend\u00eancia aparece frequentemente no teste do programa do tri\u00e2ngulo no Cap\u00edtulo 1. Poucas pessoas, por exemplo, alimentam o programa com os n\u00fameros 1, 2, 5 para garantir que o programa n\u00e3o interprete erroneamente isso como um tri\u00e2ngulo equil\u00e1tero em vez de um tri\u00e2ngulo escaleno.</p> <p>Al\u00e9m disso, muitos erros que s\u00e3o descobertos repentinamente no software de produ\u00e7\u00e3o aparecem quando ele \u00e9 usado de alguma maneira nova ou inesperada. \u00c9 dif\u00edcil, se n\u00e3o imposs\u00edvel, definir todos os casos de uso para teste de software. Portanto, os casos de teste que representam condi\u00e7\u00f5es de entrada inesperadas e inv\u00e1lidas parecem ter um rendimento de detec\u00e7\u00e3o de erro maior do que os casos de teste para condi\u00e7\u00f5es de entrada v\u00e1lidas.</p>"},{"location":"aae3/white_box_test/#principio-6","title":"Princ\u00edpio 6","text":"<p>Examinar um programa para ver se ele n\u00e3o faz o que deveria fazer \u00e9 apenas metade da batalha; a outra metade \u00e9 ver se o programa faz o que n\u00e3o deveria fazer. Este \u00e9 um corol\u00e1rio do princ\u00edpio anterior. Os programas devem ser examinados quanto a efeitos colaterais indesejados.</p> <p>Por exemplo, um programa de c\u00e1lculo das folhas de pagamento que produz os contracheques corretos ainda \u00e9 um programa err\u00f4neo se tamb\u00e9m produzir cheques extras para empregados inexistentes ou se sobregravar o primeiro registro do arquivo pessoal.</p>"},{"location":"aae3/white_box_test/#principio-7","title":"Princ\u00edpio 7","text":"<p>Evite casos de teste descart\u00e1veis, a menos que o programa seja realmente um programa descart\u00e1vel. Este problema \u00e9 visto com mais frequ\u00eancia com sistemas interativos para testar programas. Uma pr\u00e1tica comum \u00e9 sentar-se em um terminal e inventar casos de teste em tempo real e, em seguida, enviar esses casos de teste pelo programa.</p> <p>A principal quest\u00e3o \u00e9 que os casos de teste representam um investimento valioso que, neste ambiente, desaparece ap\u00f3s a conclus\u00e3o do teste. Sempre que o programa tiver que ser testado novamente (por exemplo, ap\u00f3s corrigir um erro ou fazer uma melhoria), os casos de teste devem ser reinventados.</p> <p>Na maioria das vezes, uma vez que essa reinven\u00e7\u00e3o requer uma quantidade consider\u00e1vel de trabalho, as pessoas tendem a evit\u00e1-la. Portanto, o teste do programa raramente \u00e9 t\u00e3o rigoroso quanto o teste original, o que significa que, se a modifica\u00e7\u00e3o fizer com que uma parte anteriormente funcional do programa falhe, esse erro geralmente n\u00e3o \u00e9 detectado.</p> <p>Salvar casos de teste e execut\u00e1-los novamente ap\u00f3s altera\u00e7\u00f5es em outros componentes do programa \u00e9 conhecido como teste de regress\u00e3o.</p>"},{"location":"aae3/white_box_test/#principio-8","title":"Princ\u00edpio 8","text":"<p>N\u00e3o planeje um esfor\u00e7o de teste sob a suposi\u00e7\u00e3o t\u00e1cita de que nenhum erro ser\u00e1 encontrado. Este \u00e9 um erro que os gerentes de projeto costumam cometer e \u00e9 um sinal do uso da defini\u00e7\u00e3o incorreta de teste \u2014 ou seja, a suposi\u00e7\u00e3o de que o teste \u00e9 o processo de mostrar que o programa funciona corretamente.</p> <p>Mais uma vez, a defini\u00e7\u00e3o de teste \u00e9 o processo de execu\u00e7\u00e3o de um programa com a inten\u00e7\u00e3o de encontrar erros. E deve ser \u00f3bvio a partir de nossas discuss\u00f5es anteriores que \u00e9 imposs\u00edvel desenvolver um programa que seja completamente livre de erros.</p> <p>Mesmo ap\u00f3s extensos testes e corre\u00e7\u00e3o de erros, \u00e9 seguro assumir que os erros ainda existem; eles simplesmente ainda n\u00e3o foram encontrados.</p>"},{"location":"aae3/white_box_test/#principio-9","title":"Princ\u00edpio 9","text":"<p>A probabilidade da exist\u00eancia de mais erros em uma se\u00e7\u00e3o de um programa \u00e9 proporcional ao n\u00famero de erros j\u00e1 encontrados nessa se\u00e7\u00e3o. Este fen\u00f4meno \u00e9 ilustrado na Figura 2.2. \u00c0 primeira vista, esse conceito pode parecer sem sentido, mas \u00e9 um fen\u00f4meno presente em muitos programas.</p> <p>Por exemplo, se um programa consiste em dois m\u00f3dulos, classes ou sub-rotinas, A e B, e cinco erros foram encontrados no m\u00f3dulo A, e apenas um erro foi encontrado no m\u00f3dulo B, e se o m\u00f3dulo A n\u00e3o foi propositalmente submetido a um teste mais rigoroso, ent\u00e3o este princ\u00edpio nos diz que a probabilidade de mais erros no m\u00f3dulo A \u00e9 maior do que a probabilidade de mais erros no m\u00f3dulo B.</p> <p>Outra maneira de afirmar esse princ\u00edpio \u00e9 dizer que os erros tendem a ocorrer em grupos e que, no programa t\u00edpico, algumas se\u00e7\u00f5es parecem ser muito mais propensas a erros do que outras se\u00e7\u00f5es, embora ningu\u00e9m tenha fornecido uma boa explica\u00e7\u00e3o de por que isso ocorre.</p> <p>FIGURA 2.2: A surpreendente rela\u00e7\u00e3o entre erros remanescentes e erros encontrados.</p> <p>O fen\u00f4meno \u00e9 \u00fatil porque nos d\u00e1 uma vis\u00e3o ou feedback no processo de teste. Se uma se\u00e7\u00e3o espec\u00edfica de um programa parece ser muito mais propensa a erros do que outras se\u00e7\u00f5es, esse fen\u00f4meno nos diz que, em termos de rendimento em nosso investimento em testes, os esfor\u00e7os adicionais de teste s\u00e3o mais bem focados nesta se\u00e7\u00e3o propensa a erros.</p>"},{"location":"aae3/white_box_test/#principio-10","title":"Princ\u00edpio 10","text":"<p>O teste \u00e9 uma tarefa extremamente criativa e intelectualmente desafiadora. Provavelmente \u00e9 verdade que a criatividade necess\u00e1ria para testar um programa grande excede a criatividade necess\u00e1ria para projetar esse programa.</p> <p>J\u00e1 vimos que \u00e9 imposs\u00edvel testar um programa o suficiente para garantir a aus\u00eancia de todos os erros. As metodologias discutidas posteriormente neste livro ajudam voc\u00ea a desenvolver um conjunto razo\u00e1vel de casos de teste para um programa, mas essas metodologias ainda exigem uma quantidade significativa de criatividade.</p>"},{"location":"aae3/white_box_test/#resumo","title":"Resumo","text":"<p>\u00c0 medida que voc\u00ea avan\u00e7a neste livro, tenha em mente estes importantes princ\u00edpios de teste:</p> <ul> <li>Teste \u00e9 o processo de execu\u00e7\u00e3o de um programa com a inten\u00e7\u00e3o de encontrar erros.</li> <li>O teste \u00e9 mais bem-sucedido quando n\u00e3o \u00e9 realizado pelo(s) desenvolvedor(es).</li> <li>Um bom caso de teste \u00e9 aquele que tem uma alta probabilidade de detectar um erro n\u00e3o descoberto.</li> <li>Um caso de teste bem-sucedido \u00e9 aquele que detecta um erro n\u00e3o descoberto.</li> <li>O teste bem-sucedido inclui tamb\u00e9m a defini\u00e7\u00e3o cuidadosa da sa\u00edda esperada como entrada.</li> <li>O teste bem-sucedido inclui o estudo cuidadoso dos resultados do teste.</li> </ul>"},{"location":"aae3/white_box_test/#bibliografia","title":"Bibliografia","text":"<p>MYERS, G. J.; SANDLER, C.; BADGETT, T. The Art of Software Testing. 3rd ed. Cap\u00edtulo 4, Se\u00e7\u00e3o White-Box Testing.</p>"},{"location":"tpi_tpe/tpi3_tpe3/","title":"TPI/TPE(3) - Quest\u00f5es de Testes de Software","text":""},{"location":"tpi_tpe/tpi3_tpe3/#q01-qual-e-a-representacao-de-programa-mais-comumente-utilizada-nos-criterios-de-teste-estrutural","title":"Q01. Qual \u00e9 a representa\u00e7\u00e3o de programa mais comumente utilizada nos crit\u00e9rios de teste estrutural?","text":"<ul> <li>a. Grafo de Causa-Efeito.  </li> <li>b. Grafo de Fluxo de Dados.  </li> <li>c. Grafo de Caminhos Independentes.  </li> <li>d. Grafo de Fluxo de Controle.  </li> </ul> <p>RESPOSTA: d. Grafo de Fluxo de Controle.</p> <p>O diagrama \u00e9 um grafo de fluxo de controle. Cada n\u00f3 ou c\u00edrculo representa um segmento de instru\u00e7\u00f5es que executam sequencialmente, podendo terminar com uma instru\u00e7\u00e3o de desvio. Cada aresta ou arco representa uma transfer\u00eancia de controle (desvio) entre segmentos.</p> <p>Refer\u00eancia: The Art of Software Testing \u2013 3rd Edition, p\u00e1gina 11.</p>"},{"location":"tpi_tpe/tpi3_tpe3/#q02-qual-das-seguintes-afirmacoes-e-mais-verdadeira-sobre-o-teste-de-unidade","title":"Q02. Qual das seguintes afirma\u00e7\u00f5es \u00e9 MAIS VERDADEIRA sobre o teste de unidade?","text":"<ul> <li>a. \u00c9 uma abordagem de teste de caixa preta onde a estrutura interna do m\u00f3dulo n\u00e3o \u00e9 considerada.  </li> <li>b. \u00c9 uma abordagem de teste de caixa branca que foca nos componentes individuais de um programa.  </li> <li>c. S\u00f3 \u00e9 usado para grandes programas com mais de 500 instru\u00e7\u00f5es.  </li> <li>d. \u00c9 o mesmo que teste de integra\u00e7\u00e3o, que combina v\u00e1rios componentes.</li> </ul> <p>RESPOSTA: b. \u00c9 uma abordagem de teste de caixa branca que foca nos componentes individuais de um programa.</p> <p>O teste de unidade \u00e9 amplamente orientado \u00e0 caixa-branca. (p. 86)  </p> <p>Refer\u00eancia: The Art of Software Testing \u2013 3rd Edition, p\u00e1gina 86.</p>"},{"location":"tpi_tpe/tpi3_tpe3/#q03-quais-sao-os-dois-principais-motivos-para-realizar-o-teste-de-unidade","title":"Q03. Quais s\u00e3o os dois principais motivos para realizar o teste de unidade?","text":"<ul> <li>a. Documentar a funcionalidade do programa e identificar erros no in\u00edcio do processo de desenvolvimento.  </li> <li>b. Reduzir a complexidade de testar programas grandes e facilitar a depura\u00e7\u00e3o.  </li> <li>c. Atender aos requisitos do usu\u00e1rio e garantir que o programa esteja livre de erros.  </li> <li>d. Melhorar a cobertura do c\u00f3digo e testar o desempenho do programa.  </li> </ul> <p>RESPOSTA: b. Reduzir a complexidade de testar programas grandes e facilitar a depura\u00e7\u00e3o.</p> <p>As motiva\u00e7\u00f5es para fazer isso s\u00e3o tr\u00eas. Primeiro, o teste de m\u00f3dulo \u00e9 uma forma de gerenciar os elementos combinados do teste, j\u00e1 que a aten\u00e7\u00e3o \u00e9 focada inicialmente em unidades menores do programa. Segundo, o teste de m\u00f3dulo facilita a tarefa de depura\u00e7\u00e3o, j\u00e1 que a aten\u00e7\u00e3o est\u00e1 concentrada em uma pequena unidade de c\u00f3digo e, frequentemente, a interface com o restante do programa \u00e9 simulada por um m\u00f3dulo stub. (p. 85)</p> <p>Refer\u00eancia: The Art of Software Testing \u2013 3rd Edition, p\u00e1gina 85.</p>"},{"location":"tpi_tpe/tpi3_tpe3/#q04-por-que-a-cobertura-de-condicao-pode-nao-satisfazer-a-cobertura-de-decisao","title":"Q04. Por que a cobertura de condi\u00e7\u00e3o pode n\u00e3o satisfazer a cobertura de decis\u00e3o?","text":"<ul> <li>a. Porque a cobertura de condi\u00e7\u00e3o n\u00e3o testa todas as instru\u00e7\u00f5es.  </li> <li>b. Porque algumas condi\u00e7\u00f5es podem mascarar outras.  </li> <li>c. Porque a cobertura de condi\u00e7\u00e3o n\u00e3o inclui os pontos de entrada do programa.  </li> <li>d. Porque a cobertura de condi\u00e7\u00e3o n\u00e3o testa todas as combina\u00e7\u00f5es de condi\u00e7\u00f5es.  </li> </ul> <p>RESPOSTA: b. Porque algumas condi\u00e7\u00f5es podem mascarar outras.</p> <p>Um ponto fraco da cobertura de condi\u00e7\u00e3o/decis\u00e3o \u00e9 que, embora pare\u00e7a exercitar todos os resultados de todas as condi\u00e7\u00f5es, frequentemente n\u00e3o o faz, porque certas condi\u00e7\u00f5es mascaram outras condi\u00e7\u00f5es.  </p> <p>Por exemplo, se uma condi\u00e7\u00e3o \u2018and\u2019 for falsa, nenhuma das condi\u00e7\u00f5es subsequentes na express\u00e3o precisa ser avaliada. Da mesma forma, se uma condi\u00e7\u00e3o \u2018or\u2019 for verdadeira, as condi\u00e7\u00f5es subsequentes tamb\u00e9m n\u00e3o precisam ser avaliadas.  </p> <p>Refer\u00eancia: The Art of Software Testing \u2013 3rd Edition, p\u00e1ginas 46\u201347.</p>"},{"location":"tpi_tpe/tpi3_tpe3/#q05-qual-e-a-principal-limitacao-da-cobertura-de-decisao","title":"Q05. Qual \u00e9 a principal limita\u00e7\u00e3o da cobertura de decis\u00e3o?","text":"<ul> <li>a. N\u00e3o garante que todas as instru\u00e7\u00f5es sejam executadas.  </li> <li>b. N\u00e3o considera as m\u00faltiplas condi\u00e7\u00f5es dentro de uma decis\u00e3o.  </li> <li>c. N\u00e3o testa todas as poss\u00edveis combina\u00e7\u00f5es de condi\u00e7\u00f5es.  </li> <li>d. N\u00e3o identifica erros em decis\u00f5es aninhadas.  </li> </ul> <p>RESPOSTA: b. N\u00e3o considera as m\u00faltiplas condi\u00e7\u00f5es dentro de uma decis\u00e3o.</p> <p>A cobertura de decis\u00e3o \u00e9 um crit\u00e9rio mais forte do que a cobertura de instru\u00e7\u00f5es, mas ainda \u00e9 bastante fraco. Um crit\u00e9rio que \u00e0s vezes \u00e9 mais forte do que a cobertura de decis\u00e3o \u00e9 a cobertura de condi\u00e7\u00e3o. [...] Mas, assim como a cobertura de decis\u00e3o, isso nem sempre leva \u00e0 execu\u00e7\u00e3o de cada instru\u00e7\u00e3o. Embora o crit\u00e9rio de cobertura de condi\u00e7\u00e3o pare\u00e7a, \u00e0 primeira vista, satisfazer o crit\u00e9rio de cobertura de decis\u00e3o, isso nem sempre acontece. [...] Os testes de cobertura de condi\u00e7\u00e3o do exemplo anterior cobriram todos os resultados das condi\u00e7\u00f5es, mas apenas dois dos quatro resultados das decis\u00f5es...</p> <p>Refer\u00eancia: The Art of Software Testing \u2013 3rd Edition, p\u00e1ginas 45\u201346.</p>"},{"location":"tpi_tpe/tpi3_tpe3/#q06-qual-dos-criterios-de-cobertura-de-logica-e-considerado-o-mais-fraco","title":"Q06. Qual dos crit\u00e9rios de cobertura de l\u00f3gica \u00e9 considerado o mais fraco?","text":"<ul> <li>a. Cobertura de condi\u00e7\u00e3o.  </li> <li>b. Cobertura de decis\u00e3o.  </li> <li>c. Cobertura de m\u00faltiplas condi\u00e7\u00f5es.  </li> <li>d. Cobertura de instru\u00e7\u00e3o.  </li> </ul> <p>RESPOSTA: d. Cobertura de instru\u00e7\u00e3o.</p> <p>Embora voc\u00ea possa executar todas as instru\u00e7\u00f5es com um \u00fanico teste, esse crit\u00e9rio \u00e9 bastante fraco. Em outras palavras, o crit\u00e9rio de cobertura de instru\u00e7\u00e3o \u00e9 t\u00e3o fraco que geralmente \u00e9 in\u00fatil.  </p> <p>Refer\u00eancia: The Art of Software Testing \u2013 3rd Edition, p\u00e1gina 44</p>"},{"location":"tpi_tpe/tpi3_tpe3/#q07-o-que-o-metodo-mcdc-visa-alcancar","title":"Q07. O que o m\u00e9todo MC/DC visa alcan\u00e7ar?","text":"<ul> <li>a. Testar todas as instru\u00e7\u00f5es do programa pelo menos uma vez.  </li> <li>b. Testar todas as combina\u00e7\u00f5es de decis\u00f5es em um programa.  </li> <li>c. Garantir que cada condi\u00e7\u00e3o em uma decis\u00e3o tenha um resultado verdadeiro e falso pelo menos uma vez.  </li> <li>d. Garantir que cada condi\u00e7\u00e3o independente em uma decis\u00e3o tenha um efeito independente na sa\u00edda da decis\u00e3o.  </li> </ul> <p>RESPOSTA: d. Garantir que cada condi\u00e7\u00e3o independente em uma decis\u00e3o tenha um efeito independente na sa\u00edda da decis\u00e3o.</p> <p>A cobertura de condi\u00e7\u00e3o/decis\u00e3o modificada (MC/DC) exige que cada ponto de entrada e sa\u00edda do programa tenha sido invocado pelo menos uma vez, que cada condi\u00e7\u00e3o em uma decis\u00e3o assuma todos os resultados poss\u00edveis pelo menos uma vez e que cada condi\u00e7\u00e3o em uma decis\u00e3o tenha mostrado afetar de forma independente o resultado da decis\u00e3o.</p> <p>Refer\u00eancia: The Art of Software Testing \u2013 3rd Edition, p\u00e1gina 47.</p>"},{"location":"tpi_tpe/tpi3_tpe3/#q08-qual-e-uma-das-principais-vantagens-do-metodo-mcdc-em-relacao-a-outros-criterios-de-cobertura","title":"Q08. Qual \u00e9 uma das principais vantagens do m\u00e9todo MC/DC em rela\u00e7\u00e3o a outros crit\u00e9rios de cobertura?","text":"<ul> <li>a. Requer menos casos de teste para ser implementado.  </li> <li>b. \u00c9 mais f\u00e1cil de entender e aplicar em programas grandes.  </li> <li>c. Garante uma cobertura mais robusta ao testar condi\u00e7\u00f5es de decis\u00e3o.  </li> <li>d. N\u00e3o requer testes de m\u00faltiplas condi\u00e7\u00f5es dentro de uma decis\u00e3o.  </li> </ul> <p>RESPOSTA: c. Garante uma cobertura mais robusta ao testar condi\u00e7\u00f5es de decis\u00e3o.</p> <p>Um crit\u00e9rio que cobre esse problema, e vai al\u00e9m, \u00e9 a cobertura de m\u00faltiplas condi\u00e7\u00f5es. Esse crit\u00e9rio exige que voc\u00ea escreva casos de teste suficientes para que todas as combina\u00e7\u00f5es poss\u00edveis de resultados de condi\u00e7\u00f5es em cada decis\u00e3o, e todos os pontos de entrada, sejam invocados pelo menos uma vez. Embora o MC/DC n\u00e3o exija todas as combina\u00e7\u00f5es, ele melhora a cobertura de decis\u00e3o/condi\u00e7\u00e3o ao garantir que cada condi\u00e7\u00e3o afete independentemente o resultado da decis\u00e3o.</p> <p>Refer\u00eancia: The Art of Software Testing \u2013 3rd Edition, p\u00e1gina 47.</p>"},{"location":"tpi_tpe/tpi3_tpe3/#q09-qual-das-seguintes-afirmacoes-melhor-descreve-o-primeiro-passo-ao-usar-tecnicas-de-cobertura-logica-no-teste-de-software","title":"Q09. Qual das seguintes afirma\u00e7\u00f5es melhor descreve o primeiro passo ao usar t\u00e9cnicas de cobertura l\u00f3gica no teste de software?","text":"<ul> <li>a. Identificar todas as vari\u00e1veis no programa e garantir que cada uma seja testada em diferentes condi\u00e7\u00f5es.  </li> <li>b. Listar as decis\u00f5es condicionais no programa, focando em declara\u00e7\u00f5es IF, DO e similares.  </li> <li>c. Criar casos de teste para todas as funcionalidades do software sem considerar a estrutura interna do c\u00f3digo.  </li> <li>d. Garantir que todas as declara\u00e7\u00f5es IF no programa sejam testadas de forma isolada para verificar seu comportamento.  </li> </ul> <p>RESPOSTA: b. Listar as decis\u00f5es condicionais no programa, focando em declara\u00e7\u00f5es IF, DO e similares.</p> <p>Independentemente da t\u00e9cnica de cobertura l\u00f3gica utilizada, o primeiro passo \u00e9 listar as decis\u00f5es condicionais no programa. Os candidatos neste programa s\u00e3o todas as instru\u00e7\u00f5es IF e DO.</p> <p>Refer\u00eancia: The Art of Software Testing \u2013 3rd Edition, p\u00e1gina 89.</p>"},{"location":"tpi_tpe/tpi3_tpe3/#q10-qual-das-seguintes-afirmacoes-melhor-descreve-uma-caracteristica-do-criterio-de-cobertura-de-multiplas-condicoes","title":"Q10. Qual das seguintes afirma\u00e7\u00f5es melhor descreve uma caracter\u00edstica do crit\u00e9rio de cobertura de m\u00faltiplas condi\u00e7\u00f5es?","text":"<ul> <li>a. O crit\u00e9rio de cobertura de m\u00faltiplas condi\u00e7\u00f5es \u00e9 suficiente para detectar todos os erros poss\u00edveis em uma unidade.  </li> <li>b. Mesmo testes que satisfazem o crit\u00e9rio de cobertura de m\u00faltiplas condi\u00e7\u00f5es podem n\u00e3o detectar certos erros, como valores iniciais incorretos.  </li> <li>c. O crit\u00e9rio de cobertura de m\u00faltiplas condi\u00e7\u00f5es se concentra apenas em testes de caixa-preta.  </li> <li>d. O crit\u00e9rio de cobertura de m\u00faltiplas condi\u00e7\u00f5es garante que todos os caminhos de execu\u00e7\u00e3o do c\u00f3digo sejam testados.  </li> </ul> <p>RESPOSTA: b. Mesmo testes que satisfazem o crit\u00e9rio de cobertura de m\u00faltiplas condi\u00e7\u00f5es podem n\u00e3o detectar certos erros, como valores iniciais incorretos.</p> <p>Embora esses dois casos de teste atendam ao crit\u00e9rio de cobertura de decis\u00e3o, deve ser \u00f3bvio que pode haver muitos tipos de erros no m\u00f3dulo que n\u00e3o s\u00e3o detectados por esses dois casos. Por exemplo, os casos de teste n\u00e3o exploram circunst\u00e2ncias como quando o c\u00f3digo de erro \u00e9 0, um funcion\u00e1rio \u00e9 gerente ou a tabela de departamentos est\u00e1 vazia (DSIZE \u2264 0).</p> <p>Refer\u00eancia: The Art of Software Testing \u2013 3rd Edition, p\u00e1gina 90.</p>"},{"location":"tpi_tpe/tpi3_tpe3/#q11-qual-e-uma-vantagem-importante-do-teste-incremental-sobre-o-teste-nao-incremental","title":"Q11. Qual \u00e9 uma vantagem importante do teste incremental sobre o teste n\u00e3o incremental?","text":"<ul> <li>a. Requer menos m\u00f3dulos de driver e stub.  </li> <li>b. Necessita de menos tempo de m\u00e1quina.  </li> <li>c. Permite que todos os m\u00f3dulos sejam testados simultaneamente.  </li> <li>d. Reduz a possibilidade de detectar erros nas interfaces dos m\u00f3dulos.  </li> </ul> <p>RESPOSTA: a. Requer menos m\u00f3dulos de driver e stub.</p> <p>O teste n\u00e3o incremental exige mais trabalho. Para o programa da Figura 5.7, cinco drivers e cinco stubs devem ser preparados [...]. O teste incremental bottom-up exigiria cinco drivers, mas nenhum stub. Um teste incremental top-down exigiria cinco stubs, mas nenhum driver. Menos trabalho \u00e9 necess\u00e1rio porque os m\u00f3dulos previamente testados s\u00e3o usados em vez dos m\u00f3dulos driver (se come\u00e7ar do topo) ou dos m\u00f3dulos stub (se come\u00e7ar pela base) exigidos na abordagem n\u00e3o incremental.</p> <p>Refer\u00eancia: The Art of Software Testing \u2013 3rd Edition, p\u00e1gina 99.</p>"},{"location":"tpi_tpe/tpi3_tpe3/#q12-qual-das-seguintes-observacoes-e-uma-vantagem-do-teste-nao-incremental","title":"Q12. Qual das seguintes observa\u00e7\u00f5es \u00e9 uma vantagem do teste n\u00e3o incremental?","text":"<ul> <li>a. Detecta erros de interfaces de m\u00f3dulos mais cedo.  </li> <li>b. Reduz a necessidade de drivers e stubs.  </li> <li>c. Permite mais atividades paralelas no in\u00edcio da fase de testes de m\u00f3dulo.  </li> <li>d. Resulta em testes mais completos dos m\u00f3dulos.  </li> </ul> <p>RESPOSTA: c. Permite mais atividades paralelas no in\u00edcio da fase de testes de m\u00f3dulo.</p> <p>No in\u00edcio da fase de testes de m\u00f3dulo, h\u00e1 mais oportunidade para atividades paralelas quando se utiliza o teste n\u00e3o incremental (isto \u00e9, todos os m\u00f3dulos podem ser testados simultaneamente). Isso pode ser significativo em projetos grandes (com muitos m\u00f3dulos e pessoas), j\u00e1 que o n\u00famero de integrantes do projeto geralmente atinge seu pico no in\u00edcio dessa fase.</p> <p>Refer\u00eancia: The Art of Software Testing \u2013 3rd Edition, p\u00e1gina 100.</p>"},{"location":"tpi_tpe/tpi3_tpe3/#q13-qual-e-uma-das-principais-vantagens-do-teste-top-down","title":"Q13. Qual \u00e9 uma das principais vantagens do teste top-down?","text":"<ul> <li>a. N\u00e3o requer a cria\u00e7\u00e3o de stubs.  </li> <li>b. Facilita a representa\u00e7\u00e3o de casos de teste uma vez que as fun\u00e7\u00f5es de entrada e sa\u00edda s\u00e3o adicionadas.  </li> <li>c. Permite a identifica\u00e7\u00e3o de todos os erros poss\u00edveis no programa.  </li> <li>d. Garante que todos os m\u00f3dulos s\u00e3o testados simultaneamente.  </li> </ul> <p>RESPOSTA: b. Facilita a representa\u00e7\u00e3o de casos de teste uma vez que as fun\u00e7\u00f5es de entrada e sa\u00edda s\u00e3o adicionadas.</p> <p>Uma vez que as fun\u00e7\u00f5es de entrada/sa\u00edda s\u00e3o adicionadas, a representa\u00e7\u00e3o dos casos \u00e9 facilitada.</p> <p>Refer\u00eancia: The Art of Software Testing \u2013 3rd Edition, p\u00e1gina 109.</p>"},{"location":"tpi_tpe/tpi3_tpe3/#q14-qual-e-uma-desvantagem-do-teste-bottom-up","title":"Q14. Qual \u00e9 uma desvantagem do teste bottom-up?","text":"<ul> <li>a. A produ\u00e7\u00e3o de m\u00f3dulos driver \u00e9 mais dif\u00edcil que a produ\u00e7\u00e3o de stubs.  </li> <li>b. N\u00e3o permite a cria\u00e7\u00e3o de um esqueleto inicial do programa.  </li> <li>c. Requer que todos os m\u00f3dulos sejam testados simultaneamente.  </li> <li>d. Aumenta a possibilidade de erros humanos durante a fase de design.  </li> </ul> <p>RESPOSTA: b. N\u00e3o permite a cria\u00e7\u00e3o de um esqueleto inicial do programa.</p> <p>Uma desvantagem da estrat\u00e9gia bottom-up \u00e9 que n\u00e3o h\u00e1 conceito de um programa esquel\u00e9tico inicial. De fato, o programa funcional n\u00e3o existe at\u00e9 que o \u00faltimo m\u00f3dulo (m\u00f3dulo A) seja adicionado, e esse programa funcional \u00e9 o programa completo.</p> <p>Refer\u00eancia: The Art of Software Testing \u2013 3rd Edition, p\u00e1gina 107.</p>"},{"location":"tpi_tpe/tpi4_tpe4/","title":"TPI/TPE(4) - Quest\u00f5es de Testes de Software","text":""},{"location":"tpi_tpe/tpi4_tpe4/#q01-o-que-sao-objetos-dummy","title":"Q01. O que s\u00e3o objetos dummy?","text":"<ul> <li>a. Objetos que possuem implementa\u00e7\u00f5es reais, mas simplificadas.</li> <li>b. Objetos passados para a classe em teste, mas nunca utilizados.</li> <li>c. Objetos que fornecem respostas codificadas para chamadas realizadas durante o teste.</li> <li>d. Objetos que gravam todas as intera\u00e7\u00f5es e permitem fazer asser\u00e7\u00f5es posteriormente.</li> </ul> <p>RESPOSTA: b. Objetos passados para a classe em teste, mas nunca utilizados.</p> <p>Objetos Dummy s\u00e3o uma forma degenerada de Test Double. Eles existem apenas para serem passados de m\u00e9todo para m\u00e9todo; eles nunca s\u00e3o utilizados. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 728)</p> <p>Um objeto dummy \u00e9 passado para preencher uma lista de par\u00e2metros, mas nunca \u00e9 usado. Eles s\u00e3o mais frequentemente usados para preencher par\u00e2metros obrigat\u00f3rios em m\u00e9todos ou construtores. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 728)</p> <p>Algumas linguagens exigem que forne\u00e7amos valores para todos os par\u00e2metros formais de um m\u00e9todo; objetos dummy nos permitem satisfazer esse requisito sem afetar o comportamento do teste. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 728)</p> <p>Refer\u00eancia: Meszaros, G. (2007). xUnit Test Patterns: Refactoring Test Code. Addison-Wesley.</p>"},{"location":"tpi_tpe/tpi4_tpe4/#por-que-as-outras-alternativas-estao-erradas","title":"Por que as outras alternativas est\u00e3o erradas","text":"<ul> <li>a. Objetos que possuem implementa\u00e7\u00f5es reais, mas simplificadas.</li> </ul> <p>Isso define um Fake Object: substitu\u00edmos um componente do SUT por uma implementa\u00e7\u00e3o funcional mais leve. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 551)</p> <ul> <li>c. Objetos que fornecem respostas codificadas para chamadas realizadas durante o teste.</li> </ul> <p>Isso define um Test Stub: substitu\u00edmos um objeto real por um objeto de teste que fornece entradas indiretas. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 529)</p> <ul> <li>d. Objetos que gravam todas as intera\u00e7\u00f5es e permitem fazer asser\u00e7\u00f5es posteriormente.</li> </ul> <p>Isso corresponde a um Test Spy: usamos um Test Double para capturar as chamadas indiretas feitas pelo SUT para posterior verifica\u00e7\u00e3o. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 538)</p> <p>Refer\u00eancia: Meszaros, G. (2007). xUnit Test Patterns: Refactoring Test Code. Addison-Wesley.</p>"},{"location":"tpi_tpe/tpi4_tpe4/#q02-qual-a-principal-caracteristica-de-objetos-fake","title":"Q02. Qual a principal caracter\u00edstica de objetos fake?","text":"<ul> <li>a. Eles t\u00eam implementa\u00e7\u00f5es reais, mas geralmente fazem a tarefa de forma mais simples.</li> <li>b. Eles fornecem respostas codificadas para chamadas realizadas durante o teste.</li> <li>c. Eles gravam todas as intera\u00e7\u00f5es e permitem fazer asser\u00e7\u00f5es posteriormente.</li> <li>d. Eles envolvem o objeto real e observam seu comportamento.</li> </ul> <p>RESPOSTA: a. Eles t\u00eam implementa\u00e7\u00f5es reais, mas geralmente fazem a tarefa de forma mais simples.</p> <p>Um Fake Object \u00e9 um dubl\u00ea de teste que substitui um componente do SUT com uma implementa\u00e7\u00e3o funcional, geralmente mais leve. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 551) </p> <p>Muitas vezes, usamos fakes para evitar depend\u00eancias de infraestrutura como banco de dados ou servi\u00e7os de rede. Por exemplo, um fake pode ser um banco de dados em mem\u00f3ria simples usado em vez de um real. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 551) </p> <p>Um fake geralmente implementa a mesma interface que o objeto real, mas com um comportamento mais simples, suficiente para os testes. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 551) </p>"},{"location":"tpi_tpe/tpi4_tpe4/#por-que-as-outras-alternativas-estao-erradas_1","title":"Por que as outras alternativas est\u00e3o erradas","text":"<ul> <li>b. Eles fornecem respostas codificadas para chamadas realizadas durante o teste.</li> </ul> <p>Isso define um Test Stub, n\u00e3o um fake. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 529) </p> <ul> <li>c. Eles gravam todas as intera\u00e7\u00f5es e permitem fazer asser\u00e7\u00f5es posteriormente.</li> </ul> <p>Essa \u00e9 a defini\u00e7\u00e3o de um Test Spy. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 538) </p> <ul> <li>d. Eles envolvem o objeto real e observam seu comportamento.</li> </ul> <p>Isso descreve um Mock Object, especialmente um mock din\u00e2mico que usa proxying para observar intera\u00e7\u00f5es. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 544) </p> <p>Refer\u00eancia: Meszaros, G. (2007). xUnit Test Patterns: Refactoring Test Code. Addison-Wesley.</p>"},{"location":"tpi_tpe/tpi4_tpe4/#q03-como-os-stubs-diferem-dos-objetos-fake","title":"Q03. Como os stubs diferem dos objetos fake?","text":"<ul> <li>a. Stubs t\u00eam implementa\u00e7\u00f5es reais, mas simplificadas.</li> <li>b. Stubs s\u00e3o usados apenas para observar o comportamento de uma depend\u00eancia real.</li> <li>c. Stubs fornecem respostas codificadas e n\u00e3o t\u00eam uma implementa\u00e7\u00e3o funcional.</li> <li>d. Stubs permitem fazer asser\u00e7\u00f5es sobre as intera\u00e7\u00f5es ap\u00f3s o teste.</li> </ul> <p>RESPOSTA: c. Stubs fornecem respostas codificadas e n\u00e3o t\u00eam uma implementa\u00e7\u00e3o funcional.</p> <p>Um Stub \u00e9 um Dubl\u00ea de Teste que fornece entradas indiretas para o SUT, retornando valores codificados em resposta a chamadas feitas durante o teste. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 529) </p> <p>Os stubs n\u00e3o possuem comportamento funcional; eles apenas retornam valores predefinidos quando chamados. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 529) </p> <p>Em contraste, um Fake Object substitui um componente por uma implementa\u00e7\u00e3o funcional mais leve, como um banco de dados em mem\u00f3ria. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 551) </p> <p>Um Fake geralmente \u00e9 uma implementa\u00e7\u00e3o funcional completa (mas simples), o que o difere fundamentalmente de um stub que apenas devolve valores fixos. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 551) </p>"},{"location":"tpi_tpe/tpi4_tpe4/#por-que-as-outras-alternativas-estao-erradas_2","title":"Por que as outras alternativas est\u00e3o erradas","text":"<ul> <li>a. Stubs t\u00eam implementa\u00e7\u00f5es reais, mas simplificadas.</li> </ul> <p>Essa \u00e9 a defini\u00e7\u00e3o de um Fake, n\u00e3o de um Stub. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 551) </p> <ul> <li>b. Stubs s\u00e3o usados apenas para observar o comportamento de uma depend\u00eancia real.</li> </ul> <p>Isso descreve um Test Spy ou um Mock, e n\u00e3o um Stub. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 538) </p> <ul> <li>d. Stubs permitem fazer asser\u00e7\u00f5es sobre as intera\u00e7\u00f5es ap\u00f3s o teste.</li> </ul> <p>Quem permite isso s\u00e3o os Test Spies, n\u00e3o os Stubs. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 538) </p> <p>Refer\u00eancia: Meszaros, G. (2007). xUnit Test Patterns: Refactoring Test Code. Addison-Wesley.</p>"},{"location":"tpi_tpe/tpi4_tpe4/#q04-qual-a-vantagem-principal-dos-objetos-mocks-em-comparacao-com-os-stubs","title":"Q04. Qual a vantagem principal dos objetos mocks em compara\u00e7\u00e3o com os stubs?","text":"<ul> <li>a. Mocks t\u00eam implementa\u00e7\u00f5es reais.</li> <li>b. Mocks s\u00e3o mais f\u00e1ceis de controlar do que stubs.</li> <li>c. Mocks podem gravar intera\u00e7\u00f5es e permitir asser\u00e7\u00f5es sobre elas.</li> <li>d. Mocks fornecem respostas codificadas para chamadas realizadas durante o teste.</li> </ul> <p>RESPOSTA: c. Mocks podem gravar intera\u00e7\u00f5es e permitir asser\u00e7\u00f5es sobre elas.</p> <p>Um Mock Object \u00e9 um dubl\u00ea de teste que \u00e9 pr\u00e9-programado com expectativas, que representam uma especifica\u00e7\u00e3o das chamadas que ele deve receber. O mock verifica automaticamente se essas chamadas ocorrem e, se n\u00e3o, o teste falha. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 544) </p> <p>Os mocks s\u00e3o frequentemente criados por meio de bibliotecas que permitem especificar as intera\u00e7\u00f5es esperadas. Essas intera\u00e7\u00f5es s\u00e3o registradas durante a execu\u00e7\u00e3o, e as bibliotecas de mocks verificam automaticamente se o comportamento ocorreu como esperado. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 544) </p> <p>Em contraste, um Stub apenas fornece valores de retorno predefinidos e n\u00e3o verifica intera\u00e7\u00f5es com o SUT. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 529) </p> <p>Os stubs n\u00e3o sabem se foram chamados corretamente; s\u00e3o usados apenas para injetar entradas indiretas no SUT. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 529) </p>"},{"location":"tpi_tpe/tpi4_tpe4/#por-que-as-outras-alternativas-estao-erradas_3","title":"Por que as outras alternativas est\u00e3o erradas","text":"<ul> <li>a. Mocks t\u00eam implementa\u00e7\u00f5es reais.</li> </ul> <p>Isso define um Fake Object, que \u00e9 uma implementa\u00e7\u00e3o funcional simplificada, n\u00e3o um Mock. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 551) </p> <ul> <li>b. Mocks s\u00e3o mais f\u00e1ceis de controlar do que stubs.</li> </ul> <p>O livro n\u00e3o afirma que mocks s\u00e3o \"mais f\u00e1ceis de controlar\". Ele aponta que mocks s\u00e3o usados para verificar intera\u00e7\u00f5es, enquanto stubs s\u00e3o usados para fornecer entradas indiretas. (p. 544 vs. 529, Meszaros, 2007)</p> <ul> <li>d. Mocks fornecem respostas codificadas para chamadas realizadas durante o teste.</li> </ul> <p>Quem faz isso s\u00e3o os Stubs, n\u00e3o os Mocks. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 529) </p> <p>Refer\u00eancia: Meszaros, G. (2007). xUnit Test Patterns: Refactoring Test Code. Addison-Wesley.</p>"},{"location":"tpi_tpe/tpi4_tpe4/#q05-uma-classe-que-simula-uma-base-de-dados-usando-uma-lista-pode-ser-classificada-como","title":"Q05. Uma classe que simula uma base de dados usando uma lista pode ser classificada como:","text":"<ul> <li>a. Fake object</li> <li>b. Dummy object</li> <li>c. Mock</li> <li>d. Stub</li> </ul> <p>RESPOSTA: a. Fake object</p> <p>Um Fake Object \u00e9 um Dubl\u00ea de Teste que substitui um componente de que o SUT depende com uma implementa\u00e7\u00e3o funcional, geralmente mais leve. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 551) </p> <p>Um exemplo comum de fake \u00e9 uma implementa\u00e7\u00e3o em mem\u00f3ria de um banco de dados, usada em vez de um banco real durante os testes. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 551) </p> <p>Fakes s\u00e3o apropriados quando a implementa\u00e7\u00e3o alternativa \u00e9 mais r\u00e1pida ou f\u00e1cil de configurar do que a real, mas ainda fornece o comportamento necess\u00e1rio para os testes. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 551) </p>"},{"location":"tpi_tpe/tpi4_tpe4/#por-que-as-outras-alternativas-estao-erradas_4","title":"Por que as outras alternativas est\u00e3o erradas","text":"<ul> <li>b. Dummy object</li> </ul> <p>Dummies s\u00e3o passados para preencher par\u00e2metros, mas nunca s\u00e3o usados. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 728) Uma lista simulando uma base de dados \u00e9 usada funcionalmente, portanto n\u00e3o \u00e9 um dummy.</p> <ul> <li>c. Mock</li> </ul> <p>Mocks s\u00e3o configurados com expectativas de chamadas e verificam se elas ocorreram; n\u00e3o s\u00e3o usados para simular l\u00f3gica funcional como um banco de dados. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 544) </p> <ul> <li>d. Stub</li> </ul> <p>Stubs s\u00e3o usados para fornecer respostas codificadas a chamadas do SUT, mas n\u00e3o t\u00eam comportamento funcional completo como um banco de dados em mem\u00f3ria. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 529) </p> <p>Refer\u00eancia: Meszaros, G. (2007). xUnit Test Patterns: Refactoring Test Code. Addison-Wesley.</p>"},{"location":"tpi_tpe/tpi4_tpe4/#q06-o-que-pode-ser-necessario-para-injetar-dubles-de-teste","title":"Q06. O que pode ser necess\u00e1rio para injetar dubl\u00eas de teste?","text":"<ul> <li>a. Criar um tipo especial de dubl\u00ea que intercepte chamadas.</li> <li>b. Refatorar o construtor da classe de teste para instanciar a depend\u00eancia.</li> <li>c. Usar um framework de mocking para inje\u00e7\u00e3o autom\u00e1tica.</li> <li>d. Alterar o c\u00f3digo da classe sendo testada para aceitar a depend\u00eancia via construtor.</li> </ul> <p>RESPOSTA: d. Alterar o c\u00f3digo da classe sendo testada para aceitar a depend\u00eancia via construtor.</p> <p>Inje\u00e7\u00e3o por Construtor: informamos ao SUT qual DOC usar quando o constru\u00edmos. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 680) </p> <p>Para converter o SUT para usar Inje\u00e7\u00e3o por Construtor, podemos fazer um refatoramento do tipo \"Introduce Field\" para manter o DOC em um campo que \u00e9 inicializado no construtor existente. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 684) </p> <p>Quando um teste deseja substituir o DOC real por um dubl\u00ea de teste, ele o passa para o construtor ao construir o SUT. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 681) </p> <p>Quando o SUT n\u00e3o suporta inje\u00e7\u00e3o de depend\u00eancia \"de f\u00e1brica\", pode ser necess\u00e1rio refatorar o c\u00f3digo da classe sendo testada para permitir isso. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 682) </p>"},{"location":"tpi_tpe/tpi4_tpe4/#por-que-as-outras-alternativas-estao-erradas_5","title":"Por que as outras alternativas est\u00e3o erradas","text":"<ul> <li>a. Criar um tipo especial de dubl\u00ea que intercepte chamadas.</li> </ul> <p>O livro descreve mocks e spies como dubl\u00eas configur\u00e1veis, mas n\u00e3o afirma que a inje\u00e7\u00e3o exige criar um tipo especial que intercepte chamadas. Isso n\u00e3o \u00e9 necess\u00e1rio para inje\u00e7\u00e3o. (p. 522 e p. 544, Meszaros, 2007)</p> <ul> <li>b. Refatorar o construtor da classe de teste para instanciar a depend\u00eancia.</li> </ul> <p>O que precisa ser refatorado \u00e9 o construtor da classe sendo testada (SUT), n\u00e3o o da classe de teste. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 684) </p> <ul> <li>c. Usar um framework de mocking para inje\u00e7\u00e3o autom\u00e1tica.</li> </ul> <p>O livro menciona que frameworks de mock como JMock facilitam a cria\u00e7\u00e3o de mocks, mas n\u00e3o substituem a necessidade de refatorar o SUT para aceitar inje\u00e7\u00e3o. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 565) </p> <p>Refer\u00eancia: Meszaros, G. (2007). xUnit Test Patterns: Refactoring Test Code. Addison-Wesley.</p>"},{"location":"tpi_tpe/tpi4_tpe4/#q07-qual-a-principal-vantagem-de-configurar-dubles-para-lancar-excecoes","title":"Q07. Qual a principal vantagem de configurar dubl\u00eas para lan\u00e7ar exce\u00e7\u00f5es?","text":"<ul> <li>a. Permite testar como os sistemas se comportariam em cen\u00e1rios inesperados, simulando falhas.</li> <li>b. Garante que todos os m\u00e9todos sejam chamados ao menos uma vez.</li> <li>c. Facilita respostas codificadas.</li> <li>d. Substitui testes de integra\u00e7\u00e3o com sistemas externos.</li> </ul> <p>RESPOSTA: a. Permite testar como os sistemas se comportariam em cen\u00e1rios inesperados, simulando falhas.</p> <p>Certamente n\u00e3o queremos que o c\u00f3digo de tratamento de exce\u00e7\u00f5es seja executado pela primeira vez em produ\u00e7\u00e3o. E se ele estiver implementado incorretamente? \u00c9 altamente desej\u00e1vel ter testes automatizados para esse c\u00f3digo. O desafio no teste \u00e9 fazer com que o DOC (componente dependente) lance uma exce\u00e7\u00e3o para que o caminho de erro possa ser testado. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 127) </p> <p>A exce\u00e7\u00e3o que esperamos que o DOC lance \u00e9 um bom exemplo de uma condi\u00e7\u00e3o de entrada indireta. Nosso meio de injetar essa entrada \u00e9 um ponto de controle. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 127) </p> <p>Um Saboteur \u00e9 um tipo especial de Test Stub que lan\u00e7a exce\u00e7\u00f5es ou erros para injetar entradas indiretas anormais no SUT. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 135) </p> <p>Um Expected Exception Test nos ajuda a verificar se os cen\u00e1rios de erro foram codificados corretamente. O modo mais comum de for\u00e7ar esses erros \u00e9 usar um Test Stub para controlar a entrada indireta e lan\u00e7ar as exce\u00e7\u00f5es apropriadas. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 350) </p>"},{"location":"tpi_tpe/tpi4_tpe4/#por-que-as-outras-alternativas-estao-erradas_6","title":"Por que as outras alternativas est\u00e3o erradas","text":"<ul> <li>b. Garante que todos os m\u00e9todos sejam chamados ao menos uma vez.</li> </ul> <p>Isso n\u00e3o \u00e9 relacionado ao lan\u00e7amento de exce\u00e7\u00f5es. Verificar se m\u00e9todos s\u00e3o chamados pertence ao comportamento de Mocks (verifica\u00e7\u00e3o de intera\u00e7\u00f5es), n\u00e3o ao uso de exce\u00e7\u00f5es. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 544)</p> <ul> <li>c. Facilita respostas codificadas.</li> </ul> <p>Quem faz isso s\u00e3o os Stubs do tipo Responder, usados para retornar valores predefinidos \u2014 n\u00e3o para lan\u00e7ar exce\u00e7\u00f5es. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 529)</p> <ul> <li>d. Substitui testes de integra\u00e7\u00e3o com sistemas externos.</li> </ul> <p>Dubl\u00eas podem ajudar a simular sistemas externos, mas o foco do uso de exce\u00e7\u00f5es n\u00e3o \u00e9 substituir testes de integra\u00e7\u00e3o, e sim permitir testar o comportamento em situa\u00e7\u00f5es de falha. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 127)</p> <p>Refer\u00eancia: Meszaros, G. (2007). xUnit Test Patterns: Refactoring Test Code. Addison-Wesley.</p>"},{"location":"tpi_tpe/tpi4_tpe4/#q08-qual-e-uma-das-principais-desvantagens-de-usar-dubles","title":"Q08. Qual \u00e9 uma das principais desvantagens de usar dubl\u00eas?","text":"<ul> <li>a. O acoplamento com o c\u00f3digo de produ\u00e7\u00e3o, que pode levar a falhas ao mudar intera\u00e7\u00f5es.</li> <li>b. Dificuldade de configura\u00e7\u00e3o e manuten\u00e7\u00e3o.</li> <li>c. Incapacidade de simular comportamentos complexos.</li> <li>d. Modifica\u00e7\u00e3o excessiva do c\u00f3digo de produ\u00e7\u00e3o.</li> </ul> <p>RESPOSTA: a. O acoplamento com o c\u00f3digo de produ\u00e7\u00e3o, que pode levar a falhas ao mudar intera\u00e7\u00f5es.</p> <p>Podemos tamb\u00e9m implementar o Test Double criando uma subclasse da DOC real e sobrescrevendo os m\u00e9todos cujo comportamento queremos mudar. Infelizmente, essa abordagem pode ter consequ\u00eancias imprevis\u00edveis se o SUT chamar outros m\u00e9todos da DOC que n\u00e3o foram sobrescritos. Isso tamb\u00e9m acopla fortemente o c\u00f3digo de teste \u00e0 implementa\u00e7\u00e3o da DOC, o que pode resultar em software superespecificado. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 570) </p> <p>Testes fr\u00e1geis indicam que os testes est\u00e3o muito acoplados ao SUT. Isso causa alto custo de manuten\u00e7\u00e3o, pois os testes precisam ser revisados com frequ\u00eancia, mesmo quando mudan\u00e7as m\u00ednimas s\u00e3o feitas. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 266) </p> <p>O custo alto de manuten\u00e7\u00e3o dos testes decorre do fato de que os testes ficam excessivamente dif\u00edceis de entender e manter. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 265) </p>"},{"location":"tpi_tpe/tpi4_tpe4/#por-que-as-outras-alternativas-estao-erradas_7","title":"Por que as outras alternativas est\u00e3o erradas","text":"<ul> <li>b. Dificuldade de configura\u00e7\u00e3o e manuten\u00e7\u00e3o.</li> </ul> <p>O livro trata da manuten\u00e7\u00e3o como uma consequ\u00eancia de outros problemas (como acoplamento excessivo e duplica\u00e7\u00e3o de c\u00f3digo), mas n\u00e3o afirma que os dubl\u00eas s\u00e3o dif\u00edceis de configurar por si s\u00f3. Pelo contr\u00e1rio, Configurable Test Doubles s\u00e3o justamente uma solu\u00e7\u00e3o para facilitar isso. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 558)</p> <ul> <li>c. Incapacidade de simular comportamentos complexos.</li> </ul> <p>N\u00e3o \u00e9 mencionado como limita\u00e7\u00e3o. Pelo contr\u00e1rio, mocks e fakes s\u00e3o usados justamente para simular comportamentos complexos e dif\u00edceis de reproduzir com o objeto real. (p. 544, 551, Meszaros, 2007)</p> <ul> <li>d. Modifica\u00e7\u00e3o excessiva do c\u00f3digo de produ\u00e7\u00e3o.</li> </ul> <p>O livro recomenda pr\u00e1ticas como Dependency Injection para evitar altera\u00e7\u00f5es desnecess\u00e1rias no c\u00f3digo de produ\u00e7\u00e3o, ou seja, altera\u00e7\u00f5es s\u00e3o uma solu\u00e7\u00e3o e n\u00e3o um problema causado por dubl\u00eas. (p. 678\u2013682, Meszaros, 2007)</p> <p>Refer\u00eancia: Meszaros, G. (2007). xUnit Test Patterns: Refactoring Test Code. Addison-Wesley.</p>"},{"location":"tpi_tpe/tpi4_tpe4/#q09-qual-e-o-ciclo-repetido-no-processo-de-tdd","title":"Q09. Qual \u00e9 o ciclo repetido no processo de TDD?","text":"<ul> <li>a. Teste passa \u2192 implementa\u00e7\u00e3o \u2192 refatora\u00e7\u00e3o</li> <li>b. Teste falha \u2192 implementa\u00e7\u00e3o \u2192 refatora\u00e7\u00e3o</li> <li>c. Implementa\u00e7\u00e3o \u2192 teste passa \u2192 refatora\u00e7\u00e3o</li> <li>d. Refatora\u00e7\u00e3o \u2192 teste falha \u2192 implementa\u00e7\u00e3o</li> </ul> <p>RESPOSTA: b. Teste falha \u2192 implementa\u00e7\u00e3o \u2192 refatora\u00e7\u00e3o</p> <p>O ciclo geral do TDD \u00e9 o seguinte: 1. Escreva um teste. 2. Fa\u00e7a com que ele funcione. Colocar a barra verde rapidamente domina tudo. 3. Fa\u00e7a certo. Agora que o sistema se comporta, remova duplica\u00e7\u00f5es. (Cap\u00edtulo 2, Beck, 2002) </p> <p>Lembre-se, o ciclo \u00e9 o seguinte: Adicione um pequeno teste. Execute todos os testes e veja falhar. Fa\u00e7a uma pequena mudan\u00e7a. Execute todos os testes e veja passar. Refatore para remover duplica\u00e7\u00f5es. (Cap\u00edtulo 1, Beck, 2002) </p> <p>TDD responde \u00e0 contradi\u00e7\u00e3o com um paradoxo \u2014 teste o programa antes de escrev\u00ea-lo. (Introdu\u00e7\u00e3o, Beck, 2002) </p>"},{"location":"tpi_tpe/tpi4_tpe4/#por-que-as-outras-alternativas-estao-erradas_8","title":"Por que as outras alternativas est\u00e3o erradas","text":"<ul> <li>a. Teste passa \u2192 implementa\u00e7\u00e3o \u2192 refatora\u00e7\u00e3o</li> </ul> <p>Isso inverte a ordem correta, j\u00e1 que o teste precisa falhar primeiro para guiar a implementa\u00e7\u00e3o.</p> <ul> <li>c. Implementa\u00e7\u00e3o \u2192 teste passa \u2192 refatora\u00e7\u00e3o</li> </ul> <p>Esta \u00e9 a abordagem tradicional, mas n\u00e3o \u00e9 TDD, pois ignora a cria\u00e7\u00e3o do teste antes da implementa\u00e7\u00e3o.</p> <ul> <li>d. Refatora\u00e7\u00e3o \u2192 teste falha \u2192 implementa\u00e7\u00e3o</li> </ul> <p>Tamb\u00e9m est\u00e1 fora da ordem. A refatora\u00e7\u00e3o vem depois que os testes est\u00e3o passando.</p> <p>Refer\u00eancia: Beck, K. (2002). Test-Driven Development: By Example. Addison-Wesley.</p>"},{"location":"tpi_tpe/tpi4_tpe4/#q10-por-que-o-tdd-facilita-a-identificacao-de-problemas","title":"Q10. Por que o TDD facilita a identifica\u00e7\u00e3o de problemas?","text":"<ul> <li>a. Porque desenvolvedores escrevem c\u00f3digo antes dos testes.</li> <li>b. Porque desenvolvedores focam no produto final.</li> <li>c. Porque todos os testes s\u00e3o escritos antes da implementa\u00e7\u00e3o.</li> <li>d. Porque o ciclo incremental permite detectar problemas ap\u00f3s pequenas altera\u00e7\u00f5es.</li> </ul> <p>RESPOSTA: d. Porque o ciclo incremental permite detectar problemas ap\u00f3s pequenas altera\u00e7\u00f5es.</p> <p>O processo de desenvolvimento orientado a testes (TDD) incentiva a \"escrever um teste e depois \"escrever algum c\u00f3digo para fazer esse teste passar. Esse processo n\u00e3o envolve escrever todos os testes antes de qualquer c\u00f3digo, mas sim escrever testes e c\u00f3digo de forma intercalada em passos muito pequenos. (Cap\u00edtulo 4, Meszaros, 2007) </p> <p>Isso \u00e9 desenvolvimento incremental no seu melhor. Muitos adeptos do TDD relatam que raramente usam o depurador, porque os testes em pequenas etapas localizam claramente o defeito e a \u00faltima altera\u00e7\u00e3o feita (que causou o problema) ainda est\u00e1 fresca na mem\u00f3ria. (Cap\u00edtulo 4, Meszaros, 2007) </p> <p>Lembre-se, o ciclo \u00e9 o seguinte: 1. Adicione um pequeno teste. 2. Execute todos os testes e veja falhar. 3. Fa\u00e7a uma pequena mudan\u00e7a. 4. Execute todos os testes e veja passar. 5. Refatore para remover duplica\u00e7\u00f5es.  </p> <p>O TDD permite que qualquer desenvolvedor escreva c\u00f3digo confi\u00e1vel e livre de erros, n\u00e3o importa o qu\u00e3o complexo ele seja. O desenvolvimento com testes automatizados e elimina\u00e7\u00e3o de duplica\u00e7\u00f5es encoraja mudan\u00e7as pequenas e constantes, facilitando identificar o que quebrou e quando. (Introdu\u00e7\u00e3o, Beck, 2002) </p>"},{"location":"tpi_tpe/tpi4_tpe4/#por-que-as-outras-alternativas-estao-erradas_9","title":"Por que as outras alternativas est\u00e3o erradas","text":"<ul> <li>a. Porque desenvolvedores escrevem c\u00f3digo antes dos testes.</li> </ul> <p>Falso. TDD prop\u00f5e exatamente o contr\u00e1rio: escrevemos o teste antes do c\u00f3digo. (Introdu\u00e7\u00e3o, Beck, 2002)</p> <ul> <li>b. Porque desenvolvedores focam no produto final.</li> </ul> <p>O foco est\u00e1 no comportamento incremental e test\u00e1vel, n\u00e3o no \"produto final\". (Cap\u00edtulo 4, Meszaros, 2007)</p> <ul> <li>c. Porque todos os testes s\u00e3o escritos antes da implementa\u00e7\u00e3o.</li> </ul> <p>N\u00e3o \u00e9 verdade. O TDD escreve um teste de cada vez, intercalado com c\u00f3digo. (Cap\u00edtulo 4, Meszaros, 2007)</p> <p>Refer\u00eancias: Beck, K. (2002). Test-Driven Development: By Example. Addison-Wesley. Meszaros, G. (2007). xUnit Test Patterns: Refactoring Test Code. Addison-Wesley.</p>"},{"location":"tpi_tpe/tpi4_tpe4/#q11-como-o-tdd-afeta-o-design","title":"Q11. Como o TDD afeta o design?","text":"<ul> <li>a. Testes n\u00e3o influenciam o design.</li> <li>b. O teste \u00e9 o primeiro cliente da classe, influenciando seu design.</li> <li>c. TDD encoraja designs mais complexos.</li> <li>d. TDD desencoraja refatora\u00e7\u00e3o.</li> </ul> <p>RESPOSTA: b. O teste \u00e9 o primeiro cliente da classe, influenciando seu design.</p> <p>O TDD incentiva designs simples e conjuntos de testes que inspiram confian\u00e7a. (Introdu\u00e7\u00e3o, Beck, 2002) </p> <p>Voc\u00ea escrever\u00e1 um teste. Imagine como gostaria que a opera\u00e7\u00e3o parecesse em seu c\u00f3digo. Voc\u00ea est\u00e1 escrevendo uma hist\u00f3ria. Invente a interface que gostaria de ter. (Cap\u00edtulo 2, Beck, 2002) </p> <p>Como resultado, o teste se torna o primeiro cliente da classe, moldando seu design de forma natural, orientada por uso real. (Cap\u00edtulo 17, Beck, 2002) </p> <p>Cres\u00e7a o design organicamente, por meio de refatora\u00e7\u00f5es, adicionando decis\u00f5es de design uma de cada vez. (Introdu\u00e7\u00e3o, Beck, 2002) </p>"},{"location":"tpi_tpe/tpi4_tpe4/#por-que-as-outras-alternativas-estao-erradas_10","title":"Por que as outras alternativas est\u00e3o erradas","text":"<ul> <li>a. Testes n\u00e3o influenciam o design.</li> </ul> <p>Falso. O TDD molda o design desde o in\u00edcio, com o teste sendo o primeiro cliente da API. (Cap\u00edtulo 17, Beck, 2002)</p> <ul> <li>c. TDD encoraja designs mais complexos.</li> </ul> <p>Pelo contr\u00e1rio, TDD incentiva designs simples e incrementais. (Introdu\u00e7\u00e3o, Beck, 2002)</p> <ul> <li>d. TDD desencoraja refatora\u00e7\u00e3o.</li> </ul> <p>Falso. Refatora\u00e7\u00e3o \u00e9 uma das etapas essenciais do ciclo TDD. (Cap\u00edtulo 2, Beck, 2002)</p> <p>Refer\u00eancia: Beck, K. (2002). Test-Driven Development: By Example. Addison-Wesley.</p>"},{"location":"tpi_tpe/tpi4_tpe4/#q12-quando-o-tdd-e-mais-vantajoso","title":"Q12. Quando o TDD \u00e9 mais vantajoso?","text":"<ul> <li>a. Em problemas simples.</li> <li>b. Em qualquer tipo de problema.</li> <li>c. Em projetos de manuten\u00e7\u00e3o.</li> <li>d. Em problemas mais complicados, onde ajuda a estruturar melhor o desenvolvimento.</li> </ul> <p>RESPOSTA: d. Em problemas mais complicados, onde ajuda a estruturar melhor o desenvolvimento.</p> <p>Desenvolvedores enfrentam desafios complexos de programa\u00e7\u00e3o todos os dias, e muitas vezes n\u00e3o est\u00e3o preparados para determinar a melhor solu\u00e7\u00e3o. Com frequ\u00eancia, tais projetos dif\u00edceis geram muito estresse e c\u00f3digo ruim. Para obter a for\u00e7a e a coragem necess\u00e1rias para superar tarefas aparentemente herc\u00faleas, os programadores devem recorrer ao desenvolvimento orientado por testes (TDD), um conjunto comprovado de t\u00e9cnicas que encorajam designs simples e test suites que inspiram confian\u00e7a. (Introdu\u00e7\u00e3o, Beck, 2002) </p> <p>Ao conduzir o desenvolvimento com testes automatizados e depois eliminar duplica\u00e7\u00e3o, qualquer desenvolvedor pode escrever c\u00f3digo confi\u00e1vel e livre de erros, independentemente do n\u00edvel de complexidade. (Introdu\u00e7\u00e3o, Beck, 2002) </p> <p>Os leitores aprender\u00e3o a: - Resolver tarefas complicadas, come\u00e7ando pelas simples e seguindo para as mais complexas. - Escrever testes automatizados antes de codificar. - Criar testes para l\u00f3gica complicada, incluindo reflex\u00e3o e exce\u00e7\u00f5es. (Introdu\u00e7\u00e3o, Beck, 2002) </p> <p>Refer\u00eancia: Beck, K. (2002). Test-Driven Development: By Example. Addison-Wesley.</p>"},{"location":"tpi_tpe/tpi4_tpe4/#q13-em-quais-situacoes-o-uso-do-tdd-nao-e-recomendado","title":"Q13. Em quais situa\u00e7\u00f5es o uso do TDD n\u00e3o \u00e9 recomendado?","text":"<ul> <li>a. Quando o problema \u00e9 bem conhecido e n\u00e3o h\u00e1 necessidade de experimenta\u00e7\u00e3o.</li> <li>b. Quando se est\u00e1 em projetos \u00e1geis.</li> <li>c. Em sistemas embarcados.</li> <li>d. Quando a pir\u00e2mide de testes n\u00e3o \u00e9 aplicada.</li> </ul> <p>RESPOSTA: a. Quando o problema \u00e9 bem conhecido e n\u00e3o h\u00e1 necessidade de experimenta\u00e7\u00e3o.</p> <p>O desenvolvimento orientado a testes (TDD) \u00e9 especialmente \u00fatil em situa\u00e7\u00f5es em que n\u00e3o temos certeza de como estruturar a solu\u00e7\u00e3o ou estamos lidando com um problema desconhecido. (Cap\u00edtulo 2, Beck, 2002) </p> <p>Em contrapartida, quando j\u00e1 sabemos exatamente o que fazer e a estrutura do sistema est\u00e1 clara, o valor de escrever testes antes do c\u00f3digo \u00e9 reduzido. (Cap\u00edtulo 2, Beck, 2002) </p> <p>Em projetos onde \u00e9 necess\u00e1rio explorar o design, o ciclo de TDD ajuda a conduzir decis\u00f5es incrementais e iterativas. (Cap\u00edtulo 2, Beck, 2002) </p>"},{"location":"tpi_tpe/tpi4_tpe4/#por-que-as-outras-alternativas-estao-erradas_11","title":"Por que as outras alternativas est\u00e3o erradas","text":"<ul> <li>b. Quando se est\u00e1 em projetos \u00e1geis.</li> </ul> <p>TDD \u00e9 altamente recomendado em projetos \u00e1geis, pois favorece ciclos curtos de feedback e adapta\u00e7\u00e3o cont\u00ednua. (Cap\u00edtulo 1, Beck, 2002)</p> <ul> <li> <p>c. Em sistemas embarcados.</p> </li> <li> <p>d. Quando a pir\u00e2mide de testes n\u00e3o \u00e9 aplicada.</p> </li> </ul> <p>A pir\u00e2mide de testes \u00e9 uma pr\u00e1tica auxiliar, n\u00e3o uma condi\u00e7\u00e3o para aplicar TDD. O TDD foca na escrita de testes automatizados de unidade, independentemente da estrutura completa de testes adotada.  </p> <p>Refer\u00eancia: Beck, K. (2002). Test-Driven Development: By Example. Addison-Wesley.</p>"},{"location":"tpi_tpe/tpi4_tpe4/#q14-qual-a-eficacia-dos-testes-em-tdd","title":"Q14. Qual a efic\u00e1cia dos testes em TDD?","text":"<ul> <li>a. As su\u00edtes de TDD s\u00e3o superiores \u00e0s su\u00edtes sistem\u00e1ticas em v\u00e1rios aspectos.</li> <li>b. As su\u00edtes s\u00e3o equivalentes.</li> <li>c. S\u00e3o inferiores apenas em projetos pequenos.</li> <li>d. TDD foca em desenvolvimento e n\u00e3o gera testes eficazes.</li> </ul> <p>RESPOSTA: a. As su\u00edtes de TDD s\u00e3o superiores \u00e0s su\u00edtes sistem\u00e1ticas em v\u00e1rios aspectos.</p> <p>O TDD \u00e9 uma das pr\u00e1ticas centrais dos m\u00e9todos \u00e1geis, como o XP. Seu uso de testes automatizados se concentra mais na especifica\u00e7\u00e3o do comportamento do software ainda n\u00e3o escrito do que em testes de regress\u00e3o. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 33) </p> <p>A efic\u00e1cia do TDD vem da forma como ele nos permite separar o pensamento sobre o software em duas fases: o que ele deve fazer, e como ele deve fazer. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 33) </p> <p>Quando implementamos a funcionalidade de forma incremental, podemos ver cada teste passar, um por um, \u00e0 medida que escrevemos mais c\u00f3digo. \u00c9 aqui que reside o verdadeiro valor dos testes automatizados: na sua capacidade de fixar o comportamento esperado, garantindo que mudan\u00e7as posteriores n\u00e3o o modifiquem acidentalmente. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 33) </p> <p>O TDD permite a cria\u00e7\u00e3o de especifica\u00e7\u00f5es execut\u00e1veis, que n\u00e3o apenas guiam o design como tamb\u00e9m servem de documenta\u00e7\u00e3o viva e confi\u00e1vel do sistema. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 33) </p>"},{"location":"tpi_tpe/tpi4_tpe4/#por-que-as-outras-alternativas-estao-erradas_12","title":"Por que as outras alternativas est\u00e3o erradas","text":"<ul> <li>b. As su\u00edtes s\u00e3o equivalentes.</li> </ul> <p>O livro indica explicitamente que os testes em TDD t\u00eam papel mais amplo e profundo, tanto em design quanto em valida\u00e7\u00e3o \u2014 n\u00e3o sendo \"equivalentes\", mas sim mais eficazes em v\u00e1rios aspectos. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 33)</p> <ul> <li> <p>c. S\u00e3o inferiores apenas em projetos pequenos.</p> </li> <li> <p>d. TDD foca em desenvolvimento e n\u00e3o gera testes eficazes.</p> </li> </ul> <p>TDD produz testes eficazes, que funcionam como especifica\u00e7\u00f5es automatizadas e garantem confiabilidade cont\u00ednua do sistema. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 33)</p> <p>Refer\u00eancia: Meszaros, G. (2007). xUnit Test Patterns: Refactoring Test Code. Addison-Wesley.</p>"}]}