{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#testes-de-software-20251","title":"Testes de Software (2025.1)","text":"<p>Documenta\u00e7\u00e3o pessoal sobre Testes de Software, desenvolvida como apoio aos estudos da disciplina cursada na gradua\u00e7\u00e3o em Engenharia de Software.</p> <ul> <li>xUnit Test Patterns (Meszaros, 2007)</li> <li>Test-Driven Development: By Example (Kent Beck, 2002)</li> <li>The Art of Software Testing (Glenford J. Myers, 2011)</li> </ul>"},{"location":"aae3/aae3/","title":"1. Relat\u00f3rio de Cobertura MC/DC \u2014 Atividade AAE-3","text":""},{"location":"aae3/aae3/#11-objetivo","title":"1.1 Objetivo","text":"<p>Elaborar o menor conjunto de casos de teste que garanta 100% de cobertura segundo o crit\u00e9rio MC/DC para o m\u00e9todo <code>isNumber(String number)</code> abaixo:</p> <pre><code>public boolean isNumber(String number) {\n    if (number == null || number.isEmpty()) {\n        return false;\n    }\n\n    if (number.length() == 1 &amp;&amp; (number.charAt(0) == '-' || number.charAt(0) == '+')) {\n        return false;\n    }\n\n    for (int i = 0; i &lt; number.length(); i++) {\n        char c = number.charAt(i);\n\n        if (i == 0 &amp;&amp; (c == '-' || c == '+')) {\n            continue;\n        } else if (!Character.isDigit(c)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n</code></pre>"},{"location":"aae3/aae3/#12-recapitulando-mcdc","title":"1.2 Recapitulando MC/DC","text":"<p>MC/DC (Cobertura de Decis\u00e3o/Condi\u00e7\u00e3o Modificada) \u00e9 uma t\u00e9cnica de teste que exige:</p> <ol> <li>Que cada condi\u00e7\u00e3o booleana dentro de uma decis\u00e3o seja avaliada como verdadeira e falsa.</li> <li>Que, para cada condi\u00e7\u00e3o, seja demonstrado que ela, isoladamente, pode alterar o resultado da decis\u00e3o.</li> </ol>"},{"location":"aae3/aae3/#exemplo-if-a-b","title":"Exemplo: <code>if (A &amp;&amp; B)</code>","text":"Caso A B Resultado O que muda? D-Ex-T1 F V F Base para testar A D-Ex-T2 V V V (B = V; A muda F \u2192 V; resultado muda F \u2192 V) \u2713 D-Ex-T3 V F F Base para testar B D-Ex-T4 V V V (A = V; B muda F \u2192 V; resultado muda F \u2192 V) \u2713"},{"location":"aae3/aae3/#decisoes-validas-em-mcdc","title":"Decis\u00f5es v\u00e1lidas em MC/DC","text":"<p>Uma decis\u00e3o v\u00e1lida \u00e9 qualquer express\u00e3o booleana que:</p> <ul> <li>Controle o fluxo (<code>if</code>, <code>while</code>, <code>for</code>, <code>else if</code> etc.).</li> <li>Seja composta por duas ou mais condi\u00e7\u00f5es ligadas por <code>&amp;&amp;</code> ou <code>||</code>.</li> <li>Permita que cada condi\u00e7\u00e3o, isoladamente, altere o resultado.</li> </ul> <p>Nota:</p> <ul> <li>Condi\u00e7\u00f5es de la\u00e7o sem m\u00faltiplas vari\u00e1veis (ex.: <code>i &lt; n</code> em <code>for</code>) n\u00e3o precisam de MC/DC.</li> </ul>"},{"location":"aae3/aae3/#2-primeira-decisao-linha-2","title":"2. Primeira decis\u00e3o (linha 2)","text":"<pre><code>if (number == null || number.isEmpty()) {\n    return false;\n}\n</code></pre> <ul> <li>C1: <code>number == null</code></li> <li>C2: <code>number.isEmpty()</code></li> </ul>"},{"location":"aae3/aae3/#estrutura-logica","title":"Estrutura l\u00f3gica","text":"<pre><code>C1 || C2\n</code></pre> <p>Se a string for nula ou estiver vazia, retorna false</p>"},{"location":"aae3/aae3/#tabela-verdade-de-c1-c2","title":"Tabela-verdade de <code>C1 || C2</code>","text":"Caso C1 C2 Resultado D1-T1 F F F D1-T2 F V V D1-T3 V F V D1-T4 V V V"},{"location":"aae3/aae3/#pares-mcdc","title":"Pares MC/DC","text":"<ul> <li>C1: (C2 = F; C1 muda F \u2192 V; resultado muda F \u2192 V) \u2014 D1-T1 vs D1-T3</li> <li>C2: (C1 = F; C2 muda F \u2192 V; resultado muda F \u2192 V) \u2014 D1-T1 vs D1-T2</li> </ul>"},{"location":"aae3/aae3/#3-segunda-decisao-linha-5","title":"3. Segunda decis\u00e3o (linha 5)","text":"<pre><code>if (number.length() == 1 &amp;&amp; (number.charAt(0) == '-' || number.charAt(0) == '+')) {\n    return false;\n}\n</code></pre> <ul> <li>C3: <code>number.length() == 1</code></li> <li>C4: <code>number.charAt(0) == '-'</code></li> <li>C5: <code>number.charAt(0) == '+'</code></li> </ul>"},{"location":"aae3/aae3/#estrutura-logica_1","title":"Estrutura l\u00f3gica","text":"<pre><code>C3 &amp;&amp; (C4 || C5)\n</code></pre> <p>Se h\u00e1 um caractere e ele \u00e9 \u2018-\u2019 ou \u2018+\u2019, retorna false</p>"},{"location":"aae3/aae3/#tabela-verdade-de-c3-c4-c5","title":"Tabela-verdade de <code>C3 &amp;&amp; (C4 || C5)</code>","text":"Caso C3 C4 C5 Resultado D2-T1 V V F V D2-T2 V F V V D2-T3 V F F F D2-T4 F \u2013 \u2013 F"},{"location":"aae3/aae3/#pares-mcdc_1","title":"Pares MC/DC","text":"<ul> <li>C3: (C4 = V; C5 = F; C3 muda V \u2192 F; resultado muda V \u2192 F) \u2014 D2-T1 vs D2-T4</li> <li>C4: (C3 = V; C5 = F; C4 muda V \u2192 F; resultado muda V \u2192 F) \u2014 D2-T1 vs D2-T3</li> <li>C5: (C3 = V; C4 = F; C5 muda V \u2192 F; resultado muda V \u2192 F) \u2014 D2-T2 vs D2-T3</li> </ul>"},{"location":"aae3/aae3/#4-terceira-decisao-linha-10","title":"4. Terceira decis\u00e3o (linha 10)","text":"<pre><code>if (i == 0 &amp;&amp; (c == '-' || c == '+')) {\n    continue;\n}\n</code></pre> <ul> <li>C6: <code>i == 0</code></li> <li>C7: <code>c == '-'</code></li> <li>C8: <code>c == '+'</code></li> </ul>"},{"location":"aae3/aae3/#estrutura-logica_2","title":"Estrutura l\u00f3gica","text":"<pre><code>C6 &amp;&amp; (C7 || C8)\n</code></pre> <p>Se \u00e9 o primeiro caractere e ele \u00e9 \u2018-\u2019 ou \u2018+\u2019, ignora e segue</p>"},{"location":"aae3/aae3/#tabela-verdade-de-c6-c7-c8","title":"Tabela-verdade de <code>C6 &amp;&amp; (C7 || C8)</code>","text":"Caso C6 C7 C8 Resultado D3-T1 F \u2013 \u2013 F D3-T2 V V F V D3-T3 V F V V D3-T4 V F F F"},{"location":"aae3/aae3/#pares-mcdc_2","title":"Pares MC/DC","text":"<ul> <li>C6: (C7 = V; C8 = F; C6 muda F \u2192 V; resultado muda F \u2192 V) \u2014 D3-T1 vs D3-T2</li> <li>C7: (C6 = V; C8 = F; C7 muda V \u2192 F; resultado muda V \u2192 F) \u2014 D3-T2 vs D3-T4</li> <li>C8: (C6 = V; C7 = F; C8 muda V \u2192 F; resultado muda V \u2192 F) \u2014 D3-T3 vs D3-T4</li> </ul>"},{"location":"aae3/aae3/#5-resumo-dos-pares-mcdc","title":"5. Resumo dos pares MC/DC","text":"<ul> <li>Decis\u00e3o 1 (C1, C2): D1-T1 vs D1-T3; D1-T1 vs D1-T2</li> <li>Decis\u00e3o 2 (C3, C4, C5): D2-T1 vs D2-T4; D2-T1 vs D2-T3; D2-T2 vs D2-T3</li> <li>Decis\u00e3o 3 (C6, C7, C8): D3-T1 vs D3-T2; D3-T2 vs D3-T4; D3-T3 vs D3-T4</li> </ul>"},{"location":"aae3/aae3/#6-conclusao","title":"6. Conclus\u00e3o","text":"<p>Com o conjunto de 12 casos de teste (D1-T1 a D1-T4, D2-T1 a D2-T4 e D3-T1 a D3-T4), cada condi\u00e7\u00e3o C1\u2013C8 foi avaliada como verdadeira e falsa e demonstrou, isoladamente, sua capacidade de alterar o resultado da decis\u00e3o. Assim, alcan\u00e7amos 100% de cobertura segundo o crit\u00e9rio MC/DC para o m\u00e9todo <code>isNumber</code>.</p>"},{"location":"aae3/aae3/#7-referencias-bibliograficas","title":"7. Refer\u00eancias Bibliogr\u00e1ficas","text":"<ol> <li>Myers, G. J., Sandler, C., &amp; Badgett, T. (2011). The Art of Software Testing (3rd ed.). Wiley. pp. 46\u201348.</li> <li>RTCA/DO-178C. (2011). Software Considerations in Airborne Systems and Equipment Certification. RTCA.</li> <li>ISO/IEC/IEEE 29119. (2013). Software and Systems Engineering \u2014 Software Testing. ISO/IEC/IEEE.</li> </ol>"},{"location":"aae3/mc_dc/","title":"Modified Condition/Decision Coverage (MC/DC)","text":"<p>O Modified Condition/Decision Coverage (MC/DC) \u00e9 um dos crit\u00e9rios de cobertura estrutural mais exigentes para software de alta criticidade (por exemplo: avia\u00e7\u00e3o, automotivo, ferrovi\u00e1rio, etc.). O MC/DC est\u00e1 definido na norma DO-178B/C da FAA e \u00e9 referenciado em normas como ISO 26262 (automotiva) e IEC 61508 (industrial). Uma apresenta\u00e7\u00e3o detalhada pode ser encontrada em Hayhurst et al. (2001).</p> <p>Veja uma explica\u00e7\u00e3o pr\u00e1tica e visual no v\u00eddeo a seguir:</p>"},{"location":"aae3/mc_dc/#1-definicao-formal","title":"1. Defini\u00e7\u00e3o Formal","text":"<p>De acordo com o DO-178C </p> <p>O MC/DC requer que, para cada decis\u00e3o (uma express\u00e3o booleana composta) no c\u00f3digo, sejam atendidos simultaneamente:</p> <ol> <li>Cada ponto de entrada e sa\u00edda seja invocado ao menos uma vez.</li> <li>A decis\u00e3o tome cada um de seus poss\u00edveis resultados (verdadeiro/falso).</li> <li>Cada condi\u00e7\u00e3o atinja cada valor (verdadeiro/falso) ao menos uma vez.</li> <li>Cada condi\u00e7\u00e3o seja mostrada como tendo influ\u00eancia independente sobre o resultado da decis\u00e3o, mudando-a quando somente ela for invertida, mantendo-se fixas todas as demais.</li> </ol> <p>O item 4 \u00e9 o que diferencia o MC/DC: deve-se provar que apenas invertendo uma condi\u00e7\u00e3o \u2014 sem alterar as demais \u2014 o resultado da decis\u00e3o tamb\u00e9m inverte.</p>"},{"location":"aae3/mc_dc/#2-exemplo-pratico","title":"2. Exemplo Pr\u00e1tico","text":"<p>Considere a decis\u00e3o:</p> <pre><code>D = A &amp;&amp; B &amp;&amp; C\n</code></pre> Caso A B C D = A\u2227B\u2227C 1 True True True True 2 True True False False 3 True False True False 4 True False False False 5 False True True False 6 False True False False 7 False False True False 8 False False False False <p>Para atingir 100\u202f% de MC/DC, al\u00e9m de cobrir as condi\u00e7\u00f5es e decis\u00f5es, precisamos demonstrar a independ\u00eancia de cada condi\u00e7\u00e3o.</p>"},{"location":"aae3/mc_dc/#21-independencia-de-a","title":"2.1. Independ\u00eancia de A","text":"<p>Mant\u00e9m B = True e C = True, varia apenas A:</p> Caso A B C D = A\u2227B\u2227C 1 True True True True 5 False True True False"},{"location":"aae3/mc_dc/#22-independencia-de-b","title":"2.2. Independ\u00eancia de B","text":"<p>Mant\u00e9m A = True e C = True, varia apenas B:</p> Caso A B C D = A\u2227B\u2227C 1 True True True True 3 True False True False"},{"location":"aae3/mc_dc/#23-independencia-de-c","title":"2.3. Independ\u00eancia de C","text":"<p>Mant\u00e9m A = True e B = True, varia apenas C:</p> Caso A B C D = A\u2227B\u2227C 1 True True True True 2 True True False False"},{"location":"aae3/mc_dc/#3-vantagens-e-aplicacoes","title":"3. Vantagens e Aplica\u00e7\u00f5es","text":"<ul> <li>Redu\u00e7\u00e3o de riscos: garante que cada condi\u00e7\u00e3o individualmente impacta o resultado, revelando erros mascarados.</li> <li>Requisito normativo: n\u00edvel A em avia\u00e7\u00e3o exige 100\u202f% MC/DC (DO-178C, Tabela A-7); tamb\u00e9m recomendado para SIL\u202f4 (IEC\u00a061508) e ASIL\u202fD (ISO\u00a026262).</li> <li>Efici\u00eancia: exige menos testes que a cobertura de todas as combina\u00e7\u00f5es (Multiple Condition Coverage), mantendo rigor.</li> </ul>"},{"location":"aae3/mc_dc/#4-referencias-bibliograficas","title":"4. Refer\u00eancias Bibliogr\u00e1ficas","text":"<ol> <li>Kelly\u00a0J. Hayhurst, Dan\u00a0S. Veerhusen, John\u00a0D. Chilenski e Leanna\u00a0R. Rierson. A Practical Tutorial on Modified Condition/Decision Coverage, NASA TM-2001-210876, 2001.</li> <li>FAA. Guidelines for the Use of the Modified Condition/Decision Coverage (MC/DC) Criterion, CAST-10, 2020.</li> <li>RTCA/DO-178C. Software Considerations in Airborne Systems and Equipment Certification, 2011.</li> <li>ISO\u00a026262:2011. Road vehicles \u2013 Functional safety, Parte\u00a06.</li> <li>IEC\u00a061508-3:2010. Functional safety of electrical/electronic/programmable electronic safety-related systems, Anexo\u00a0B.</li> <li>Myers, G. J., Sandler, C., &amp; Badgett, T. (2011). The Art of Software Testing (3rd ed.). Wiley. pp. 46\u201348.</li> </ol>"},{"location":"aae3/unit_test/","title":"Teste de Unidade","text":""},{"location":"aae3/unit_test/#3-piramide-de-testes","title":"3. Pir\u00e2mide de Testes","text":"<p>A Pir\u00e2mide de Testes ilustra como equilibrar velocidade, custo e cobertura ao estruturar sua su\u00edte de testes (Meszaros, 2007):</p> <p></p> N\u00edvel Quantidade de Testes Custo por Teste Velocidade de Execu\u00e7\u00e3o Exemplos de Ferramentas Aceita\u00e7\u00e3o Baixa Alto Muito Lenta Cucumber, Robot Framework Sistema M\u00e9dia M\u00e9dio Lenta Selenium, TestComplete Integra\u00e7\u00e3o M\u00e9dia\u2013Alta Baixo\u2013M\u00e9dio Moderada Pytest + Docker Compose, Postman Unidade Alta Baixo Muito R\u00e1pida pytest, unittest, Jest <ul> <li>Unidade (base) </li> <li>O que: Testes de fun\u00e7\u00e3o/m\u00e9todo isolado.  </li> <li>Por que: R\u00e1pidos e baratos; detectam defeitos de l\u00f3gica interna antes de integrar depend\u00eancias.  </li> <li>Integra\u00e7\u00e3o (camada intermedi\u00e1ria) </li> <li>O que: Testes de m\u00faltiplos m\u00f3dulos funcionando juntos (por exemplo, servi\u00e7o + banco de dados).  </li> <li>Por que: Verifica contratos/interfaces, detecta erros de comunica\u00e7\u00e3o e configura\u00e7\u00e3o.  </li> <li>Sistema (\u00faltima camada antes da aceita\u00e7\u00e3o) </li> <li>O que: Testes fim-a-fim que exercitam todo o sistema em ambiente real ou simulado.  </li> <li>Por que: Confirma fluxo completo (UI \u2192 backend \u2192 DB), mas custa mais manter.  </li> <li>Aceita\u00e7\u00e3o (topo) </li> <li>O que: Valida\u00e7\u00e3o contra requisitos de neg\u00f3cio por meio de cen\u00e1rios escritos em linguagem natural.  </li> <li>Por que: Garante que o software atenda \u00e0s expectativas do usu\u00e1rio, mas demora para rodar.</li> </ul> <p>Eixos - Velocidade: decresce de unidades \u2192 aceita\u00e7\u00e3o. - Custo: cresce de unidades \u2192 aceita\u00e7\u00e3o. - Quantidade: cresce de aceita\u00e7\u00e3o \u2192 unidades.</p>"},{"location":"aae3/unit_test/#4-outros-formatos-de-estrategia","title":"4. Outros Formatos de Estrat\u00e9gia","text":""},{"location":"aae3/unit_test/#a-the-testing-trophy","title":"A. The Testing Trophy","text":"<p>Desenvolvida por Kent C. Dodds para aplica\u00e7\u00f5es web modernas:</p> <p></p> <ul> <li>Static: detec\u00e7\u00e3o de erros sem execu\u00e7\u00e3o (ESLint, mypy).  </li> <li>Unit: l\u00f3gica interna (Jest, pytest).  </li> <li>Integration: contratos entre m\u00f3dulos (Testing Library, pytest-docker).  </li> <li>End to End: simula\u00e7\u00e3o completa de usu\u00e1rio (Cypress, Playwright).   <p>Meta: Keep static and unit tests em larga quantidade, reduzindo gradualmente at\u00e9 E2E (Dodds, 2020).</p> </li> </ul>"},{"location":"aae3/unit_test/#b-microservices-test-strategy","title":"B. Microservices Test Strategy","text":"<p>Abordagem do Spotify Labs para arquiteturas de microsservi\u00e7os:</p> <ol> <li>Implementation Detail: validar l\u00f3gica isolada de cada servi\u00e7o (testes de unidade profundas).  </li> <li>Integration: testar comunica\u00e7\u00e3o entre pares de servi\u00e7os (contratos de API).  </li> <li>Integrated: executar conjunto completo de microsservi\u00e7os simulando produ\u00e7\u00e3o (fluxos end-to-end).   <p>Recomenda\u00e7\u00e3o: minimizar testes de detalhe interno, focar em Integration e Integrated (Spotify Labs, 2019).</p> </li> </ol>"},{"location":"aae3/unit_test/#5-niveis-de-teste-beneficios","title":"5. N\u00edveis de Teste \u2013 Benef\u00edcios","text":"<ol> <li>Evita redund\u00e2ncia </li> <li>Cada n\u00edvel foca em diferentes categorias de defeitos (Myers et al., 2012).  </li> <li>Custo x Risco </li> <li>Detectar cedo (unidade) corrige barato; detectar tarde (aceita\u00e7\u00e3o) corrige caro.  </li> <li>Escalabilidade </li> <li>Pequenos projetos podem parar em integra\u00e7\u00e3o; projetos cr\u00edticos devem chegar \u00e0 aceita\u00e7\u00e3o.  </li> </ol>"},{"location":"aae3/unit_test/#6-niveis-de-teste-consideracoes","title":"6. N\u00edveis de Teste \u2013 Considera\u00e7\u00f5es","text":"<ul> <li>N\u00e3o s\u00e3o sequenciais: escolha n\u00edveis conforme risco, or\u00e7amento e complexidade do projeto.  </li> <li>Fatores a influenciar a estrat\u00e9gia: </li> <li>Grau de acoplamento e coes\u00e3o do sistema.  </li> <li>Frequ\u00eancia de mudan\u00e7as nos componentes.  </li> <li>Recursos de infraestrutura (tempo de build, ambientes de teste).  </li> </ul>"},{"location":"aae3/unit_test/#7-diagrama-de-correspondencia-de-niveis","title":"7. Diagrama de Correspond\u00eancia de N\u00edveis","text":""},{"location":"aae3/unit_test/#8-lista-de-niveis-de-teste","title":"8. Lista de N\u00edveis de Teste","text":"<ol> <li>Unidade \u2013 testar o menor bloco de c\u00f3digo isoladamente.  </li> <li>Integra\u00e7\u00e3o \u2013 validar a intera\u00e7\u00e3o entre m\u00f3dulos.  </li> <li>Fun\u00e7\u00e3o \u2013 foco em funcionalidades discretas, similar a testes de sistema menores.  </li> <li>Sistema \u2013 testes de ponta a ponta num ambiente completo.  </li> <li>Aceita\u00e7\u00e3o \u2013 valida\u00e7\u00e3o contra crit\u00e9rios de aceite do cliente.</li> </ol>"},{"location":"aae3/unit_test/#9-testes-de-unidade","title":"9. Testes de Unidade","text":"<p>Defini\u00e7\u00e3o (Myers, 2012): Processo de testar fun\u00e7\u00f5es, m\u00e9todos, procedimentos, sub-rotinas ou subprogramas individualmente, garantindo que cada unidade isolada se comporte conforme a especifica\u00e7\u00e3o.</p> <ul> <li>Objetivo: verificar o menor elemento test\u00e1vel de um software.  </li> <li>Procedural: fun\u00e7\u00e3o ou procedimento.  </li> <li>Orientado a objeto: m\u00e9todo de classe.  </li> <li>Respons\u00e1vel: geralmente o desenvolvedor.  </li> <li>Enfoque: algoritmos e l\u00f3gica de programa\u00e7\u00e3o.  </li> <li>T\u00e9cnicas: tipicamente caixa-branca, complementada por caixa-preta.</li> </ul> <p>Motiva\u00e7\u00f5es: - Gerenciar incrementalmente os elementos do teste. - Facilitar a depura\u00e7\u00e3o (localiza\u00e7\u00e3o de defeitos). - Permitir paralelismo na execu\u00e7\u00e3o dos testes.</p>"},{"location":"aae3/unit_test/#91-ferramentas-em-python","title":"9.1. Ferramentas em Python","text":"Ferramenta Caracter\u00edsticas Refer\u00eancia <code>unittest</code> Framework padr\u00e3o, estilo xUnit. Python Software Foundation (2024). <code>pytest</code> Sintaxe concisa, fixtures, parametriza\u00e7\u00e3o e plugins. pytest Documentation (2024). <code>coverage.py</code> Medi\u00e7\u00e3o de cobertura de c\u00f3digo. Ned Batchelder (2024)."},{"location":"aae3/unit_test/#92-exemplo-simples-funcao-is_even","title":"9.2. Exemplo Simples: Fun\u00e7\u00e3o <code>is_even</code>","text":"<pre><code># utils.py\ndef is_even(n: int) -&gt; bool:\n    \"\"\"\n    Retorna True se n for par, False caso contr\u00e1rio.\n    \"\"\"\n    return n % 2 == 0\n</code></pre>"},{"location":"aae3/unit_test/#921-testes-com-pytest","title":"9.2.1. Testes com <code>pytest</code>","text":"<pre><code># tests/test_utils.py\nimport pytest\nfrom utils import is_even\n\n@pytest.mark.parametrize(\"input,expected\", [\n    (0, True),\n    (1, False),\n    (2, True),\n    (99, False),\n])\ndef test_is_even(input, expected):\n    assert is_even(input) == expected\n</code></pre> <ul> <li>Casos de teste:</li> <li><code>0</code> \u2192 <code>True</code></li> <li><code>1</code> \u2192 <code>False</code></li> <li><code>2</code> \u2192 <code>True</code></li> <li><code>99</code> \u2192 <code>False</code></li> </ul>"},{"location":"aae3/unit_test/#922-teste-caixa-branca-cobertura-de-decisao","title":"9.2.2. Teste Caixa-Branca (Cobertura de Decis\u00e3o)","text":"<pre><code>def test_is_even_branches():\n    # testa tanto o ramo True quanto o ramo False\n    assert is_even(4) is True\n    assert is_even(5) is False\n</code></pre> <ul> <li>Com isso garantimos que ambas as sa\u00eddas (<code>True</code> e <code>False</code>) ocorram ao menos uma vez.</li> </ul>"},{"location":"aae3/unit_test/#93-criterios-de-cobertura","title":"9.3. Crit\u00e9rios de Cobertura","text":"Crit\u00e9rio Descri\u00e7\u00e3o Cobertura de decis\u00f5es Garante que <code>n % 2 == 0</code> avalie <code>True</code> e <code>False</code> Cobertura de instru\u00e7\u00f5es Garante execu\u00e7\u00e3o da \u00fanica linha da fun\u00e7\u00e3o <pre><code># Gerando relat\u00f3rio de cobertura\ncoverage run -m pytest &amp;&amp; coverage report -m\n</code></pre> <pre><code>Name           Stmts   Miss  Cover\n----------------------------------\nutils.py           3      0   100%\n</code></pre>"},{"location":"aae3/unit_test/#12-referencias-bibliograficas","title":"12. Refer\u00eancias Bibliogr\u00e1ficas","text":"<ul> <li>Myers, G. J., Sandler, C., &amp; Badgett, T. (2012). The Art of Software Testing. John Wiley &amp; Sons.  </li> <li>pytest Development Team. (2024). pytest documentation. Retrieved from https://docs.pytest.org/  </li> <li>Ned Batchelder. (2024). coverage.py documentation. Retrieved from https://coverage.readthedocs.io/  </li> <li>Meszaros, G. (2007). xUnit Test Patterns: Refactoring Test Code. Addison-Wesley.  </li> <li>Dodds, K. C. (2020). The Testing Trophy.  </li> <li>Spotify Labs. (2019). Microservices Test Strategy</li> </ul>"},{"location":"aae3/white_box_test/","title":"Cap\u00edtulo 4 \u2013  Teste de Caixa Branca","text":"<p>Outra estrat\u00e9gia de teste, o teste de caixa branca (ou orientado por l\u00f3gica), permite que voc\u00ea examine a estrutura interna do programa. Essa estrat\u00e9gia deriva dados de teste de um exame da l\u00f3gica do programa (e muitas vezes, infelizmente, negligenciando a especifica\u00e7\u00e3o).</p> <p>O objetivo neste ponto \u00e9 estabelecer, para esta estrat\u00e9gia, o teste de entrada an\u00e1logo ao exaustivo na abordagem de caixa preta. Fazer com que todas as instru\u00e7\u00f5es do programa sejam executadas pelo menos uma vez pode parecer ser a resposta, mas n\u00e3o \u00e9 dif\u00edcil mostrar que isso \u00e9 altamente inadequado. Sem insistir no ponto aqui, uma vez que esse assunto \u00e9 discutido com mais profundidade no Cap\u00edtulo 4, o an\u00e1logo geralmente \u00e9 considerado um teste de caminho exaustivo. Ou seja, se voc\u00ea executar, via casos de teste, todos os caminhos poss\u00edveis de controle fluem pelo programa, ent\u00e3o, possivelmente, o programa foi completamente testado.</p> <p>Existem duas falhas nesta afirma\u00e7\u00e3o, no entanto. Uma \u00e9 que o n\u00famero de caminhos l\u00f3gicos \u00fanicos atrav\u00e9s de um programa pode ser astronomicamente grande. Para ver isso, considere o programa trivial representado na Figura 2.1. O diagrama \u00e9 um gr\u00e1fico de fluxo de controle. Cada n\u00f3 ou c\u00edrculo representa um segmento de instru\u00e7\u00f5es que s\u00e3o executadas sequencialmente, possivelmente terminando com uma branching statement. Cada aresta ou arco representa uma transfer\u00eancia de controle (ramifica\u00e7\u00e3o) entre segmentos. O diagrama, ent\u00e3o, descreve um programa de 10 a 20 instru\u00e7\u00f5es que consiste em um loop DO que itera at\u00e9 20 vezes. Dentro do corpo do loop DO, h\u00e1 um conjunto de instru\u00e7\u00f5es IF aninhadas. Determinar o n\u00famero de caminhos l\u00f3gicos \u00fanicos \u00e9 o mesmo que determinar o n\u00famero total de maneiras \u00fanicas de se mover do ponto A para o ponto B (assumindo que todas as decis\u00f5es no programa s\u00e3o independentes umas das outras). Este n\u00famero \u00e9 aproximadamente 10\u00b9\u2074.</p> <p>FIGURA 2.1: Gr\u00e1fico de fluxo de controle de um pequeno programa.</p> <p>100 trilh\u00f5es. \u00c9 calculado a partir de 5\u00b2\u2070 + 5\u00b9\u2079 + ... + 5\u00b9, onde 5 \u00e9 o n\u00famero de caminhos atrav\u00e9s do corpo do loop. A maioria das pessoas tem dificuldade em visualizar esse n\u00famero, ent\u00e3o considere desta forma: se voc\u00ea pudesse escrever, executar e verificar um caso de teste a cada cinco minutos, levaria aproximadamente 1 bilh\u00e3o de anos para tentar todos os caminhos. Se voc\u00ea fosse 300 vezes mais r\u00e1pido, completando um teste uma vez por segundo, voc\u00ea poderia completar o trabalho em 3,2 milh\u00f5es de anos, dar ou tirar alguns anos bissextos e s\u00e9culos.</p> <p>\u00c9 claro que, em programas reais, todas as decis\u00f5es n\u00e3o s\u00e3o independentes de todas as outras decis\u00f5es, o que significa que o n\u00famero de caminhos de execu\u00e7\u00e3o poss\u00edveis seria um pouco menor. Por outro lado, os programas reais s\u00e3o muito maiores do que o programa simples representado na Figura 2.1. Portanto, testes exaustivos de caminho, como testes exaustivos de entrada, parecem ser impratic\u00e1veis, se n\u00e3o imposs\u00edveis.</p> <p>A segunda falha na afirma\u00e7\u00e3o \"teste de caminho exaustivo significa um teste completo\" \u00e9 que todos os caminhos em um programa podem ser testados, mas o programa ainda pode estar carregado de erros. Existem tr\u00eas explica\u00e7\u00f5es para isso.</p> <p>A primeira \u00e9 que um teste exaustivo de trajet\u00f3ria n\u00e3o garante, de forma alguma, que um programa corresponda \u00e0 sua especifica\u00e7\u00e3o. Por exemplo, se voc\u00ea fosse solicitado a escrever uma rotina de classifica\u00e7\u00e3o em ordem crescente, mas produzisse por engano uma rotina de classifica\u00e7\u00e3o em ordem decrescente, o teste de caminho exaustivo seria de pouco valor; o programa ainda tem um bug: \u00e9 o programa errado, pois n\u00e3o atende \u00e0 especifica\u00e7\u00e3o.</p> <p>Em segundo lugar, um programa pode estar incorreto devido a caminhos ausentes. O teste exaustivo de caminho, \u00e9 claro, n\u00e3o detectaria a aus\u00eancia de caminhos necess\u00e1rios.</p> <p>Terceiro, um teste de caminho exaustivo pode n\u00e3o revelar erros de confidencialidade de dados. Existem muitos exemplos de tais erros, mas um simples deve ser suficiente. Suponha que, em um programa, voc\u00ea tenha que comparar dois n\u00fameros para converg\u00eancia, isto \u00e9, para ver se a diferen\u00e7a entre os dois n\u00fameros \u00e9 menor do que algum valor predeterminado. Por exemplo, voc\u00ea pode escrever uma instru\u00e7\u00e3o Java IF como:</p> <pre><code>if (a - b &lt; c)\n    System.out.println(\"a - b &lt; c\");\n</code></pre> <p>Claro, a declara\u00e7\u00e3o cont\u00e9m um erro porque deveria comparar <code>c</code> com o valor absoluto de <code>a - b</code>. A detec\u00e7\u00e3o desse erro, no entanto, depende dos valores usados para <code>a</code> e <code>b</code>, e n\u00e3o seria necessariamente detectada apenas executando todos os caminhos do programa.</p> <p>Em conclus\u00e3o, embora o teste exaustivo de entrada seja superior ao teste de caminho exaustivo, nenhum deles se mostra \u00fatil porque ambos s\u00e3o invi\u00e1veis. Talvez, ent\u00e3o, existam maneiras de combinar elementos de teste de caixa preta e caixa branca para derivar uma estrat\u00e9gia de teste razo\u00e1vel, mas n\u00e3o herm\u00e9tica. Este assunto \u00e9 aprofundado no Cap\u00edtulo 4.</p>"},{"location":"aae3/white_box_test/#principios-de-teste-de-software","title":"Princ\u00edpios de teste de software","text":""},{"location":"aae3/white_box_test/#tabela-21-diretrizes-de-teste-de-programas","title":"Tabela 2.1 \u2013 Diretrizes de teste de programas","text":"N\u00ba Princ\u00edpio 1 Uma parte necess\u00e1ria de um caso de teste \u00e9 uma defini\u00e7\u00e3o da sa\u00edda ou resultado esperado. 2 Um programador deve evitar tentar testar seu pr\u00f3prio programa. 3 Uma organiza\u00e7\u00e3o de programa\u00e7\u00e3o n\u00e3o deve testar seus pr\u00f3prios programas. 4 Qualquer processo de teste deve incluir uma inspe\u00e7\u00e3o completa dos resultados de cada teste. 5 Os casos de teste devem ser gravados para condi\u00e7\u00f5es de entrada inv\u00e1lidas e inesperadas, bem como para aquelas que s\u00e3o v\u00e1lidas e esperadas. 6 Examinar um programa para ver se ele n\u00e3o faz o que deveria fazer \u00e9 apenas metade da batalha; a outra metade \u00e9 ver se o programa faz o que n\u00e3o deveria fazer. 7 Evite casos de teste descart\u00e1veis, a menos que o programa seja realmente um programa descart\u00e1vel. 8 N\u00e3o planeje um esfor\u00e7o de teste sob a suposi\u00e7\u00e3o t\u00e1cita de que nenhum erro ser\u00e1 encontrado. 9 A probabilidade da exist\u00eancia de mais erros em uma se\u00e7\u00e3o de um programa \u00e9 proporcional ao n\u00famero de erros j\u00e1 encontrados nessa se\u00e7\u00e3o. 10 O teste \u00e9 uma tarefa extremamente criativa e intelectualmente desafiadora. <p>Continuando com a premissa principal deste cap\u00edtulo, de que as considera\u00e7\u00f5es mais importantes no teste de software s\u00e3o quest\u00f5es de psicologia, podemos identificar um conjunto de princ\u00edpios ou diretrizes vitais de teste. A maioria desses princ\u00edpios pode parecer \u00f3bvia, mas muitas vezes s\u00e3o negligenciados. A Tabela 2.1 resume esses princ\u00edpios importantes, e cada um \u00e9 discutido com mais detalhes nos par\u00e1grafos a seguir.</p>"},{"location":"aae3/white_box_test/#principio-1","title":"Princ\u00edpio 1","text":"<p>Uma parte necess\u00e1ria de um caso de teste \u00e9 uma defini\u00e7\u00e3o da sa\u00edda ou resultado esperado. Este princ\u00edpio, embora \u00f3bvio, quando negligenciado, \u00e9 a causa de um dos erros mais frequentes no teste de programas. Novamente, \u00e9 algo baseado na psicologia humana. Se o resultado esperado de um caso de teste n\u00e3o foi predefinido, \u00e9 prov\u00e1vel que um resultado plaus\u00edvel, mas err\u00f4neo, seja interpretado como um resultado correto por causa do fen\u00f4meno de \"o olho ver o que quer ver\". Em outras palavras, apesar da defini\u00e7\u00e3o destrutiva adequada de teste, ainda h\u00e1 um desejo subconsciente de ver o resultado correto.</p> <p>Uma maneira de lutar contra essa situa\u00e7\u00e3o consiste em incentivar uma an\u00e1lise pormenorizada de toda a produ\u00e7\u00e3o, especificando com precis\u00e3o, antecipadamente, a produ\u00e7\u00e3o esperada do programa. Portanto, um caso de teste deve consistir em dois componentes:</p> <ol> <li>Uma descri\u00e7\u00e3o dos dados de entrada para o programa.</li> <li>Uma descri\u00e7\u00e3o precisa da sa\u00edda correta do programa para esse conjunto de dados de entrada.</li> </ol> <p>Um problema pode ser caracterizado como um fato ou grupo de fatos para os quais n\u00e3o temos uma explica\u00e7\u00e3o aceit\u00e1vel, que parecem incomuns ou que n\u00e3o se encaixam em nossas expectativas ou preconceitos. Deve ser \u00f3bvio que algumas cren\u00e7as pr\u00e9vias s\u00e3o necess\u00e1rias para que algo pare\u00e7a problem\u00e1tico. Se n\u00e3o houver expectativas, n\u00e3o pode haver surpresas.</p>"},{"location":"aae3/white_box_test/#principio-2","title":"Princ\u00edpio 2","text":"<p>Um programador deve evitar tentar testar seu pr\u00f3prio programa. Qualquer escritor sabe \u2014 ou deveria saber \u2014 que \u00e9 uma m\u00e1 ideia tentar editar ou revisar seu pr\u00f3prio trabalho. Eles sabem o que a pe\u00e7a deve dizer, portanto, podem n\u00e3o reconhecer quando diz o contr\u00e1rio. E eles realmente n\u00e3o querem encontrar erros em seu pr\u00f3prio trabalho. O mesmo se aplica aos autores de software.</p> <p>Outro problema surge com uma mudan\u00e7a de foco em um projeto de software. Depois que um programador projetou e codificou construtivamente um programa, \u00e9 extremamente dif\u00edcil mudar repentinamente a perspectiva para olhar para o programa com um olhar destrutivo.</p> <p>Como muitos propriet\u00e1rios sabem, remover o papel de parede (um processo destrutivo) n\u00e3o \u00e9 f\u00e1cil, mas \u00e9 quase insuportavelmente deprimente se foram suas m\u00e3os que penduraram o papel em primeiro lugar. Da mesma forma, a maioria dos programadores n\u00e3o pode testar efetivamente seus pr\u00f3prios programas porque n\u00e3o consegue mudar as engrenagens mentais para tentar expor erros. Al\u00e9m disso, um programador pode inconscientemente evitar encontrar erros por medo de retalia\u00e7\u00e3o de colegas, de um supervisor, de um cliente ou do propriet\u00e1rio do programa ou sistema que est\u00e1 sendo desenvolvido.</p> <p>Al\u00e9m dessas quest\u00f5es psicol\u00f3gicas, h\u00e1 um segundo problema significativo: o programa pode conter erros devido ao mal-entendido do programador sobre a declara\u00e7\u00e3o ou especifica\u00e7\u00e3o do problema. Se for esse o caso, \u00e9 prov\u00e1vel que o programador leve o mesmo mal-entendido para os testes de seu pr\u00f3prio programa.</p> <p>Isso n\u00e3o significa que seja imposs\u00edvel para um programador testar seu pr\u00f3prio programa. Em vez disso, implica que o teste \u00e9 mais eficaz e bem-sucedido se outra pessoa o fizer. No entanto, como vamos discutir em mais detalhes no Cap\u00edtulo 3, os desenvolvedores podem ser membros valiosos da equipe de teste quando a especifica\u00e7\u00e3o do programa e o pr\u00f3prio c\u00f3digo do programa est\u00e3o sendo avaliados.</p> <p>Observe que esse argumento n\u00e3o se aplica \u00e0 depura\u00e7\u00e3o (corrigir erros conhecidos); a depura\u00e7\u00e3o \u00e9 executada com mais efici\u00eancia pelo programador original.</p>"},{"location":"aae3/white_box_test/#principio-3","title":"Princ\u00edpio 3","text":"<p>Uma organiza\u00e7\u00e3o de programa\u00e7\u00e3o n\u00e3o deve testar seus pr\u00f3prios programas. O argumento aqui \u00e9 semelhante ao feito no princ\u00edpio anterior. Uma organiza\u00e7\u00e3o de projeto ou programa\u00e7\u00e3o \u00e9, em muitos sentidos, uma organiza\u00e7\u00e3o viva com problemas psicol\u00f3gicos semelhantes aos de programadores individuais. Al\u00e9m disso, na maioria dos ambientes, uma organiza\u00e7\u00e3o de programas ou um gerente de projeto \u00e9 amplamente medido pela capacidade de produzir um programa em uma determinada data e por um determinado custo.</p> <p>Uma raz\u00e3o para isso \u00e9 que \u00e9 f\u00e1cil medir os objetivos de tempo e custo, enquanto \u00e9 extremamente dif\u00edcil quantificar a confiabilidade de um programa. Portanto, \u00e9 dif\u00edcil para uma organiza\u00e7\u00e3o de programa\u00e7\u00e3o ser objetiva ao testar seus pr\u00f3prios programas, porque o processo de teste, se abordado com a defini\u00e7\u00e3o adequada, pode ser visto como diminuindo a probabilidade de atingir o cronograma e os objetivos de custo.</p> <p>Novamente, isso n\u00e3o significa que seja imposs\u00edvel para uma organiza\u00e7\u00e3o de programa\u00e7\u00e3o encontrar alguns de seus erros, porque as organiza\u00e7\u00f5es realizam isso com algum grau de sucesso. Em vez disso, implica que \u00e9 mais econ\u00f4mico que os testes sejam realizados por uma parte objetiva e independente.</p>"},{"location":"aae3/white_box_test/#principio-4","title":"Princ\u00edpio 4","text":"<p>Qualquer processo de teste deve incluir uma inspe\u00e7\u00e3o completa dos resultados de cada teste. Este \u00e9 provavelmente o princ\u00edpio mais \u00f3bvio, mas, novamente, \u00e9 algo que muitas vezes \u00e9 esquecido. Vimos v\u00e1rios experimentos que mostram que muitos sujeitos falharam em detectar certos erros, mesmo quando os sintomas desses erros eram claramente observ\u00e1veis nas listas de sa\u00edda. Dito de outra forma, os erros encontrados em testes posteriores foram frequentemente perdidos nos resultados de testes anteriores.</p>"},{"location":"aae3/white_box_test/#principio-5","title":"Princ\u00edpio 5","text":"<p>Os casos de teste devem ser escritos para condi\u00e7\u00f5es de entrada inv\u00e1lidas e inesperadas, bem como para aquelas que s\u00e3o v\u00e1lidas e esperadas. H\u00e1 uma tend\u00eancia natural, ao testar um programa, de se concentrar nas condi\u00e7\u00f5es de entrada v\u00e1lidas e esperadas, negligenciando as condi\u00e7\u00f5es inv\u00e1lidas e inesperadas.</p> <p>Por exemplo, essa tend\u00eancia aparece frequentemente no teste do programa do tri\u00e2ngulo no Cap\u00edtulo 1. Poucas pessoas, por exemplo, alimentam o programa com os n\u00fameros 1, 2, 5 para garantir que o programa n\u00e3o interprete erroneamente isso como um tri\u00e2ngulo equil\u00e1tero em vez de um tri\u00e2ngulo escaleno.</p> <p>Al\u00e9m disso, muitos erros que s\u00e3o descobertos repentinamente no software de produ\u00e7\u00e3o aparecem quando ele \u00e9 usado de alguma maneira nova ou inesperada. \u00c9 dif\u00edcil, se n\u00e3o imposs\u00edvel, definir todos os casos de uso para teste de software. Portanto, os casos de teste que representam condi\u00e7\u00f5es de entrada inesperadas e inv\u00e1lidas parecem ter um rendimento de detec\u00e7\u00e3o de erro maior do que os casos de teste para condi\u00e7\u00f5es de entrada v\u00e1lidas.</p>"},{"location":"aae3/white_box_test/#principio-6","title":"Princ\u00edpio 6","text":"<p>Examinar um programa para ver se ele n\u00e3o faz o que deveria fazer \u00e9 apenas metade da batalha; a outra metade \u00e9 ver se o programa faz o que n\u00e3o deveria fazer. Este \u00e9 um corol\u00e1rio do princ\u00edpio anterior. Os programas devem ser examinados quanto a efeitos colaterais indesejados.</p> <p>Por exemplo, um programa de c\u00e1lculo das folhas de pagamento que produz os contracheques corretos ainda \u00e9 um programa err\u00f4neo se tamb\u00e9m produzir cheques extras para empregados inexistentes ou se sobregravar o primeiro registro do arquivo pessoal.</p>"},{"location":"aae3/white_box_test/#principio-7","title":"Princ\u00edpio 7","text":"<p>Evite casos de teste descart\u00e1veis, a menos que o programa seja realmente um programa descart\u00e1vel. Este problema \u00e9 visto com mais frequ\u00eancia com sistemas interativos para testar programas. Uma pr\u00e1tica comum \u00e9 sentar-se em um terminal e inventar casos de teste em tempo real e, em seguida, enviar esses casos de teste pelo programa.</p> <p>A principal quest\u00e3o \u00e9 que os casos de teste representam um investimento valioso que, neste ambiente, desaparece ap\u00f3s a conclus\u00e3o do teste. Sempre que o programa tiver que ser testado novamente (por exemplo, ap\u00f3s corrigir um erro ou fazer uma melhoria), os casos de teste devem ser reinventados.</p> <p>Na maioria das vezes, uma vez que essa reinven\u00e7\u00e3o requer uma quantidade consider\u00e1vel de trabalho, as pessoas tendem a evit\u00e1-la. Portanto, o teste do programa raramente \u00e9 t\u00e3o rigoroso quanto o teste original, o que significa que, se a modifica\u00e7\u00e3o fizer com que uma parte anteriormente funcional do programa falhe, esse erro geralmente n\u00e3o \u00e9 detectado.</p> <p>Salvar casos de teste e execut\u00e1-los novamente ap\u00f3s altera\u00e7\u00f5es em outros componentes do programa \u00e9 conhecido como teste de regress\u00e3o.</p>"},{"location":"aae3/white_box_test/#principio-8","title":"Princ\u00edpio 8","text":"<p>N\u00e3o planeje um esfor\u00e7o de teste sob a suposi\u00e7\u00e3o t\u00e1cita de que nenhum erro ser\u00e1 encontrado. Este \u00e9 um erro que os gerentes de projeto costumam cometer e \u00e9 um sinal do uso da defini\u00e7\u00e3o incorreta de teste \u2014 ou seja, a suposi\u00e7\u00e3o de que o teste \u00e9 o processo de mostrar que o programa funciona corretamente.</p> <p>Mais uma vez, a defini\u00e7\u00e3o de teste \u00e9 o processo de execu\u00e7\u00e3o de um programa com a inten\u00e7\u00e3o de encontrar erros. E deve ser \u00f3bvio a partir de nossas discuss\u00f5es anteriores que \u00e9 imposs\u00edvel desenvolver um programa que seja completamente livre de erros.</p> <p>Mesmo ap\u00f3s extensos testes e corre\u00e7\u00e3o de erros, \u00e9 seguro assumir que os erros ainda existem; eles simplesmente ainda n\u00e3o foram encontrados.</p>"},{"location":"aae3/white_box_test/#principio-9","title":"Princ\u00edpio 9","text":"<p>A probabilidade da exist\u00eancia de mais erros em uma se\u00e7\u00e3o de um programa \u00e9 proporcional ao n\u00famero de erros j\u00e1 encontrados nessa se\u00e7\u00e3o. Este fen\u00f4meno \u00e9 ilustrado na Figura 2.2. \u00c0 primeira vista, esse conceito pode parecer sem sentido, mas \u00e9 um fen\u00f4meno presente em muitos programas.</p> <p>Por exemplo, se um programa consiste em dois m\u00f3dulos, classes ou sub-rotinas, A e B, e cinco erros foram encontrados no m\u00f3dulo A, e apenas um erro foi encontrado no m\u00f3dulo B, e se o m\u00f3dulo A n\u00e3o foi propositalmente submetido a um teste mais rigoroso, ent\u00e3o este princ\u00edpio nos diz que a probabilidade de mais erros no m\u00f3dulo A \u00e9 maior do que a probabilidade de mais erros no m\u00f3dulo B.</p> <p>Outra maneira de afirmar esse princ\u00edpio \u00e9 dizer que os erros tendem a ocorrer em grupos e que, no programa t\u00edpico, algumas se\u00e7\u00f5es parecem ser muito mais propensas a erros do que outras se\u00e7\u00f5es, embora ningu\u00e9m tenha fornecido uma boa explica\u00e7\u00e3o de por que isso ocorre.</p> <p>FIGURA 2.2: A surpreendente rela\u00e7\u00e3o entre erros remanescentes e erros encontrados.</p> <p>O fen\u00f4meno \u00e9 \u00fatil porque nos d\u00e1 uma vis\u00e3o ou feedback no processo de teste. Se uma se\u00e7\u00e3o espec\u00edfica de um programa parece ser muito mais propensa a erros do que outras se\u00e7\u00f5es, esse fen\u00f4meno nos diz que, em termos de rendimento em nosso investimento em testes, os esfor\u00e7os adicionais de teste s\u00e3o mais bem focados nesta se\u00e7\u00e3o propensa a erros.</p>"},{"location":"aae3/white_box_test/#principio-10","title":"Princ\u00edpio 10","text":"<p>O teste \u00e9 uma tarefa extremamente criativa e intelectualmente desafiadora. Provavelmente \u00e9 verdade que a criatividade necess\u00e1ria para testar um programa grande excede a criatividade necess\u00e1ria para projetar esse programa.</p> <p>J\u00e1 vimos que \u00e9 imposs\u00edvel testar um programa o suficiente para garantir a aus\u00eancia de todos os erros. As metodologias discutidas posteriormente neste livro ajudam voc\u00ea a desenvolver um conjunto razo\u00e1vel de casos de teste para um programa, mas essas metodologias ainda exigem uma quantidade significativa de criatividade.</p>"},{"location":"aae3/white_box_test/#resumo","title":"Resumo","text":"<p>\u00c0 medida que voc\u00ea avan\u00e7a neste livro, tenha em mente estes importantes princ\u00edpios de teste:</p> <ul> <li>Teste \u00e9 o processo de execu\u00e7\u00e3o de um programa com a inten\u00e7\u00e3o de encontrar erros.</li> <li>O teste \u00e9 mais bem-sucedido quando n\u00e3o \u00e9 realizado pelo(s) desenvolvedor(es).</li> <li>Um bom caso de teste \u00e9 aquele que tem uma alta probabilidade de detectar um erro n\u00e3o descoberto.</li> <li>Um caso de teste bem-sucedido \u00e9 aquele que detecta um erro n\u00e3o descoberto.</li> <li>O teste bem-sucedido inclui tamb\u00e9m a defini\u00e7\u00e3o cuidadosa da sa\u00edda esperada como entrada.</li> <li>O teste bem-sucedido inclui o estudo cuidadoso dos resultados do teste.</li> </ul>"},{"location":"aae3/white_box_test/#bibliografia","title":"Bibliografia","text":"<p>MYERS, G. J.; SANDLER, C.; BADGETT, T. The Art of Software Testing. 3rd ed. Cap\u00edtulo 4, Se\u00e7\u00e3o White-Box Testing.</p>"},{"location":"tpi_tpe/tpi1_tpe1/","title":"Question\u00e1rio - TPI-1","text":""},{"location":"tpi_tpe/tpi1_tpe1/#questao-1","title":"Quest\u00e3o 1","text":"<p>Enunciado: O que acontece com equipes que n\u00e3o adotam uma pr\u00e1tica rigorosa de testes?</p> <p>Alternativas: a) Elas entram em um ciclo repetitivo de cria\u00e7\u00e3o e corre\u00e7\u00e3o de bugs. b) Elas conseguem lan\u00e7ar software mais rapidamente, com menor esfor\u00e7o. c) Elas precisam de mais ferramentas automatizadas para compensar a aus\u00eancia de testes. d) Elas produzem software menos complexo, o que facilita a manuten\u00e7\u00e3o.</p> <p>Resposta correta: a</p>"},{"location":"tpi_tpe/tpi1_tpe1/#questao-2","title":"Quest\u00e3o 2","text":"<p>Enunciado: O que significa testar de forma eficaz, segundo o texto?</p> <p>Alternativas: a) Criar o maior n\u00famero poss\u00edvel de testes, de forma a cobrir o c\u00f3digo de forma abrangente e redundante. b) Escrever os testes certos, focando em encontrar mais bugs com o menor esfor\u00e7o poss\u00edvel. c) Combinar testes manuais com testes automatizados para ganhar efici\u00eancia. d) Focar no uso de ferramentas automatizadas para acelerar o processo de testes.</p> <p>Resposta correta: b</p>"},{"location":"tpi_tpe/tpi1_tpe1/#questao-3","title":"Quest\u00e3o 3","text":"<p>Enunciado: O que \u00e9 necess\u00e1rio para que diferentes desenvolvedores cheguem \u00e0 mesma su\u00edte de testes para um c\u00f3digo?</p> <p>Alternativas: a) Que todos usem a mesma linguagem de programa\u00e7\u00e3o. b) Que o processo de teste seja sistem\u00e1tico e padronizado. c) Que compartilhem a mesma ferramenta de automa\u00e7\u00e3o. d) Que tenham o mesmo n\u00edvel de experi\u00eancia profissional.</p> <p>Resposta correta: b</p>"},{"location":"tpi_tpe/tpi1_tpe1/#questao-4","title":"Quest\u00e3o 4","text":"<p>Enunciado: Qual \u00e9 um dos principais argumentos a favor do investimento em testes rigorosos?</p> <p>Alternativas: a) Reduzir o tempo de desenvolvimento inicial. b) Garantir que o sistema ser\u00e1 100% livre de erros. c) Evitar a necessidade de QA. d) O custo de bugs em produ\u00e7\u00e3o pode ser maior que o custo de preven\u00e7\u00e3o.</p> <p>Resposta correta: d</p>"},{"location":"tpi_tpe/tpi1_tpe1/#questao-5","title":"Quest\u00e3o 5","text":"<p>Enunciado: Qual \u00e9 a principal recomenda\u00e7\u00e3o ao considerar o paradoxo do pesticida?</p> <p>Alternativas: a) Priorizar testes automatizados para validar todas as entradas. b) Focar apenas em testes de integra\u00e7\u00e3o, ap\u00f3s obter cobertura completa de testes unit\u00e1rios. c) Combinar diferentes estrat\u00e9gias de teste para encontrar uma gama mais ampla de bugs. d) Evitar mudan\u00e7as frequentes nas t\u00e9cnicas de teste.</p> <p>Resposta correta: c</p>"},{"location":"tpi_tpe/tpi1_tpe1/#questao-6","title":"Quest\u00e3o 6","text":"<p>Enunciado: O que a observa\u00e7\u00e3o emp\u00edrica da comunidade de testes de software mostra sobre a distribui\u00e7\u00e3o de bugs?</p> <p>Alternativas: a) Os bugs ocorrem de forma homog\u00eanea em todos os componentes do sistema. b) Os bugs ocorrem com maior frequ\u00eancia em interfaces gr\u00e1ficas. c) A distribui\u00e7\u00e3o de bugs depende apenas da linguagem de programa\u00e7\u00e3o utilizada. d) Alguns componentes s\u00e3o mais propensos a conter bugs do que outros.</p> <p>Resposta correta: d</p>"},{"location":"tpi_tpe/tpi1_tpe1/#questao-7","title":"Quest\u00e3o 7","text":"<p>Enunciado: Por que os testes unit\u00e1rios s\u00e3o considerados f\u00e1ceis de controlar?</p> <p>Alternativas: a) Porque os valores de entrada e sa\u00edda s\u00e3o f\u00e1ceis de adaptar e modificar. b) Porque exigem muitas ferramentas externas para executar. c) Porque precisam ser reescritos a cada altera\u00e7\u00e3o de c\u00f3digo. d) Porque cobrem apenas requisitos de neg\u00f3cio complexos.</p> <p>Resposta correta: a</p>"},{"location":"tpi_tpe/tpi1_tpe1/#questao-8","title":"Quest\u00e3o 8","text":"<p>Enunciado: Qual \u00e9 uma das limita\u00e7\u00f5es dos testes unit\u00e1rios?</p> <p>Alternativas: a) Permitem identificar todos os defeitos presentes em sistemas multithread. b) Exigem a execu\u00e7\u00e3o completa da aplica\u00e7\u00e3o. c) N\u00e3o representam fielmente a execu\u00e7\u00e3o real do sistema, pois testam unidades isoladas. d) Dependem fortemente da intera\u00e7\u00e3o com bancos de dados reais.</p> <p>Resposta correta: c</p>"},{"location":"tpi_tpe/tpi1_tpe1/#questao-9","title":"Quest\u00e3o 9","text":"<p>Enunciado: Qual \u00e9 o foco principal dos testes de integra\u00e7\u00e3o?</p> <p>Alternativas: a) Integrar testes de unidade com testes de sistema. b) Verificar a comunica\u00e7\u00e3o correta entre componentes do sistema e componentes externos. c) Garantir que todos os requisitos do cliente foram implementados. d) Verificar se todos os componentes funcionam corretamente.</p> <p>Resposta correta: b</p>"},{"location":"tpi_tpe/tpi1_tpe1/#questao-10","title":"Quest\u00e3o 10","text":"<p>Enunciado: Qual dos itens abaixo \u00e9 uma desvantagem t\u00edpica dos testes de sistema?</p> <p>Alternativas: a) Maior tempo de execu\u00e7\u00e3o e maior complexidade na configura\u00e7\u00e3o dos ambientes de teste. b) Baixa chance de detectar falhas reais de produ\u00e7\u00e3o. c) Dificuldade de automa\u00e7\u00e3o devido \u00e0 falta de ferramentas. d) Inabilidade de simular cen\u00e1rios reais de usu\u00e1rio.</p> <p>Resposta correta: a</p>"},{"location":"tpi_tpe/tpi1_tpe1/#questao-11","title":"Quest\u00e3o 11","text":"<p>Enunciado: Por que alguns desenvolvedores preferem testes unit\u00e1rios em compara\u00e7\u00e3o a outros n\u00edveis de teste?</p> <p>Alternativas: a) Porque s\u00e3o mais f\u00e1ceis de escrever, mais r\u00e1pidos e podem ser escritos junto com o c\u00f3digo de produ\u00e7\u00e3o. b) Porque testes unit\u00e1rios dispensam manuten\u00e7\u00e3o e s\u00e3o 100% confi\u00e1veis. c) Porque testes unit\u00e1rios substituem a necessidade de testes de integra\u00e7\u00e3o e sistema. d) Porque s\u00e3o mais realistas que os outros n\u00edveis de testes.</p> <p>Resposta correta: a</p>"},{"location":"tpi_tpe/tpi1_tpe1/#questao-12","title":"Quest\u00e3o 12","text":"<p>Enunciado: Em qual situa\u00e7\u00e3o \u00e9 mais adequado utilizar testes de integra\u00e7\u00e3o, segundo Aniche?</p> <p>Alternativas: a) Quando h\u00e1 l\u00f3gica de neg\u00f3cio complexa desacoplada de outros componentes. b) Quando o c\u00f3digo est\u00e1 relacionado \u00e0 interface com o usu\u00e1rio. c) Quando o componente interage com servi\u00e7os externos, como bancos de dados ou APIs. d) Quando o tempo de execu\u00e7\u00e3o do teste precisa ser o mais curto poss\u00edvel.</p> <p>Resposta correta: c</p>"},{"location":"tpi_tpe/tpi1_tpe1/#questao-13","title":"Quest\u00e3o 13","text":"<p>Enunciado: O que representa a diferen\u00e7a entre a pir\u00e2mide de testes e o trof\u00e9u de testes?</p> <p>Alternativas: a) O trof\u00e9u de testes representa um maior uso de testes manuais. b) A pir\u00e2mide favorece mais testes unit\u00e1rios, enquanto o trof\u00e9u favorece mais testes de integra\u00e7\u00e3o. c) O trof\u00e9u exclui os testes de sistema. d) A pir\u00e2mide inclui testes de desempenho, enquanto o trof\u00e9u n\u00e3o.</p> <p>Resposta correta: b</p>"},{"location":"tpi_tpe/tpi1_tpe1/#questao-14","title":"Quest\u00e3o 14","text":"<p>Enunciado: De acordo com o Myers, qual \u00e9 a atitude ideal de um testador de software?</p> <p>Alternativas: a) Desconfiar da capacidade da equipe em realizar testes sistematizados. b) Come\u00e7ar assumindo que o programa cont\u00e9m erros. c) Desenvolver novas funcionalidades para melhorar o sistema. d) Automatizar todos os testes antes de execut\u00e1-los.</p> <p>Resposta correta: b</p>"},{"location":"tpi_tpe/tpi1_tpe1/#questao-15","title":"Quest\u00e3o 15","text":"<p>Enunciado: Por que Myers compara o teste de software com exames m\u00e9dicos?</p> <p>Alternativas: a) Para destacar que ambos tiram o sangue das pessoas. b) Porque ambos evitam que o paciente/software piore com o tempo. c) Porque m\u00e9dicos tamb\u00e9m usam softwares para seus diagn\u00f3sticos. d) Porque um teste s\u00f3 \u00e9 bem-sucedido se encontrar o problema.</p> <p>Resposta correta: d</p>"},{"location":"tpi_tpe/tpi1_tpe1/#questao-16","title":"Quest\u00e3o 16","text":"<p>Enunciado: O que Myers sugere como solu\u00e7\u00e3o para as limita\u00e7\u00f5es dos testes caixa-preta exaustivos?</p> <p>Alternativas: a) Executar apenas os testes definidos pelo cliente. b) Automatizar todos os testes para garantir cobertura total. c) Criar uma ferramenta que gere todos os casos automaticamente. d) Maximizar o n\u00famero de erros encontrados com um n\u00famero finito de casos de teste.</p> <p>Resposta correta: d</p>"},{"location":"tpi_tpe/tpi1_tpe1/#questao-17","title":"Quest\u00e3o 17","text":"<p>Enunciado: Qual \u00e9 o principal objetivo do teste de caixa-branca (white-box testing)?</p> <p>Alternativas: a) Verificar se o programa atende aos requisitos funcionais descritos na especifica\u00e7\u00e3o. b) Avaliar o desempenho do sistema em diferentes plataformas. c) Examinar a estrutura l\u00f3gica interna do programa para definir dados de teste. d) Executar testes baseados exclusivamente na interface do usu\u00e1rio.</p> <p>Resposta correta: c</p>"},{"location":"tpi_tpe/tpi1_tpe1/#questao-18","title":"Quest\u00e3o 18","text":"<p>Enunciado: Qual \u00e9 um elemento essencial de um caso de teste, segundo Myers?</p> <p>Alternativas: a) A defini\u00e7\u00e3o precisa da sa\u00edda esperada. b) A descri\u00e7\u00e3o do c\u00f3digo-fonte analisado. c) O nome do programador respons\u00e1vel. d) A linguagem de programa\u00e7\u00e3o utilizada.</p> <p>Resposta correta: a</p>"},{"location":"tpi_tpe/tpi2_tpe2/","title":"Question\u00e1rio - TPI-2","text":""},{"location":"tpi_tpe/tpi2_tpe2/#questao-1","title":"Quest\u00e3o 1","text":"<p>Enunciado: O teste de caixa preta \u00e9 caracterizado por:</p> <p>Alternativas: a) Utilizar as especifica\u00e7\u00f5es dos requisitos como base para cria\u00e7\u00e3o dos testes. b) Focar na estrutura interna do c\u00f3digo para definir os testes. c) Analisar o fluxo de controle do programa como crit\u00e9rio para os casos de teste. d) Utilizar t\u00e9cnicas heur\u00edsticas para derivar casos de teste.</p> <p>Resposta correta: a</p>"},{"location":"tpi_tpe/tpi2_tpe2/#questao-2","title":"Quest\u00e3o 2","text":"<p>Enunciado: Qual pr\u00e1tica \u00e9 utilizada para identificar as condi\u00e7\u00f5es de entrada no particionamento de equival\u00eancia?</p> <p>Alternativas: a) Definir entradas com base na cobertura de c\u00f3digo. b) Escolher dados aleat\u00f3rios para maximizar o n\u00famero de testes. c) Analisar cada senten\u00e7a da especifica\u00e7\u00e3o de requisitos. d) Reutilizar dados de testes de unidade.</p> <p>Resposta correta: c</p>"},{"location":"tpi_tpe/tpi2_tpe2/#questao-3","title":"Quest\u00e3o 3","text":"<p>Enunciado: O que define uma classe de equival\u00eancia?</p> <p>Alternativas: a) Um conjunto de entradas que o sistema trata de forma similar. b) Um grupo de testes que cobrem todos os caminhos do programa. c) Um subconjunto de entradas com maior chance de gerar falhas. d) Um grupo de sa\u00eddas esperadas com o mesmo valor.</p> <p>Resposta correta: a</p>"},{"location":"tpi_tpe/tpi2_tpe2/#questao-4","title":"Quest\u00e3o 4","text":"<p>Enunciado: Se uma entrada \u00e9 definida por um intervalo cont\u00ednuo, como se deve proceder para identificar as classes de equival\u00eancia?</p> <p>Alternativas: a) Criar tr\u00eas classes divididas pelos valores do intervalo. b) Criar uma classe v\u00e1lida e uma inv\u00e1lida. c) Criar uma classe v\u00e1lida com os valores dentro do intervalo e inv\u00e1lidas com os valores fora dele. d) Criar classes delimitadas por valores equidistantes.</p> <p>Resposta correta: c</p>"},{"location":"tpi_tpe/tpi2_tpe2/#questao-5","title":"Quest\u00e3o 5","text":"<p>Enunciado: Para um campo que aceita os valores \u201c\u00d4nibus\u201d, \u201cCaminh\u00e3o\u201d e \u201cTaxi\u201d, como devem ser definidas as classes de equival\u00eancia?</p> <p>Alternativas: a) Uma \u00fanica classe v\u00e1lida com todos os valores poss\u00edveis. b) Uma classe v\u00e1lida e uma inv\u00e1lida. c) Uma classe inv\u00e1lida e duas inv\u00e1lidas. d) Uma classe v\u00e1lida para cada valor e uma classe inv\u00e1lida para qualquer outro.</p> <p>Resposta correta: d</p>"},{"location":"tpi_tpe/tpi2_tpe2/#questao-6","title":"Quest\u00e3o 6","text":"<p>Enunciado: Em uma especifica\u00e7\u00e3o que diz \u201co primeiro caractere deve ser uma letra\u201d, quais classes de equival\u00eancia devem ser consideradas?</p> <p>Alternativas: a) Duas v\u00e1lidas (vogais e consoantes) e uma inv\u00e1lida (n\u00e3o letra). b) Apenas uma classe v\u00e1lida (letra). c) Uma classe v\u00e1lida (letra) e uma inv\u00e1lida (n\u00e3o letra). d) Uma classe inv\u00e1lida para cada caractere n\u00e3o alfab\u00e9tico.</p> <p>Resposta correta: c</p>"},{"location":"tpi_tpe/tpi2_tpe2/#questao-7","title":"Quest\u00e3o 7","text":"<p>Enunciado: Por que se considera eficiente testar apenas um valor por classe de equival\u00eancia?</p> <p>Alternativas: a) Espera-se que todos os valores da classe produzam resultados semelhantes. b) Isso garante 100% de cobertura de c\u00f3digo. c) \u00c9 mais r\u00e1pido e evita a valida\u00e7\u00e3o dos dados de sa\u00edda. d) O sistema geralmente ignora entradas repetidas.</p> <p>Resposta correta: a</p>"},{"location":"tpi_tpe/tpi2_tpe2/#questao-8","title":"Quest\u00e3o 8","text":"<p>Enunciado: Por que a an\u00e1lise de valor limite \u00e9 eficaz na detec\u00e7\u00e3o de erros?</p> <p>Alternativas: a) Ela garante 100% de cobertura de c\u00f3digo. b) Os limites representam a m\u00e9dia estat\u00edstica dos dados de entrada. c) Muitos erros ocorrem nas extremidades de intervalos v\u00e1lidos. d) Os limites n\u00e3o impactam o comportamento do programa.</p> <p>Resposta correta: c</p>"},{"location":"tpi_tpe/tpi2_tpe2/#questao-9","title":"Quest\u00e3o 9","text":"<p>Enunciado: Por que \u00e9 importante considerar os limites das sa\u00eddas esperadas na an\u00e1lise de valor limite?</p> <p>Alternativas: a) Porque os testes de sa\u00edda s\u00e3o mais f\u00e1ceis de validar manualmente. b) Porque as sa\u00eddas s\u00e3o mais suscet\u00edveis a falhas. c) Porque o sistema pode falhar ao gerar sa\u00eddas pr\u00f3ximas aos seus limites esperados. d) Porque os limites de sa\u00edda n\u00e3o s\u00e3o influenciados pelas entradas.</p> <p>Resposta correta: c</p>"},{"location":"tpi_tpe/tpi2_tpe2/#questao-10","title":"Quest\u00e3o 10","text":"<p>Enunciado: Uma boa pr\u00e1tica ao aplicar an\u00e1lise de valor limite \u00e9:</p> <p>Alternativas: a) Utilizar o valor central do intervalo, al\u00e9m dos valores nos limites. b) Testar somente os valores inv\u00e1lidos. c) Testar os valores imediatamente abaixo, nos pr\u00f3prios limites e imediatamente acima dos limites v\u00e1lidos. d) Executar testes aleat\u00f3rios fora do intervalo.</p> <p>Resposta correta: c</p>"},{"location":"tpi_tpe/tpi2_tpe2/#questao-11","title":"Quest\u00e3o 11","text":"<p>Enunciado: A t\u00e9cnica de grafo de causa-efeito \u00e9 mais apropriada quando:</p> <p>Alternativas: a) Os testes precisam ser derivados diretamente do c\u00f3digo-fonte. b) Todas as entradas s\u00e3o independentes entre si. c) H\u00e1 apenas uma entrada e uma sa\u00edda no sistema. d) Existem m\u00faltiplas condi\u00e7\u00f5es de entrada e regras de combina\u00e7\u00e3o complexas.</p> <p>Resposta correta: d</p>"},{"location":"tpi_tpe/tpi2_tpe2/#questao-12","title":"Quest\u00e3o 12","text":"<p>Enunciado: Qual das seguintes atividades representa um exemplo de uso da t\u00e9cnica de error-guessing?</p> <p>Alternativas: a) Testar com campos vazios mesmo quando n\u00e3o explicitamente proibido nas regras. b) Usar apenas valores de entrada listados como v\u00e1lidos na documenta\u00e7\u00e3o. c) Executar todos os testes com base em classes de equival\u00eancia. d) Escolher entradas com base em \u00e1lgebra relacional.</p> <p>Resposta correta: a</p>"},{"location":"tpi_tpe/tpi2_tpe2/#questao-13","title":"Quest\u00e3o 13","text":"<p>Enunciado: Quais t\u00e9cnicas s\u00e3o comumente utilizadas para derivar casos de teste no n\u00edvel funcional (sistema)?</p> <p>Alternativas: a) Caminho l\u00f3gico, MC/DC e tabelas de decis\u00e3o. b) Particionamento de equival\u00eancia, an\u00e1lise de valor limite e grafo de causa-efeito. c) An\u00e1lise l\u00e9xica e interpreta\u00e7\u00e3o sint\u00e1tica. d) An\u00e1lise de muta\u00e7\u00e3o e an\u00e1lise de fluxo de dados.</p> <p>Resposta correta: b</p>"},{"location":"tpi_tpe/tpi2_tpe2/#questao-14","title":"Quest\u00e3o 14","text":"<p>Enunciado: Os testes n\u00e3o-funcionais no n\u00edvel de sistema geralmente focam em:</p> <p>Alternativas: a) Caracter\u00edsticas como desempenho, usabilidade, confiabilidade e seguran\u00e7a. b) Corre\u00e7\u00e3o de bugs encontrados na fase de desenvolvimento. c) Execu\u00e7\u00e3o de testes de unidade em m\u00f3dulos isolados. d) Valida\u00e7\u00e3o de requisitos funcionais do usu\u00e1rio.</p> <p>Resposta correta: a</p>"},{"location":"tpi_tpe/tpi2_tpe2/#questao-15","title":"Quest\u00e3o 15","text":"<p>Enunciado: Um cen\u00e1rio comum de teste de desempenho inclui:</p> <p>Alternativas: a) Executar an\u00e1lises com altos volumes de dados de entrada. b) Gerar entradas aleat\u00f3rias para verificar falhas de formata\u00e7\u00e3o. c) Simular m\u00faltiplos usu\u00e1rios acessando o sistema simultaneamente. d) Verificar a ordena\u00e7\u00e3o correta de registros em um relat\u00f3rio.</p> <p>Resposta correta: c</p>"},{"location":"tpi_tpe/tpi2_tpe2/#questao-16","title":"Quest\u00e3o 16","text":"<p>Enunciado: Um exemplo de teste de volume \u00e9:</p> <p>Alternativas: a) Aumentar a quantidade de usu\u00e1rios ativos simultaneamente. b) Avaliar a taxa de throughput. c) Importar um milh\u00e3o de registros em um sistema de cadastro. d) Validar se campos obrigat\u00f3rios est\u00e3o sendo preenchidos corretamente.</p> <p>Resposta correta: c</p>"},{"location":"tpi_tpe/tpi2_tpe2/#questao-17","title":"Quest\u00e3o 17","text":"<p>Enunciado: O teste de confiabilidade busca:</p> <p>Alternativas: a) Verificar se os dados est\u00e3o criptografados em repouso. b) Garantir que os m\u00f3dulos estejam integrados corretamente. c) Medir a capacidade do sistema de funcionar corretamente durante um per\u00edodo prolongado. d) Testar a responsividade da interface com o usu\u00e1rio.</p> <p>Resposta correta: c</p>"},{"location":"tpi_tpe/tpi2_tpe2/#questao-18","title":"Quest\u00e3o 18","text":"<p>Enunciado: Qual \u00e9 um crit\u00e9rio razo\u00e1vel para encerrar os testes?</p> <p>Alternativas: a) Quando todos os casos de teste falharem pelo menos uma vez. b) Quando a curva de tend\u00eancia da taxa de defeitos por unidade estabilizar. c) Quando uma quantidade predefinida de falhas for identificada. d) Quando os usu\u00e1rios derem o aceite do sistema.</p> <p>Resposta correta: c</p>"},{"location":"tpi_tpe/tpi3_tpe3/","title":"Question\u00e1rio - TPI/TPE 3","text":""},{"location":"tpi_tpe/tpi3_tpe3/#questao-1","title":"Quest\u00e3o 1","text":"<p>Enunciado: Qual \u00e9 a representa\u00e7\u00e3o de programa mais comumente utilizada nos crit\u00e9rios de teste estrutural?</p> <p>Alternativas: a) Grafo de Causa-Efeito b) Grafo de Fluxo de Dados c) Grafo de Caminhos Independentes d) Grafo de Fluxo de Controle</p> <p>Resposta correta: d</p> <p>O diagrama \u00e9 um grafo de fluxo de controle. Cada n\u00f3 ou c\u00edrculo representa um segmento de instru\u00e7\u00f5es que executam sequencialmente, podendo terminar com uma instru\u00e7\u00e3o de desvio. Cada aresta ou arco representa uma transfer\u00eancia de controle (desvio) entre segmentos.</p> <p>Refer\u00eancia: The Art of Software Testing \u2013 3rd Edition, p\u00e1gina 11.</p>"},{"location":"tpi_tpe/tpi3_tpe3/#questao-2","title":"Quest\u00e3o 2","text":"<p>Enunciado: Qual das seguintes afirma\u00e7\u00f5es \u00e9 MAIS VERDADEIRA sobre o teste de unidade?</p> <p>Alternativas: a) \u00c9 uma abordagem de teste de caixa preta onde a estrutura interna do m\u00f3dulo n\u00e3o \u00e9 considerada b) \u00c9 uma abordagem de teste de caixa branca que foca nos componentes individuais de um programa c) S\u00f3 \u00e9 usado para grandes programas com mais de 500 instru\u00e7\u00f5es d) \u00c9 o mesmo que teste de integra\u00e7\u00e3o, que combina v\u00e1rios componentes</p> <p>Resposta correta: b</p> <p>O teste de unidade \u00e9 amplamente orientado \u00e0 caixa-branca. (p. 86)</p> <p>Refer\u00eancia: The Art of Software Testing \u2013 3rd Edition, p\u00e1gina 86.</p>"},{"location":"tpi_tpe/tpi3_tpe3/#questao-3","title":"Quest\u00e3o 3","text":"<p>Enunciado: Quais s\u00e3o os dois principais motivos para realizar o teste de unidade?</p> <p>Alternativas: a) Documentar a funcionalidade do programa e identificar erros no in\u00edcio do processo de desenvolvimento b) Reduzir a complexidade de testar programas grandes e facilitar a depura\u00e7\u00e3o c) Atender aos requisitos do usu\u00e1rio e garantir que o programa esteja livre de erros d) Melhorar a cobertura do c\u00f3digo e testar o desempenho do programa</p> <p>Resposta correta: b</p> <p>As motiva\u00e7\u00f5es para fazer isso s\u00e3o tr\u00eas. Primeiro, o teste de m\u00f3dulo \u00e9 uma forma de gerenciar os elementos combinados do teste, j\u00e1 que a aten\u00e7\u00e3o \u00e9 focada inicialmente em unidades menores do programa. Segundo, o teste de m\u00f3dulo facilita a tarefa de depura\u00e7\u00e3o, j\u00e1 que a aten\u00e7\u00e3o est\u00e1 concentrada em uma pequena unidade de c\u00f3digo e, frequentemente, a interface com o restante do programa \u00e9 simulada por um m\u00f3dulo stub. (p. 85)</p> <p>Refer\u00eancia: The Art of Software Testing \u2013 3rd Edition, p\u00e1gina 85.</p>"},{"location":"tpi_tpe/tpi3_tpe3/#questao-4","title":"Quest\u00e3o 4","text":"<p>Enunciado: Por que a cobertura de condi\u00e7\u00e3o pode n\u00e3o satisfazer a cobertura de decis\u00e3o?</p> <p>Alternativas: a) Porque a cobertura de condi\u00e7\u00e3o n\u00e3o testa todas as instru\u00e7\u00f5es b) Porque algumas condi\u00e7\u00f5es podem mascarar outras c) Porque a cobertura de condi\u00e7\u00e3o n\u00e3o inclui os pontos de entrada do programa d) Porque a cobertura de condi\u00e7\u00e3o n\u00e3o testa todas as combina\u00e7\u00f5es de condi\u00e7\u00f5es</p> <p>Resposta correta: b</p> <p>Um ponto fraco da cobertura de condi\u00e7\u00e3o/decis\u00e3o \u00e9 que, embora pare\u00e7a exercitar todos os resultados de todas as condi\u00e7\u00f5es, frequentemente n\u00e3o o faz, porque certas condi\u00e7\u00f5es mascaram outras condi\u00e7\u00f5es.</p> <p>Por exemplo, se uma condi\u00e7\u00e3o \u2018and\u2019 for falsa, nenhuma das condi\u00e7\u00f5es subsequentes na express\u00e3o precisa ser avaliada. Da mesma forma, se uma condi\u00e7\u00e3o \u2018or\u2019 for verdadeira, as condi\u00e7\u00f5es subsequentes tamb\u00e9m n\u00e3o precisam ser avaliadas.</p> <p>Refer\u00eancia: The Art of Software Testing \u2013 3rd Edition, p\u00e1ginas 46\u201347.</p>"},{"location":"tpi_tpe/tpi3_tpe3/#questao-5","title":"Quest\u00e3o 5","text":"<p>Enunciado: Qual \u00e9 a principal limita\u00e7\u00e3o da cobertura de decis\u00e3o?</p> <p>Alternativas: a) N\u00e3o garante que todas as instru\u00e7\u00f5es sejam executadas b) N\u00e3o considera as m\u00faltiplas condi\u00e7\u00f5es dentro de uma decis\u00e3o c) N\u00e3o testa todas as poss\u00edveis combina\u00e7\u00f5es de condi\u00e7\u00f5es d) N\u00e3o identifica erros em decis\u00f5es aninhadas</p> <p>Resposta correta: b</p> <p>A cobertura de decis\u00e3o \u00e9 um crit\u00e9rio mais forte do que a cobertura de instru\u00e7\u00f5es, mas ainda \u00e9 bastante fraco. Um crit\u00e9rio que \u00e0s vezes \u00e9 mais forte do que a cobertura de decis\u00e3o \u00e9 a cobertura de condi\u00e7\u00e3o. [...] Mas, assim como a cobertura de decis\u00e3o, isso nem sempre leva \u00e0 execu\u00e7\u00e3o de cada instru\u00e7\u00e3o. Embora o crit\u00e9rio de cobertura de condi\u00e7\u00e3o pare\u00e7a, \u00e0 primeira vista, satisfazer o crit\u00e9rio de cobertura de decis\u00e3o, isso nem sempre acontece. [...] Os testes de cobertura de condi\u00e7\u00e3o do exemplo anterior cobriram todos os resultados das condi\u00e7\u00f5es, mas apenas dois dos quatro resultados das decis\u00f5es...</p> <p>Refer\u00eancia: The Art of Software Testing \u2013 3rd Edition, p\u00e1ginas 45\u201346.</p>"},{"location":"tpi_tpe/tpi3_tpe3/#questao-6","title":"Quest\u00e3o 6","text":"<p>Enunciado: Qual dos crit\u00e9rios de cobertura de l\u00f3gica \u00e9 considerado o mais fraco?</p> <p>Alternativas: a) Cobertura de condi\u00e7\u00e3o b) Cobertura de decis\u00e3o c) Cobertura de m\u00faltiplas condi\u00e7\u00f5es d) Cobertura de instru\u00e7\u00e3o</p> <p>Resposta correta: d</p> <p>Embora voc\u00ea possa executar todas as instru\u00e7\u00f5es com um \u00fanico teste, esse crit\u00e9rio \u00e9 bastante fraco. Em outras palavras, o crit\u00e9rio de cobertura de instru\u00e7\u00e3o \u00e9 t\u00e3o fraco que geralmente \u00e9 in\u00fatil.</p> <p>Refer\u00eancia: The Art of Software Testing \u2013 3rd Edition, p\u00e1gina 44.</p>"},{"location":"tpi_tpe/tpi3_tpe3/#questao-7","title":"Quest\u00e3o 7","text":"<p>Enunciado: O que o m\u00e9todo MC/DC visa alcan\u00e7ar?</p> <p>Alternativas: a) Testar todas as instru\u00e7\u00f5es do programa pelo menos uma vez b) Testar todas as combina\u00e7\u00f5es de decis\u00f5es em um programa c) Garantir que cada condi\u00e7\u00e3o em uma decis\u00e3o tenha um resultado verdadeiro e falso pelo menos uma vez d) Garantir que cada condi\u00e7\u00e3o independente em uma decis\u00e3o tenha um efeito independente na sa\u00edda da decis\u00e3o</p> <p>Resposta correta: d</p> <p>A cobertura de condi\u00e7\u00e3o/decis\u00e3o modificada (MC/DC) exige que cada ponto de entrada e sa\u00edda do programa tenha sido invocado pelo menos uma vez, que cada condi\u00e7\u00e3o em uma decis\u00e3o assuma todos os resultados poss\u00edveis pelo menos uma vez e que cada condi\u00e7\u00e3o em uma decis\u00e3o tenha mostrado afetar de forma independente o resultado da decis\u00e3o.</p> <p>Refer\u00eancia: The Art of Software Testing \u2013 3rd Edition, p\u00e1gina 47.</p>"},{"location":"tpi_tpe/tpi3_tpe3/#questao-8","title":"Quest\u00e3o 8","text":"<p>Enunciado: Qual \u00e9 uma das principais vantagens do m\u00e9todo MC/DC em rela\u00e7\u00e3o a outros crit\u00e9rios de cobertura?</p> <p>Alternativas: a) Requer menos casos de teste para ser implementado b) \u00c9 mais f\u00e1cil de entender e aplicar em programas grandes c) Garante uma cobertura mais robusta ao testar condi\u00e7\u00f5es de decis\u00e3o d) N\u00e3o requer testes de m\u00faltiplas condi\u00e7\u00f5es dentro de uma decis\u00e3o</p> <p>Resposta correta: c</p> <p>Um crit\u00e9rio que cobre esse problema, e vai al\u00e9m, \u00e9 a cobertura de m\u00faltiplas condi\u00e7\u00f5es. Esse crit\u00e9rio exige que voc\u00ea escreva casos de teste suficientes para que todas as combina\u00e7\u00f5es poss\u00edveis de resultados de condi\u00e7\u00f5es em cada decis\u00e3o, e todos os pontos de entrada, sejam invocados pelo menos uma vez. Embora o MC/DC n\u00e3o exija todas as combina\u00e7\u00f5es, ele melhora a cobertura de decis\u00e3o/condi\u00e7\u00e3o ao garantir que cada condi\u00e7\u00e3o afete independentemente o resultado da decis\u00e3o.</p> <p>Refer\u00eancia: The Art of Software Testing \u2013 3rd Edition, p\u00e1gina 47.</p>"},{"location":"tpi_tpe/tpi3_tpe3/#questao-9","title":"Quest\u00e3o 9","text":"<p>Enunciado: Qual das seguintes afirma\u00e7\u00f5es melhor descreve o primeiro passo ao usar t\u00e9cnicas de cobertura l\u00f3gica no teste de software?</p> <p>Alternativas: a) Identificar todas as vari\u00e1veis no programa e garantir que cada uma seja testada em diferentes condi\u00e7\u00f5es b) Listar as decis\u00f5es condicionais no programa, focando em declara\u00e7\u00f5es IF, DO e similares c) Criar casos de teste para todas as funcionalidades do software sem considerar a estrutura interna do c\u00f3digo d) Garantir que todas as declara\u00e7\u00f5es IF no programa sejam testadas de forma isolada para verificar seu comportamento</p> <p>Resposta correta: b</p> <p>Independentemente da t\u00e9cnica de cobertura l\u00f3gica utilizada, o primeiro passo \u00e9 listar as decis\u00f5es condicionais no programa. Os candidatos neste programa s\u00e3o todas as instru\u00e7\u00f5es IF e DO.</p> <p>Refer\u00eancia: The Art of Software Testing \u2013 3rd Edition, p\u00e1gina 89.</p>"},{"location":"tpi_tpe/tpi3_tpe3/#questao-10","title":"Quest\u00e3o 10","text":"<p>Enunciado: Qual das seguintes afirma\u00e7\u00f5es melhor descreve uma caracter\u00edstica do crit\u00e9rio de cobertura de m\u00faltiplas condi\u00e7\u00f5es?</p> <p>Alternativas: a) O crit\u00e9rio de cobertura de m\u00faltiplas condi\u00e7\u00f5es \u00e9 suficiente para detectar todos os erros poss\u00edveis em uma unidade b) Mesmo testes que satisfazem o crit\u00e9rio de cobertura de m\u00faltiplas condi\u00e7\u00f5es podem n\u00e3o detectar certos erros, como valores iniciais incorretos c) O crit\u00e9rio de cobertura de m\u00faltiplas condi\u00e7\u00f5es se concentra apenas em testes de caixa-preta d) O crit\u00e9rio de cobertura de m\u00faltiplas condi\u00e7\u00f5es garante que todos os caminhos de execu\u00e7\u00e3o do c\u00f3digo sejam testados</p> <p>Resposta correta: b</p> <p>Embora esses dois casos de teste atendam ao crit\u00e9rio de cobertura de decis\u00e3o, deve ser \u00f3bvio que pode haver muitos tipos de erros no m\u00f3dulo que n\u00e3o s\u00e3o detectados por esses dois casos. Por exemplo, os casos de teste n\u00e3o exploram circunst\u00e2ncias como quando o c\u00f3digo de erro \u00e9 0, um funcion\u00e1rio \u00e9 gerente ou a tabela de departamentos est\u00e1 vazia (DSIZE \u2264 0).</p> <p>Refer\u00eancia: The Art of Software Testing \u2013 3rd Edition, p\u00e1gina 90.</p>"},{"location":"tpi_tpe/tpi3_tpe3/#questao-11","title":"Quest\u00e3o 11","text":"<p>Enunciado: Qual \u00e9 uma vantagem importante do teste incremental sobre o teste n\u00e3o incremental?</p> <p>Alternativas: a) Requer menos m\u00f3dulos de driver e stub b) Necessita de menos tempo de m\u00e1quina c) Permite que todos os m\u00f3dulos sejam testados simultaneamente d) Reduz a possibilidade de detectar erros nas interfaces dos m\u00f3dulos</p> <p>Resposta correta: a</p> <p>O teste n\u00e3o incremental exige mais trabalho. Para o programa da Figura 5.7, cinco drivers e cinco stubs devem ser preparados [...]. O teste incremental bottom-up exigiria cinco drivers, mas nenhum stub. Um teste incremental top-down exigiria cinco stubs, mas nenhum driver. Menos trabalho \u00e9 necess\u00e1rio porque os m\u00f3dulos previamente testados s\u00e3o usados em vez dos m\u00f3dulos driver (se come\u00e7ar do topo) ou dos m\u00f3dulos stub (se come\u00e7ar pela base) exigidos na abordagem n\u00e3o incremental.</p> <p>Refer\u00eancia: The Art of Software Testing \u2013 3rd Edition, p\u00e1gina 99.</p>"},{"location":"tpi_tpe/tpi3_tpe3/#questao-12","title":"Quest\u00e3o 12","text":"<p>Enunciado: Qual das seguintes observa\u00e7\u00f5es \u00e9 uma vantagem do teste n\u00e3o incremental?</p> <p>Alternativas: a) Detecta erros de interfaces de m\u00f3dulos mais cedo b) Reduz a necessidade de drivers e stubs c) Permite mais atividades paralelas no in\u00edcio da fase de testes de m\u00f3dulo d) Resulta em testes mais completos dos m\u00f3dulos</p> <p>Resposta correta: c</p> <p>No in\u00edcio da fase de testes de m\u00f3dulo, h\u00e1 mais oportunidade para atividades paralelas quando se utiliza o teste n\u00e3o incremental (isto \u00e9, todos os m\u00f3dulos podem ser testados simultaneamente). Isso pode ser significativo em projetos grandes (com muitos m\u00f3dulos e pessoas), j\u00e1 que o n\u00famero de integrantes do projeto geralmente atinge seu pico no in\u00edcio dessa fase.</p> <p>Refer\u00eancia: The Art of Software Testing \u2013 3rd Edition, p\u00e1gina 100.</p>"},{"location":"tpi_tpe/tpi3_tpe3/#questao-13","title":"Quest\u00e3o 13","text":"<p>Enunciado: Qual \u00e9 uma das principais vantagens do teste top-down?</p> <p>Alternativas: a) N\u00e3o requer a cria\u00e7\u00e3o de stubs b) Facilita a representa\u00e7\u00e3o de casos de teste uma vez que as fun\u00e7\u00f5es de entrada e sa\u00edda s\u00e3o adicionadas c) Permite a identifica\u00e7\u00e3o de todos os erros poss\u00edveis no programa d) Garante que todos os m\u00f3dulos s\u00e3o testados simultaneamente</p> <p>Resposta correta: b</p> <p>Uma vez que as fun\u00e7\u00f5es de entrada/sa\u00edda s\u00e3o adicionadas, a representa\u00e7\u00e3o dos casos \u00e9 facilitada.</p> <p>Refer\u00eancia: The Art of Software Testing \u2013 3rd Edition, p\u00e1gina 109.</p>"},{"location":"tpi_tpe/tpi3_tpe3/#questao-14","title":"Quest\u00e3o 14","text":"<p>Enunciado: Qual \u00e9 uma desvantagem do teste bottom-up?</p> <p>Alternativas: a) A produ\u00e7\u00e3o de m\u00f3dulos driver \u00e9 mais dif\u00edcil que a produ\u00e7\u00e3o de stubs b) N\u00e3o permite a cria\u00e7\u00e3o de um esqueleto inicial do programa c) Requer que todos os m\u00f3dulos sejam testados simultaneamente d) Aumenta a possibilidade de erros humanos durante a fase de design</p> <p>Resposta correta: b</p> <p>Uma desvantagem da estrat\u00e9gia bottom-up \u00e9 que n\u00e3o h\u00e1 conceito de um programa esquel\u00e9tico inicial. De fato, o programa funcional n\u00e3o existe at\u00e9 que o \u00faltimo m\u00f3dulo (m\u00f3dulo A) seja adicionado, e esse programa funcional \u00e9 o programa completo.</p> <p>Refer\u00eancia: The Art of Software Testing \u2013 3rd Edition, p\u00e1gina 107.</p>"},{"location":"tpi_tpe/tpi4_tpe4/","title":"Question\u00e1rio - TPI/TPE 4","text":""},{"location":"tpi_tpe/tpi4_tpe4/#questao-1","title":"Quest\u00e3o 1","text":"<p>Enunciado: O que s\u00e3o objetos dummy?</p> <p>Alternativas: a) Objetos que possuem implementa\u00e7\u00f5es reais, mas simplificadas b) Objetos passados para a classe em teste, mas nunca utilizados c) Objetos que fornecem respostas codificadas para chamadas realizadas durante o teste d) Objetos que gravam todas as intera\u00e7\u00f5es e permitem fazer asser\u00e7\u00f5es posteriormente</p> <p>Resposta correta: b</p> <p>Objetos dummy s\u00e3o passados para a classe em teste, mas nunca s\u00e3o utilizados. Isso \u00e9 comum em aplica\u00e7\u00f5es de neg\u00f3cio, onde \u00e9 necess\u00e1rio preencher uma longa lista de par\u00e2metros, mas o teste utiliza apenas alguns deles. Pense em um teste de unidade para uma classe Customer. Talvez essa classe dependa de v\u00e1rias outras, como Address, Email, e assim por diante. Talvez um caso de teste espec\u00edfico (caso A) queira exercitar um comportamento, e esse comportamento n\u00e3o se importa com qual Address o Customer possui. Nesse caso, o testador pode criar um objeto Address dummy e pass\u00e1-lo para a classe Customer.</p> <p>(Tradu\u00e7\u00e3o Livre de Aniche, 2022, Cap. 6)</p> <p>Dummy objects are passed to the class under test but never used. This is common in business applications where you need to fill a long list of parameters, but the test exercises only a few of them. Think of a unit test for a Customer class. Maybe this class depends on several other classes like Address, Email, and so on. Maybe a specific test case A wants to exercise a behavior, and this behavior does not care which Address this Customer has. In this case, a tester can set up a dummy Address object and pass it to the Customer class.</p> <p>(Aniche, 2022, Cap. 6)</p> <p>Objetos Dummy s\u00e3o uma forma degenerada de Test Double. Eles existem apenas para serem passados de m\u00e9todo para m\u00e9todo; eles nunca s\u00e3o utilizados. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 728)</p> <p>Um objeto dummy \u00e9 passado para preencher uma lista de par\u00e2metros, mas nunca \u00e9 usado. Eles s\u00e3o mais frequentemente usados para preencher par\u00e2metros obrigat\u00f3rios em m\u00e9todos ou construtores. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 728)</p> <p>Algumas linguagens exigem que forne\u00e7amos valores para todos os par\u00e2metros formais de um m\u00e9todo; objetos dummy nos permitem satisfazer esse requisito sem afetar o comportamento do teste. (Tradu\u00e7\u00e3o livre de Meszaros, 2007, p. 728)</p> <p>Refer\u00eancias:</p> <ul> <li>Meszaros, G. (2007). xUnit Test Patterns: Refactoring Test Code. Addison-Wesley.</li> <li>Aniche, Maur\u00edcio. Effective Software Testing: A Developer's Guide. Manning, 2022. ISBN\u201110: 1633439933; ISBN\u201113: 978\u20111633439931.</li> </ul> <p>Por que as outras alternativas est\u00e3o erradas</p> <ul> <li>a. Objetos que possuem implementa\u00e7\u00f5es reais, mas simplificadas.</li> </ul> <p>Isso define um Fake Object, substituindo um componente real por uma implementa\u00e7\u00e3o funcional mais leve. (Meszaros, 2007, p. 551)</p> <ul> <li>c. Objetos que fornecem respostas codificadas para chamadas realizadas durante o teste.</li> </ul> <p>Isso define um Test Stub. (Meszaros, 2007, p. 529)</p> <ul> <li>d. Objetos que gravam todas as intera\u00e7\u00f5es e permitem fazer asser\u00e7\u00f5es posteriormente. <p>Isso corresponde a um Test Spy. (Meszaros, 2007, p. 538)</p> </li> </ul>"},{"location":"tpi_tpe/tpi4_tpe4/#questao-2","title":"Quest\u00e3o 2","text":"<p>Enunciado: Qual a principal caracter\u00edstica de objetos fake?</p> <p>Alternativas: a) Eles t\u00eam implementa\u00e7\u00f5es reais, mas geralmente fazem a tarefa de forma mais simples b) Eles fornecem respostas codificadas para chamadas realizadas durante o teste c) Eles gravam todas as intera\u00e7\u00f5es e permitem fazer asser\u00e7\u00f5es posteriormente d) Eles envolvem o objeto real e observam seu comportamento</p> <p>Resposta correta: a</p> <p>Objetos fake possuem implementa\u00e7\u00f5es reais e funcionais da classe que est\u00e3o simulando, mas realizam a tarefa de forma mais simples. Imagine uma classe de banco de dados fake que usa uma ArrayList em vez de um banco real. (Aniche, 2022, Cap. 6)</p> <p>Um Fake Object substitui um componente do SUT por uma implementa\u00e7\u00e3o funcional, geralmente mais leve. (Meszaros, 2007, p. 551)</p> <p>Por que as outras alternativas est\u00e3o erradas</p> <ul> <li>b. Isso descreve um Test Stub.</li> </ul> <p>(Meszaros, 2007, p. 529)</p> <ul> <li>c. Isso descreve um Test Spy.</li> </ul> <p>(Meszaros, 2007, p. 538)</p> <ul> <li>d. Isso descreve um Mock Object com proxying. <p>(Meszaros, 2007, p. 544)</p> </li> </ul> <p>Refer\u00eancias: Meszaros, 2007; Aniche, 2022.</p>"},{"location":"tpi_tpe/tpi4_tpe4/#questao-3","title":"Quest\u00e3o 3","text":"<p>Enunciado: Como os stubs diferem dos objetos fake?</p> <p>Alternativas: a) Stubs t\u00eam implementa\u00e7\u00f5es reais, mas simplificadas b) Stubs s\u00e3o usados apenas para observar o comportamento de uma depend\u00eancia real c) Stubs fornecem respostas codificadas e n\u00e3o t\u00eam implementa\u00e7\u00e3o funcional d) Stubs permitem fazer asser\u00e7\u00f5es sobre as intera\u00e7\u00f5es ap\u00f3s o teste</p> <p>Resposta correta: c</p> <p>Stubs fornecem respostas codificadas e n\u00e3o t\u00eam comportamento funcional. (Aniche, 2022, Cap. 6; Meszaros, 2007, p. 529)</p> <p>Por que as outras alternativas est\u00e3o erradas</p> <ul> <li>a. Descreve Fake</li> <li>b. Descreve Spy</li> <li>d. Descreve Spy</li> </ul> <p>Refer\u00eancias: Meszaros, 2007; Aniche, 2022.</p>"},{"location":"tpi_tpe/tpi4_tpe4/#questao-4","title":"Quest\u00e3o 4","text":"<p>Enunciado: Qual a vantagem principal dos objetos mocks em compara\u00e7\u00e3o com os stubs?</p> <p>Alternativas: a) Mocks t\u00eam implementa\u00e7\u00f5es reais b) Mocks s\u00e3o mais f\u00e1ceis de controlar do que stubs c) Mocks podem gravar intera\u00e7\u00f5es e permitir asser\u00e7\u00f5es sobre elas d) Mocks fornecem respostas codificadas para chamadas realizadas durante o teste</p> <p>Resposta correta: c</p> <p>Mocks permitem verificar intera\u00e7\u00f5es ao final do teste, al\u00e9m de retornarem valores esperados como stubs fazem. (Aniche, 2022, Cap. 6; Meszaros, 2007, p. 544)</p>"},{"location":"tpi_tpe/tpi4_tpe4/#questao-5","title":"Quest\u00e3o 5","text":"<p>Enunciado: Uma classe que simula uma base de dados usando uma lista pode ser classificada como:</p> <p>Alternativas: a) Fake object b) Dummy object c) Mock d) Stub</p> <p>Resposta correta: a</p> <p>Fake Object substitui a implementa\u00e7\u00e3o real por algo funcional mais simples, como um banco de dados em mem\u00f3ria. (Meszaros, 2007, p. 551; Aniche, 2022, Cap. 6)</p>"},{"location":"tpi_tpe/tpi4_tpe4/#questao-6","title":"Quest\u00e3o 6","text":"<p>Enunciado: O que pode ser necess\u00e1rio para injetar dubl\u00eas de teste?</p> <p>Alternativas: a) Criar um tipo especial de dubl\u00ea que intercepte chamadas b) Refatorar o construtor da classe de teste c) Usar um framework de mocking d) Alterar o c\u00f3digo da classe sendo testada para aceitar a depend\u00eancia via construtor</p> <p>Resposta correta: d</p> <p>O livro destaca a inje\u00e7\u00e3o via construtor como forma de passar dubl\u00eas para o SUT. (Aniche, 2022, Cap. 6; Meszaros, 2007, p. 680\u2013684)</p>"},{"location":"tpi_tpe/tpi4_tpe4/#questao-7","title":"Quest\u00e3o 7","text":"<p>Enunciado: Qual a principal vantagem de configurar dubl\u00eas para lan\u00e7ar exce\u00e7\u00f5es?</p> <p>Alternativas: a) Permite testar como os sistemas se comportariam em cen\u00e1rios inesperados b) Garante que todos os m\u00e9todos sejam chamados ao menos uma vez c) Facilita respostas codificadas d) Substitui testes de integra\u00e7\u00e3o</p> <p>Resposta correta: a</p> <p>Isso facilita testar caminhos de exce\u00e7\u00e3o sem depend\u00eancias reais. (Aniche, 2022, Cap. 6; Meszaros, 2007, p. 127)</p>"},{"location":"tpi_tpe/tpi4_tpe4/#questao-8","title":"Quest\u00e3o 8","text":"<p>Enunciado: Qual \u00e9 uma das principais desvantagens de usar dubl\u00eas?</p> <p>Alternativas: a) O acoplamento com o c\u00f3digo de produ\u00e7\u00e3o, que pode levar a falhas ao mudar intera\u00e7\u00f5es b) Dificuldade de configura\u00e7\u00e3o e manuten\u00e7\u00e3o c) Incapacidade de simular comportamentos complexos d) Modifica\u00e7\u00e3o excessiva do c\u00f3digo de produ\u00e7\u00e3o</p> <p>Resposta correta: a</p> <p>Dubl\u00eas, especialmente mocks, podem gerar testes fr\u00e1geis muito acoplados ao c\u00f3digo real. (Aniche, 2022, Cap. 6; Meszaros, 2007, p. 570)</p>"},{"location":"tpi_tpe/tpi4_tpe4/#questao-9","title":"Quest\u00e3o 9","text":"<p>Enunciado: Qual \u00e9 o ciclo repetido no processo de TDD?</p> <p>Alternativas: a) Teste passa \u2192 implementa\u00e7\u00e3o \u2192 refatora\u00e7\u00e3o b) Teste falha \u2192 implementa\u00e7\u00e3o \u2192 refatora\u00e7\u00e3o c) Implementa\u00e7\u00e3o \u2192 teste passa \u2192 refatora\u00e7\u00e3o d) Refatora\u00e7\u00e3o \u2192 teste falha \u2192 implementa\u00e7\u00e3o</p> <p>Resposta correta: b</p> <p>O ciclo do TDD cl\u00e1ssico: falhar \u2192 passar \u2192 refatorar. (Aniche, 2022, Cap. 8; Beck, 2002, Cap. 2)</p>"},{"location":"tpi_tpe/tpi4_tpe4/#questao-10","title":"Quest\u00e3o 10","text":"<p>Enunciado: Por que o TDD facilita a identifica\u00e7\u00e3o de problemas?</p> <p>Alternativas: a) Porque desenvolvedores escrevem c\u00f3digo antes dos testes b) Porque desenvolvedores focam no produto final c) Porque todos os testes s\u00e3o escritos antes da implementa\u00e7\u00e3o d) Porque o ciclo incremental permite detectar problemas ap\u00f3s pequenas altera\u00e7\u00f5es</p> <p>Resposta correta: d</p> <p>Pequenas altera\u00e7\u00f5es facilitam identificar falhas rapidamente. (Aniche, 2022, Cap. 8; Beck, 2002, Cap. 2)</p>"},{"location":"tpi_tpe/tpi4_tpe4/#questao-11","title":"Quest\u00e3o 11","text":"<p>Enunciado: Como o TDD afeta o design?</p> <p>Alternativas: a) Testes n\u00e3o influenciam o design b) O teste \u00e9 o primeiro cliente da classe, influenciando seu design c) TDD encoraja designs mais complexos d) TDD desencoraja refatora\u00e7\u00e3o</p> <p>Resposta correta: b</p> <p>O c\u00f3digo de teste serve de primeiro cliente, influenciando a forma do design. (Aniche, 2022, Cap. 8; Beck, 2002, Cap. 17)</p>"},{"location":"tpi_tpe/tpi4_tpe4/#questao-12","title":"Quest\u00e3o 12","text":"<p>Enunciado: Quando o TDD \u00e9 mais vantajoso?</p> <p>Alternativas: a) Em problemas simples b) Em qualquer tipo de problema c) Em projetos de manuten\u00e7\u00e3o d) Em problemas mais complicados, onde ajuda a estruturar melhor o desenvolvimento</p> <p>Resposta correta: d</p> <p>O TDD auxilia muito quando a solu\u00e7\u00e3o n\u00e3o est\u00e1 clara e exige experimenta\u00e7\u00e3o. (Aniche, 2022, Cap. 8; Beck, 2002)</p>"},{"location":"tpi_tpe/tpi4_tpe4/#questao-13","title":"Quest\u00e3o 13","text":"<p>Enunciado: Em quais situa\u00e7\u00f5es o uso do TDD n\u00e3o \u00e9 recomendado?</p> <p>Alternativas: a) Quando o problema \u00e9 bem conhecido e n\u00e3o h\u00e1 necessidade de experimenta\u00e7\u00e3o b) Quando se est\u00e1 em projetos \u00e1geis c) Em sistemas embarcados d) Quando a pir\u00e2mide de testes n\u00e3o \u00e9 aplicada</p> <p>Resposta correta: a</p> <p>Se o problema j\u00e1 est\u00e1 totalmente dominado, n\u00e3o h\u00e1 muito a aprender com TDD. (Aniche, 2022, Cap. 8; Beck, 2002)</p>"},{"location":"tpi_tpe/tpi4_tpe4/#questao-14","title":"Quest\u00e3o 14","text":"<p>Enunciado: Qual a efic\u00e1cia dos testes em TDD?</p> <p>Alternativas: a) As su\u00edtes de TDD s\u00e3o superiores \u00e0s su\u00edtes sistem\u00e1ticas em v\u00e1rios aspectos b) As su\u00edtes s\u00e3o equivalentes c) S\u00e3o inferiores apenas em projetos pequenos d) TDD foca em desenvolvimento e n\u00e3o gera testes eficazes</p> <p>Resposta correta: a</p> <p>Pesquisas apontam maior qualidade de design, cobertura de testes e redu\u00e7\u00e3o de defeitos. (Aniche, 2022, Cap. 8; Meszaros, 2007, p. 33)</p>"},{"location":"tpi_tpe/tpi5_tpe5/","title":"Question\u00e1rio - TPI-5","text":""},{"location":"tpi_tpe/tpi5_tpe5/#questao-1","title":"Quest\u00e3o 1","text":"<p>Enunciado: Por que \u00e9 importante desenvolver a mentalidade correta ao testar a seguran\u00e7a de aplica\u00e7\u00f5es web?</p> <p>Alternativas: a) Porque os testes de seguran\u00e7a devem seguir os mesmos cen\u00e1rios dos testes funcionais. b) Porque a maioria das ferramentas automatizadas cobre todos os cen\u00e1rios poss\u00edveis de ataque. c) Porque \u00e9 necess\u00e1rio pensar como um atacante e explorar comportamentos inesperados que n\u00e3o foram considerados pelos desenvolvedores. d) Porque os testes de seguran\u00e7a devem priorizar a valida\u00e7\u00e3o dos fluxos de uso previstos pelo neg\u00f3cio.</p> <p>Resposta correta: c</p>"},{"location":"tpi_tpe/tpi5_tpe5/#questao-2","title":"Quest\u00e3o 2","text":"<p>Enunciado: Qual das alternativas melhor descreve uma vantagem das inspe\u00e7\u00f5es manuais no processo de teste de seguran\u00e7a?</p> <p>Alternativas: a) Podem ser executadas em curto espa\u00e7o de tempo, principalmente se houver material de apoio dispon\u00edvel. b) Permitem que a verifica\u00e7\u00e3o seja realizada em est\u00e1gios finais do SDLC. c) Podem avaliar pol\u00edticas, habilidades e decis\u00f5es de arquitetura por meio de an\u00e1lise de documenta\u00e7\u00e3o e entrevistas. d) S\u00e3o recomendadas quando n\u00e3o h\u00e1 especialista em seguran\u00e7a dispon\u00edvel para a equipe.</p> <p>Resposta correta: c</p>"},{"location":"tpi_tpe/tpi5_tpe5/#questao-3","title":"Quest\u00e3o 3","text":"<p>Enunciado: Qual \u00e9 o objetivo principal da modelagem de amea\u00e7as (threat modeling) no contexto de seguran\u00e7a de aplica\u00e7\u00f5es?</p> <p>Alternativas: a) Avaliar riscos e antecipar amea\u00e7as para desenvolver estrat\u00e9gias de mitiga\u00e7\u00e3o desde as primeiras fases do SDLC. b) Medir o desempenho da aplica\u00e7\u00e3o em cen\u00e1rios de ataque de DDOS. c) Substituir a an\u00e1lise de c\u00f3digo-fonte na identifica\u00e7\u00e3o de falhas de seguran\u00e7a. d) Testar a efic\u00e1cia das ferramentas automatizadas de seguran\u00e7a, a partir da modelagem da aplica\u00e7\u00e3o.</p> <p>Resposta correta: a</p>"},{"location":"tpi_tpe/tpi5_tpe5/#questao-4","title":"Quest\u00e3o 4","text":"<p>Enunciado: Qual \u00e9 uma limita\u00e7\u00e3o importante da revis\u00e3o de c\u00f3digo-fonte?</p> <p>Alternativas: a) O c\u00f3digo analisado pode n\u00e3o ser o mesmo que ser\u00e1 implantado em produ\u00e7\u00e3o. b) \u00c9 um processo lento, mesmo para desenvolvedores bastante experientes. c) Identifica tipos de vulnerabilidades que poderiam ser detectadas por outros m\u00e9todos. d) \u00c9 realizada apenas nos est\u00e1gios finais do SDLC, reduzindo sua efic\u00e1cia.</p> <p>Resposta correta: a</p>"},{"location":"tpi_tpe/tpi5_tpe5/#questao-5","title":"Quest\u00e3o 5","text":"<p>Enunciado: Qual \u00e9 uma vantagem do teste de penetra\u00e7\u00e3o em aplica\u00e7\u00f5es web?</p> <p>Alternativas: a) Permite modificar o comportamento da aplica\u00e7\u00e3o sem acesso ao ambiente de produ\u00e7\u00e3o. b) Pode ser realizado nos est\u00e1gios iniciais do SDLC, ampliando a capacidade de detec\u00e7\u00e3o de vulnerabilidades. c) Substitui a necessidade de entrevistas e an\u00e1lise documental para detectar vulnerabilidades. d) Avalia o comportamento do c\u00f3digo realmente implantado, mesmo sem conhecer sua implementa\u00e7\u00e3o interna.</p> <p>Resposta correta: d</p>"},{"location":"tpi_tpe/tpi5_tpe5/#questao-6","title":"Quest\u00e3o 6","text":"<p>Enunciado: Qual \u00e9 uma vantagem principal da revis\u00e3o manual do c\u00f3digo-fonte para identificar problemas de seguran\u00e7a em aplica\u00e7\u00f5es web?</p> <p>Alternativas: a) Permite detectar problemas de seguran\u00e7a que outras formas de an\u00e1lise, como testes de penetra\u00e7\u00e3o, podem n\u00e3o identificar. b) Facilita a execu\u00e7\u00e3o sistem\u00e1tica de testes de seguran\u00e7a, por ser um m\u00e9todo caixa-preta. c) Elimina a necessidade de verificar a l\u00f3gica de neg\u00f3cios e o controle de acesso. d) Reduz a necessidade de habilidades t\u00e9cnicas para identificar vulnerabilidades.</p> <p>Resposta correta: a</p>"},{"location":"tpi_tpe/tpi5_tpe5/#questao-7","title":"Quest\u00e3o 7","text":"<p>Enunciado: No processo de deriva\u00e7\u00e3o de requisitos de seguran\u00e7a usando casos de uso e abuso, qual \u00e9 a import\u00e2ncia de descrever cen\u00e1rios negativos, como ataques de for\u00e7a bruta?</p> <p>Alternativas: a) Para garantir que a aplica\u00e7\u00e3o seja capaz de fornecer respostas espec\u00edficas para cada tipo de ataque identificado. b) Para identificar e documentar vulnerabilidades potenciais e as contramedidas necess\u00e1rias para mitigar os riscos associados a ataques. c) Para avaliar a conformidade da aplica\u00e7\u00e3o com regulamentos e padr\u00f5es de seguran\u00e7a aplic\u00e1veis. d) Para implementar controles de seguran\u00e7a que bloqueiem o acesso n\u00e3o autorizado antes do in\u00edcio do desenvolvimento.</p> <p>Resposta correta: b</p>"},{"location":"tpi_tpe/tpi5_tpe5/#questao-8","title":"Quest\u00e3o 8","text":"<p>Enunciado: A prote\u00e7\u00e3o de dados sens\u00edveis, como informa\u00e7\u00f5es pessoalmente identific\u00e1veis (PII), deve envolver a valida\u00e7\u00e3o de qual requisito de seguran\u00e7a?</p> <p>Alternativas: a) A an\u00e1lise de risco baseada no n\u00edvel de sensibilidade do dado. b) A verifica\u00e7\u00e3o do uso de criptografia. c) A verifica\u00e7\u00e3o da conformidade com as pol\u00edticas de seguran\u00e7a da informa\u00e7\u00e3o da empresa. d) A elimina\u00e7\u00e3o do armazenamento de dados sens\u00edveis.</p> <p>Resposta correta: c</p>"},{"location":"tpi_tpe/tpi5_tpe5/#questao-9","title":"Quest\u00e3o 9","text":"<p>Enunciado: Por que os requisitos de seguran\u00e7a baseados em risco (negativos) s\u00e3o mais dif\u00edceis de testar do que os requisitos funcionais (positivos)?</p> <p>Alternativas: a) Porque eles sempre exigem o uso de ferramentas de fuzzing automatizado. b) Porque n\u00e3o podem ser descritos por meio de casos de uso nem validados com testes de penetra\u00e7\u00e3o. c) Porque dependem exclusivamente de verifica\u00e7\u00f5es manuais feitas ap\u00f3s a implanta\u00e7\u00e3o do sistema. d) Porque n\u00e3o descrevem um comportamento esperado, exigindo an\u00e1lise de amea\u00e7as e cen\u00e1rios imprevistos.</p> <p>Resposta correta: d</p>"},{"location":"tpi_tpe/tpi5_tpe5/#questao-10","title":"Quest\u00e3o 10","text":"<p>Enunciado: O que s\u00e3o \"misuse cases\" ou \"abuse cases\" no contexto da engenharia de requisitos de seguran\u00e7a?</p> <p>Alternativas: a) Cen\u00e1rios que descrevem como um sistema pode ser maliciosamente explorado. b) Casos de teste automatizados para validar funcionalidades n\u00e3o documentadas. c) Casos de uso voltados para testes de desempenho em ambientes inseguros. d) Casos que descrevem a experi\u00eancia do usu\u00e1rio em situa\u00e7\u00f5es de erro.</p> <p>Resposta correta: a</p>"},{"location":"tpi_tpe/tpi5_tpe5/#questao-11","title":"Quest\u00e3o 11","text":"<p>Enunciado: Como os testes unit\u00e1rios de seguran\u00e7a contribuem para a valida\u00e7\u00e3o de mudan\u00e7as no c\u00f3digo ap\u00f3s a corre\u00e7\u00e3o de vulnerabilidades?</p> <p>Alternativas: a) Garantem que a nova funcionalidade foi implementada conforme as especifica\u00e7\u00f5es do cliente. b) Verificam se as altera\u00e7\u00f5es no c\u00f3digo mitigam a vulnerabilidade identificada e seguem os padr\u00f5es de codifica\u00e7\u00e3o segura. c) Permitem que o c\u00f3digo com problemas de seguran\u00e7a seja inclu\u00eddo no build desde que esteja documentado. d) Avaliam o impacto das mudan\u00e7as no desempenho do sistema em tempo de execu\u00e7\u00e3o.</p> <p>Resposta correta: b</p>"},{"location":"tpi_tpe/tpi5_tpe5/#questao-12","title":"Quest\u00e3o 12","text":"<p>Enunciado: O que ocorre com um pacote no pipeline DevSecOps quando o resultado das atividades de seguran\u00e7a n\u00e3o atender aos requisitos de um checkpoint?</p> <p>Alternativas: a) O pacote \u00e9 automaticamente modificado para atender aos requisitos de seguran\u00e7a necess\u00e1rios. b) O pacote \u00e9 encaminhado para uma revis\u00e3o externa para verificar a conformidade com os requisitos de seguran\u00e7a. c) O pacote avan\u00e7a para o pr\u00f3ximo est\u00e1gio, mas com uma nota de alerta sobre os requisitos de seguran\u00e7a n\u00e3o atendidos. d) O pacote permanece na fase atual e n\u00e3o \u00e9 permitido avan\u00e7ar para o pr\u00f3ximo checkpoint ou est\u00e1gio.</p> <p>Resposta correta: d</p>"},{"location":"tpi_tpe/tpi5_tpe5/#questao-13","title":"Quest\u00e3o 13","text":"<p>Enunciado: Qual \u00e9 a abordagem recomendada para introduzir recursos de testes de seguran\u00e7a no pipeline de entrega para suportar DevSecOps?</p> <p>Alternativas: a) Introduzir todos os recursos de testes de seguran\u00e7a de forma integral para garantir uma abordagem completa desde o in\u00edcio. b) Investir em ferramentas atualizadas e avan\u00e7adas substituindo as ferramentas existentes para garantir uma integra\u00e7\u00e3o eficiente. c) Realizar a automa\u00e7\u00e3o de controles e atividades de seguran\u00e7a antes de implementar qualquer ferramenta de seguran\u00e7a existente. d) Come\u00e7ar com recursos de testes de seguran\u00e7a de alto valor e baixo impacto, como ferramentas de qualidade de c\u00f3digo, e adicionar novos recursos gradualmente.</p> <p>Resposta correta: d</p>"},{"location":"tpi_tpe/tpi5_tpe5/#questao-14","title":"Quest\u00e3o 14","text":"<p>Enunciado: Qual \u00e9 um benef\u00edcio de utilizar uma su\u00edte de testes de seguran\u00e7a gen\u00e9rica integrada ao framework de testes unit\u00e1rios dos desenvolvedores?</p> <p>Alternativas: a) Permitir a verifica\u00e7\u00e3o das funcionalidades de seguran\u00e7a tanto para requisitos positivos quanto negativos em componentes de software. b) Facilitar a cria\u00e7\u00e3o de novos m\u00f3dulos de software sem a necessidade de an\u00e1lise de c\u00f3digo. c) Identificar problemas de desempenho em tempo real durante a execu\u00e7\u00e3o do c\u00f3digo, em fun\u00e7\u00e3o dos requisitos de seguran\u00e7a adicionais. d) Automatizar os testes, substituindo a necessidade de testes de seguran\u00e7a realizados por engenheiros de seguran\u00e7a especializados.</p> <p>Resposta correta: a</p>"}]}